[{"title":"document.execCommand('copy' / 'cut') 异步调用一二事","url":"http://hysunny.me/2017/12/04/document-execCommand-copy/","content":"<p>最近的wap项目开发中有这样一个需求：</p>\n<p><strong>点击“分享”按钮会生成分享链接，然后自动将该链接复制到剪贴板</strong></p>\n<p>一开始以为很好做：</p>\n<p>点击按钮时调用生成分享链接的接口，然后在回调中执行<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\" target=\"_blank\" rel=\"external\">document.execCommand(‘copy’)</a> 就好啦</p>\n<p>简单示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;share-box&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; class=&quot;share-link&quot; value=&quot;分享链接&quot; /&gt;</div><div class=\"line\">  &lt;button class=&quot;share-btn&quot;&gt;分享&lt;/button&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">$(&apos;.share-btn&apos;).on(&apos;click&apos;, function() &#123;</div><div class=\"line\">  $.ajax(&#123;</div><div class=\"line\">  \turl: &apos;/echo/json/&apos;,</div><div class=\"line\">    method: &apos;post&apos;</div><div class=\"line\">  &#125;).then(rs =&gt; &#123;</div><div class=\"line\">  \t$(&apos;.share-link&apos;).val(&apos;https://xxx.xxx.com/share/xxx&apos;).select()</div><div class=\"line\">   \tdocument.execCommand(&apos;copy&apos;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，现实总会狠狠打脸</p>\n<p>回调中的<code>document.execCommand(&#39;copy&#39;)</code>并没有执行</p>\n<p>效果查看：</p>\n<script async src=\"//jsfiddle.net/hysunny/939upv6n/embed/\"></script>\n\n<p>查看<a href=\"https://www.w3.org/TR/clipboard-apis/#clipboard-event-copy\" target=\"_blank\" rel=\"external\">规范</a>后得知：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">These are the steps to follow when triggering copy, cut or paste actions through a scripting API:</div><div class=\"line\"></div><div class=\"line\">1. Execute the corresponding action synchronously.</div><div class=\"line\">2. Use the action’s return value as the return value for the API call.</div><div class=\"line\"></div><div class=\"line\">Note: Copy and cut commands triggered through a scripting API will only affect the contents of the real clipboard if the event is dispatched from an event that is trusted and triggered by the user, or if the implementation is configured to allow this. Paste commands triggered through a scripting API will only fire paste events and give access to clipboard contents if the implementation is configured to allow this. How implementations can be configured to allow read or write access to the clipboard is outside the scope of this specification.</div></pre></td></tr></table></figure>\n<p>也就是说：<code>document.execCommand(&#39;copy&#39;)</code>必须是<strong>由用户触发，并且这个操作是同步地</strong>。</p>\n<p>所以，这个需求并不是我不想做，而是无能为力啊(´_ゝ`)</p>\n<p>最后，改成了<strong>点击“分享”生成链接后再弹出个弹窗，然后再点击“复制链接”按钮后复制链接</strong>，简单示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;share-box&quot;&gt;</div><div class=\"line\">  &lt;input type=&quot;text&quot; class=&quot;share-link&quot; value=&quot;分享链接&quot; /&gt;</div><div class=\"line\">  &lt;button class=&quot;share-btn&quot;&gt;分享&lt;/button&gt;</div><div class=\"line\">  &lt;button class=&quot;copy-link&quot;&gt;复制链接&lt;/button&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">$(&apos;.share-btn&apos;).on(&apos;click&apos;, function() &#123;</div><div class=\"line\">  $.ajax(&#123;</div><div class=\"line\">  \turl: &apos;/echo/json/&apos;,</div><div class=\"line\">    method: &apos;post&apos;</div><div class=\"line\">  &#125;).then(rs =&gt; &#123;</div><div class=\"line\">  \t $(&apos;.share-link&apos;).val(&apos;https://xxx.xxx.com/share/xxx&apos;)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">$(&apos;.copy-link&apos;).on(&apos;click&apos;, function() &#123;</div><div class=\"line\">  $(&apos;.share-link&apos;).select()</div><div class=\"line\">  document.execCommand(&apos;copy&apos;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>效果可查看： </p>\n<script async src=\"//jsfiddle.net/hysunny/vzh37p9y/embed/\"></script>\n","categories":[],"tags":[]},{"title":"JavaScript 实现 —— 将一个数组插入另一个数组中","url":"http://hysunny.me/2017/11/25/insert-array-to-array/","content":"<p><code>JavaScript</code>将一个数组插入到另一个数组中</p>\n<p>方法一：<code>unshift</code> + <code>splice</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];   </div><div class=\"line\">var arr2 = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];   </div><div class=\"line\">var index = 2;   </div><div class=\"line\">arr2.unshift(index, 0);  </div><div class=\"line\">Array.prototype.splice.apply(arr1, arr2);   </div><div class=\"line\">console.log(arr1);     // [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>\n<p>方法二：<code>splice</code> + <code>concat</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];   </div><div class=\"line\">var arr2 = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;];   </div><div class=\"line\">var index = 2;   </div><div class=\"line\">arr1.splice.apply(arr1, [index, 0].concat(arr2));</div><div class=\"line\">console.log(arr1);     // [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>\n<p>方法三: <code>splice +</code>ES6 rest`</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];   </div><div class=\"line\">var arr2 = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]; </div><div class=\"line\">arr1.splice(2, 0, ...arr2)</div><div class=\"line\">console.log(arr1) \t//  [&quot;a&quot;, &quot;b&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;c&quot;]</div></pre></td></tr></table></figure>\n","categories":[],"tags":[]},{"title":"Event target 与 currentTarget 的区别","url":"http://hysunny.me/2017/10/29/the-difference-between-target-and-currentTarget/","content":"<ol>\n<li><p><code>target</code>: 触发事件的某个具体对象，只会出现在事件流的<strong>目标阶段</strong>，谁触发谁命中;</p>\n</li>\n<li><p><code>currentTarget</code>: 绑定事件的对象，可能出现在事件流的<strong>任意一个阶段</strong>（捕获、目标及冒泡）中;</p>\n</li>\n<li><p>只有当事件流处于目标阶段时，<code>target</code>和<code>currentTarget</code>才是一致的。</p>\n</li>\n</ol>\n<p>举例：</p>\n<script async src=\"//jsfiddle.net/hysunny/c1kyvLw9/embed/\"></script>\n\n<p>运行代码可以看到：</p>\n<p><img src=\"/images/event-demo.png\" alt=\"示例\"></p>\n<p>说明：上面代码中，<code>div</code>标签嵌套了<code>p</code>标签，并且在父元素中绑定了点击事件，当单击“click me”时，根据<a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\" target=\"_blank\" rel=\"external\">W3C</a>规定，该示例的整个事件流流程如下图：</p>\n<p><img src=\"/images/event-flow.png\" alt=\"event-flow\"></p>\n<p>通过上图，我们应该可以很容易区分<code>target</code>和<code>currentTarget</code>了。</p>\n","categories":[],"tags":[]},{"title":"Vue 2.0 patch 原理分析","url":"http://hysunny.me/2017/10/02/vue-compile/","content":"<blockquote>\n<p>本文基于<a href=\"https://github.com/vuejs/vue/tree/v2.4.4\" target=\"_blank\" rel=\"external\">vue-2.4.4</a>源码进行分析</p>\n</blockquote>\n<p>Vue 2.0开始，引入<code>VirtualDOM</code>。</p>\n<p>使用<code>VirtualDOM</code>而不使用真实<code>DOM</code>是出于性能优化的考虑。</p>\n<p>真实<code>DOM</code>使用<code>document.createElement</code>创建DOM元素，但是这个方法会带来性能上的损失。</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">let div = document.createElement(&apos;div&apos;);</div><div class=\"line\">let count = 0</div><div class=\"line\">for(let k in div) &#123;</div><div class=\"line\">\tcount++</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(count)\t// 231</div></pre></td></tr></table></figure>\n<p>执行上面的代码，我们可以看到该方法创建的<code>DOM</code>元素的属性多达231个，但是我们真正需要的可能只有不到10%。</p>\n<p>为了解决这个问题，<code>VirtualDOM</code>应运而生。它和真实<code>DOM</code>保持映射关系，每个<code>VNode</code>节点都存储了对应真实<code>DOM</code>节点的一些重要参数，当数据发生改变时，在改变真实<code>DOM</code>节点之前，会先比较相应的VNode的的数据，如果需要改变，才更新真实<code>DOM</code>。这样就可以通过操作<code>VirtualDOM</code>来提高直接操作<code>DOM</code>的效率和性能。</p>\n<p>比较<code>VNode</code>数据这个操作就是我们今天要讨论的<code>patch</code>，在讨论之前，我们先简单说下<code>VNode</code>。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>在上篇<a href=\"http://www.jianshu.com/p/761bca5b34a0\" target=\"_blank\" rel=\"external\">Vue 2.0 模板编译源码分析</a>中我们得出模板编译的结果是<code>render function</code>。</p>\n<p><code>render function</code>的运行结果就是<code>VNode</code>， 参考<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/instance/render.js\" target=\"_blank\" rel=\"external\">src/core/instance/render.js</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.prototype._render = function (): VNode &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  const &#123;</div><div class=\"line\">\trender,</div><div class=\"line\">\tstaticRenderFns,</div><div class=\"line\">\t_parentVnode</div><div class=\"line\">  &#125; = vm.$options</div><div class=\"line\">  ... </div><div class=\"line\">  vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Vue 2.0中的<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"external\">VNode</a>(src/core/vdom/vnode.js)定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">export default class VNode &#123;</div><div class=\"line\">constructor (</div><div class=\"line\">    tag?: string,</div><div class=\"line\">    data?: VNodeData,</div><div class=\"line\">    children?: ?Array&lt;VNode&gt;,</div><div class=\"line\">    text?: string,</div><div class=\"line\">    elm?: Node,</div><div class=\"line\">    context?: Component,</div><div class=\"line\">    componentOptions?: VNodeComponentOptions,</div><div class=\"line\">    asyncFactory?: Function</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    this.tag = tag    // 元素标签</div><div class=\"line\">    this.data = data    // 属性</div><div class=\"line\">    this.children = children    // 子元素列表</div><div class=\"line\">    this.text = text</div><div class=\"line\">    this.elm = elm    //  对应的真实 DOM 元素</div><div class=\"line\">    this.ns = undefined</div><div class=\"line\">    this.context = context</div><div class=\"line\">    this.functionalContext = undefined</div><div class=\"line\">    this.key = data &amp;&amp; data.key</div><div class=\"line\">    this.componentOptions = componentOptions</div><div class=\"line\">    this.componentInstance = undefined</div><div class=\"line\">    this.parent = undefined</div><div class=\"line\">    this.raw = false</div><div class=\"line\">    this.isStatic = false     // 是否被标记为静态节点</div><div class=\"line\">    this.isRootInsert = true</div><div class=\"line\">    this.isComment = false</div><div class=\"line\">    this.isCloned = false</div><div class=\"line\">    this.isOnce = false</div><div class=\"line\">    this.asyncFactory = asyncFactory</div><div class=\"line\">    this.asyncMeta = undefined</div><div class=\"line\">    this.isAsyncPlaceholder = false</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>它是真实<code>DOM</code>的简化版，与真实<code>DOM</code>一一对映。通过<code>new</code>实例化的<code>VNode</code>可以分为：<code>EmptyVNode</code>（注释节点）、<code>TextVNode</code>（文本节点）、<code>ElementVNode</code>（元素节点）、<code>ComponentVNode</code>（组件节点）、<code>CloneVNode</code>（克隆节点）等。</p>\n<h3 id=\"patch原理\"><a href=\"#patch原理\" class=\"headerlink\" title=\"patch原理\"></a>patch原理</h3><p>再拉通一下整个思路，目前我们晓得</p>\n<p><code>render function</code> 生成 <code>VNode</code>，是在 <code>vm._render</code> 里完成的。</p>\n<p>那么<code>vm._render</code>方法又是在什么时候调用的呢？</p>\n<p><code>debugger</code>一下代码，可以看到流程如下：</p>\n<p><img src=\"/images/vue-render.png\" alt=\"\"></p>\n<p>初始化时，通过<code>render function</code> 生成 <code>VNode</code>的同时进行<code>Watcher</code>的绑定。当数据发生会变化时，会执行<code>_update</code>方法，生成一个<strong>新的</strong><code>VNode</code>对象，然后调用<code>__patch__</code>方法，比较新生成的<code>VNode</code>和旧的<code>VNode</code>，最后将差异（变化的节点）更新到真实的<code>DOM</code>树上。</p>\n<p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/vdom/patch.js\" target=\"_blank\" rel=\"external\">patch</a>(src/core/vdom/patch.js)所用的diff算法来源于<a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"external\">snabbdom</a>，只会在同层级进行比较，不会跨层级比较。图示如下：</p>\n<p><img src=\"/images/vue-diff.png\" alt=\"diff algorithm (by Christopher Chedeau)\"></p>\n<p>下面结合源码进行原理分析：</p>\n<h4 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h4><p>patch方法接收6个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) &#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>oldVnode</code>: 旧的<code>VNode</code>或旧的真实<code>DOM</code>节点</li>\n<li><code>vnode</code>: 新的<code>VNode</code></li>\n<li><code>hydrating</code>: 是否要和真实<code>DOM</code>混合</li>\n<li><code>removeOnly</code>: 特殊的flag，用于<code>&lt;transition-group&gt;</code></li>\n<li><code>parentElm</code>: 父节点</li>\n<li><code>refElm</code>: 新节点将插入到<code>refElm</code>之前</li>\n</ul>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><ol>\n<li><p>如果<code>vnode</code>不存在，但是<code>oldVnode</code>存在，说明是需要销毁旧节点，则调用<code>invokeDestroyHook(oldVnode)</code>来销毁<code>oldVnode</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isUndef(vnode)) &#123;</div><div class=\"line\">  if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</div><div class=\"line\">  return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>如果<code>vnode</code>存在，但是<code>oldVnode</code>不存在，说明是需要创建新节点，则调用<code>createElm</code>来创建新节点。 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isUndef(oldVnode)) &#123;</div><div class=\"line\">    isInitialPatch = true\t// 用于做延迟插值处理</div><div class=\"line\">    createElm(vnode, insertedVnodeQueue, parentElm, refElm)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>当<code>vnode</code>和<code>oldVnode</code>都存在时</p>\n<ul>\n<li>3.1 如果oldVnode不是真实节点，并且<code>vnode</code>和<code>oldVnode</code>是同一节点时，说明是需要比较新旧节点，则调用<code>patchVnode</code>进行<code>patch</code>。</li>\n<li>3.2 如果<code>oldVnode</code>是真实节点时<ul>\n<li>3.2.1 如果oldVnode是元素节点，且含有<code>data-server-rendered</code>属性时，移除该属性，并设置<code>hydrating</code>为<code>true</code>。</li>\n<li>3.2.2 如果<code>hydrating</code>为<code>true</code>时，调用<code>hydrate</code>方法，将<code>Virtural DOM</code>与真实<code>DOM</code>进行映射，然后将<code>oldVnode</code>设置为对应的<code>Virtual DOM</code>。</li>\n</ul>\n</li>\n<li><p>3.3 如果<code>oldVnode</code>是真实节点时或<code>vnode</code>和<code>oldVnode</code>不是同一节点时，找到<code>oldVnode.elm</code>的父节点，根据<code>vnode</code>创建一个真实的<code>DOM</code>节点，并插入到该父节点中的<code>oldVnode.elm</code>位置。如果组件根节点被替换，遍历更新父节点<code>element</code>。然后移除旧节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t// 3. 当vnode和oldVnode都存在时</div><div class=\"line\">\tconst isRealElement = isDef(oldVnode.nodeType)</div><div class=\"line\">     if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</div><div class=\"line\">     \t // 3.1 如果oldVnode不是真实节点，并且vnode和oldVnode是同一节点时</div><div class=\"line\">       // patch existing root node</div><div class=\"line\">       patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">       if (isRealElement) &#123;</div><div class=\"line\">       \t// 3.2 如果oldVnode是真实节点时</div><div class=\"line\">         // mounting to a real element</div><div class=\"line\">         // check if this is server-rendered content and if we can perform</div><div class=\"line\">         // a successful hydration.</div><div class=\"line\">         if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</div><div class=\"line\">           // 3.2.1 如果oldVnode是元素节点，且含有`data-server-rendered`属性时</div><div class=\"line\">           oldVnode.removeAttribute(SSR_ATTR)</div><div class=\"line\">           hydrating = true</div><div class=\"line\">         &#125;</div><div class=\"line\">         if (isTrue(hydrating)) &#123;</div><div class=\"line\">           // 3.2.2 如果hydrating为true时</div><div class=\"line\">           if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</div><div class=\"line\">             invokeInsertHook(vnode, insertedVnodeQueue, true)</div><div class=\"line\">             return oldVnode</div><div class=\"line\">           &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</div><div class=\"line\">             warn(</div><div class=\"line\">               &apos;The client-side rendered virtual DOM tree is not matching &apos; +</div><div class=\"line\">               &apos;server-rendered content. This is likely caused by incorrect &apos; +</div><div class=\"line\">               &apos;HTML markup, for example nesting block-level elements inside &apos; +</div><div class=\"line\">               &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; +</div><div class=\"line\">               &apos;full client-side render.&apos;</div><div class=\"line\">             )</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         // either not server-rendered, or hydration failed.</div><div class=\"line\">         // create an empty node and replace it</div><div class=\"line\">         oldVnode = emptyNodeAt(oldVnode)</div><div class=\"line\">       &#125;</div><div class=\"line\">       // 3.3 </div><div class=\"line\">       // replacing existing element</div><div class=\"line\">       const oldElm = oldVnode.elm</div><div class=\"line\">       const parentElm = nodeOps.parentNode(oldElm)</div><div class=\"line\">       createElm(</div><div class=\"line\">         vnode,</div><div class=\"line\">         insertedVnodeQueue,</div><div class=\"line\">         oldElm._leaveCb ? null : parentElm,</div><div class=\"line\">         nodeOps.nextSibling(oldElm)</div><div class=\"line\">       )</div><div class=\"line\"></div><div class=\"line\">       if (isDef(vnode.parent)) &#123;</div><div class=\"line\">         // component root element replaced.</div><div class=\"line\">         // update parent placeholder node element, recursively</div><div class=\"line\">         let ancestor = vnode.parent</div><div class=\"line\">         const patchable = isPatchable(vnode)</div><div class=\"line\">         while (ancestor) &#123;</div><div class=\"line\">           for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123;</div><div class=\"line\">             cbs.destroy[i](ancestor)</div><div class=\"line\">           &#125;</div><div class=\"line\">           ancestor.elm = vnode.elm</div><div class=\"line\">           if (patchable) &#123;</div><div class=\"line\">             for (let i = 0; i &lt; cbs.create.length; ++i) &#123;</div><div class=\"line\">               cbs.create[i](emptyNode, ancestor)</div><div class=\"line\">             &#125;</div><div class=\"line\">             const insert = ancestor.data.hook.insert</div><div class=\"line\">             if (insert.merged) &#123;</div><div class=\"line\">               // start at index 1 to avoid re-invoking component mounted hook</div><div class=\"line\">               for (let i = 1; i &lt; insert.fns.length; i++) &#123;</div><div class=\"line\">                 insert.fns[i]()</div><div class=\"line\">               &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           ancestor = ancestor.parent</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       if (isDef(parentElm)) &#123;</div><div class=\"line\">       \t// 移除老节点</div><div class=\"line\">         removeVnodes(parentElm, [oldVnode], 0, 0)</div><div class=\"line\">       &#125; else if (isDef(oldVnode.tag)) &#123;</div><div class=\"line\">         invokeDestroyHook(oldVnode)</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>最后返回 <code>vnode.elm</code>。</p>\n</li>\n</ol>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>由上面的流程我们知道了当<code>vnode</code>和<code>oldVnode</code>都存在、<code>oldVnode</code>不是真实节点，并且<code>vnode</code>和<code>oldVnode</code>是同一节点时，才会调用<code>patchVnode</code>进行<code>patch</code>。</p>\n<p>下面根据<code>patchVnode</code>源码分析patch的原理：</p>\n<ol>\n<li>如果<code>oldVnode</code>和<code>vnode</code>完全一致，则可认为没有变化，<code>return</code>；</li>\n<li>如果<code>oldVnode</code>的<code>isAsyncPlaceholder</code>属性为<code>true</code>时，跳过检查异步组件，<code>return</code>；</li>\n<li>如果<code>oldVnode</code>跟<code>vnode</code>都是静态节点，且具有相同的<code>key</code>，并且当<code>vnode</code>是克隆节点或是<code>v-once</code>指令控制的节点时，只需要把<code>oldVnode.elm</code>和<code>oldVnode.child</code>都复制到<code>vnode</code>上，也不用再有其他操作，<code>return</code>；</li>\n<li><p>否则，如果vnode不是文本节点时</p>\n<ul>\n<li><p>4.1 如果<code>vnode</code>和<code>oldVnode</code>都有子节点并且两者的子节点不一致时，就调用<code>updateChildren</code>更新子节点。<code>updateChildren</code>方法详细的解析可参考<a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"external\">解析vue2.0的diff算法</a>，图示说明，很形象。</p>\n</li>\n<li><p>4.2 如果只有<code>vnode</code>有子节点，则调用<code>addVnodes</code>创建子节点；</p>\n</li>\n<li>4.3 如果只有<code>oldVnode</code>有子节点，则调用<code>removeVnodes</code>把这些节点都删除；     </li>\n<li>4.4 如果<code>oldVnode</code>和<code>vnode</code>都没有子节点，但是<code>oldVnode</code>是文本节点时，则把<code>vnode.elm</code>的文本设置为空字符串；</li>\n</ul>\n</li>\n<li><p>如果<code>vnode</code>是文本节点但是<code>vnode.text != oldVnode.text</code>时只需要更新<code>vnode.elm</code>的文本内容就可以。</p>\n</li>\n</ol>\n<p>原理流程图如下：</p>\n<p><img src=\"/images/vue-patch-flow.png\" alt=\"\"></p>\n<p>自此，Vue的patch原理就分析完了。</p>\n","categories":[],"tags":[]},{"title":"Vue.js 2.0 模板编译源码分析","url":"http://hysunny.me/2017/09/28/vue-render/","content":"<blockquote>\n<p>本文基于<a href=\"https://github.com/vuejs/vue/tree/v2.4.4\" target=\"_blank\" rel=\"external\">vue-2.4.4</a>源码进行分析</p>\n</blockquote>\n<p>模板编译是Vue 2.0中很重要的一个环节，它将<code>template</code>编译成<code>render</code> 函数，最后生成<code>Virtual DOM</code>渲染在页面。</p>\n<p>本篇文章将结合源码对<strong>模板编译</strong>流程进行分析：</p>\n<p>从源码角度看，模板编译主要经历如下流程：</p>\n<p><img src=\"/images/vue-compile.png\" alt=\"vue-compile.png\"></p>\n<p>即：</p>\n<p>首先，在项目初始化时<code>挂载DOM节点</code>并<code>获取template</code></p>\n<p>然后将 <code>template</code> 编译成 <code>render 函数</code>。这个编译过程包含：</p>\n<ol>\n<li>check 缓存，如果有缓存数据就读取缓存数据</li>\n<li>获取并合并options</li>\n<li>parse: 将template解析成AST</li>\n<li>optimize: 标记静态节点</li>\n<li>generate: 拼接 render function 字符串</li>\n<li>通过 new function 生成渲染函数</li>\n<li>缓存</li>\n</ol>\n<p>其中，3、4、5是整个模板编译的核心。</p>\n<p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/index.js\" target=\"_blank\" rel=\"external\">baseCompile</a>函数（src/compiler/index.js）依次执行<code>parse</code>，<code>optimize</code>，和<code>generate</code>，最后返回一个包含<code>ast</code>、<code>render</code>和<code>staticRenderFns</code>的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 3. parse: 将template解析成AST</span></div><div class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</div><div class=\"line\">  <span class=\"comment\">// 4. optimize: 标记静态节点</span></div><div class=\"line\">  optimize(ast, options)</div><div class=\"line\">  <span class=\"comment\">// 5. generate: 拼接 render function 字符串</span></div><div class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    ast,</div><div class=\"line\">    render: code.render,</div><div class=\"line\">    staticRenderFns: code.staticRenderFns</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"parse-将template解析成AST\"><a href=\"#parse-将template解析成AST\" class=\"headerlink\" title=\"parse: 将template解析成AST\"></a>parse: 将template解析成AST</h3><p>这里，先简单介绍下AST。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9\" target=\"_blank\" rel=\"external\">AST</a>全称是：Abstract Syntax Tree (抽象语法树)，是源代码语法所对应的树状结构。Vue 2.0中ASTNode有三种形式：<code>ASTElement</code>、<code>ASTText</code>、<code>ASTExpression</code>。</p>\n<p>Vue 2.0中的<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/parser/index.js\" target=\"_blank\" rel=\"external\">parse</a>函数（src/compiler/parser/index.js）采用了jQuery作者<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E9%9B%B7%E8%A5%BF%E6%A0%BC\" target=\"_blank\" rel=\"external\">John Resig</a>的<a href=\"https://johnresig.com/files/htmlparser.js\" target=\"_blank\" rel=\"external\">HTML Parser</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">parseHTML(template, &#123;</div><div class=\"line\">  start (tag, attrs, unary) &#123;</div><div class=\"line\">  \t// 解析到新的节点时调用，包括节点tagName, attributes等信息</div><div class=\"line\">  &#125;,</div><div class=\"line\">  end () &#123;</div><div class=\"line\">  \t// 节点解析结束时调用，包括节点tagName等信息</div><div class=\"line\">  &#125;,</div><div class=\"line\">  chars (text: string) &#123;</div><div class=\"line\">  \t// 文本解析完成时调用，包括文本本身</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如：<code>&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;</code></p>\n<p><code>parseHTML</code>后的结果是：</p>\n<p><img src=\"/images/ast.png\" alt=\"ast.png\"></p>\n<h3 id=\"optimize-标记静态节点\"><a href=\"#optimize-标记静态节点\" class=\"headerlink\" title=\"optimize: 标记静态节点\"></a>optimize: 标记静态节点</h3><p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/optimizer.js\" target=\"_blank\" rel=\"external\">optimize</a>函数（src/compiler/optimizer.js）会对静态节点打标，提取最大的静态树，在后面patch时，被标记为static的节点将直接跳过diff。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">optimize</span> (<span class=\"params\">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span></div><div class=\"line\">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class=\"string\">''</span>)</div><div class=\"line\">  isPlatformReservedTag = options.isReservedTag || no</div><div class=\"line\">  <span class=\"comment\">// first pass: mark all non-static nodes.</span></div><div class=\"line\">  markStatic(root)</div><div class=\"line\">  <span class=\"comment\">// second pass: mark static roots.</span></div><div class=\"line\">  markStaticRoots(root, <span class=\"literal\">false</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"generate-拼接-render-function-字符串\"><a href=\"#generate-拼接-render-function-字符串\" class=\"headerlink\" title=\"generate: 拼接 render function 字符串\"></a>generate: 拼接 render function 字符串</h3><p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/codegen/index.js\" target=\"_blank\" rel=\"external\">generate</a>函数（src/compiler/codegen/index.js）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span> (<span class=\"params\"></span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  ast: ASTElement | void,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CodegenResult</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> state = <span class=\"keyword\">new</span> CodegenState(options)</div><div class=\"line\">  <span class=\"keyword\">const</span> code = ast ? genElement(ast, state) : <span class=\"string\">'_c(\"div\")'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    render: <span class=\"string\">`with(this)&#123;return <span class=\"subst\">$&#123;code&#125;</span>&#125;`</span>,</div><div class=\"line\">    staticRenderFns: state.staticRenderFns</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>模板编译的核心：<code>template</code>  →  <code>AST</code> →  <code>render function</code></p>\n<p><img src=\"/images/vue-compile-flow.png\" alt=\"vue-comile-flow.png\"></p>\n","categories":[],"tags":[]},{"title":"JavaScript深入理解 —— 原型、原型链和继承","url":"http://hysunny.me/2017/09/17/javascript-prototype/","content":"<h2 id=\"普通对象和函数对象\"><a href=\"#普通对象和函数对象\" class=\"headerlink\" title=\"普通对象和函数对象\"></a>普通对象和函数对象</h2><p>函数对象：使用<code>函数声明</code>、<code>函数表达式</code>、<code>Function构造函数</code>创建的对象</p>\n<blockquote>\n<p>函数实际上是对象，每个函数都是<code>Function</code>类型的实例，而且都与其他引用类型一样具有属性和方法。</p>\n</blockquote>\n<p>普通对象：除了<code>函数对象</code>以外的对象，都是普通对象。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 定义函数的三个方法</div><div class=\"line\">function f1() &#123;&#125;;\t\t// 函数声明</div><div class=\"line\">var f2 = function() &#123;&#125;;\t\t\t// 函数表达式</div><div class=\"line\">var f3 = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);\t\t// Function构造函数</div><div class=\"line\"></div><div class=\"line\">// 创建对象</div><div class=\"line\">var o1 = &#123;&#125;; \t\t// 对象字面量</div><div class=\"line\">var o2 = new Object();\t\t// Object构造函数</div><div class=\"line\">var o3 = new f1();\t\t// f1构造函数</div><div class=\"line\"></div><div class=\"line\">// 检测类型</div><div class=\"line\">console.log(typeof Function);  //function</div><div class=\"line\">console.log(typeof Object);  //function</div><div class=\"line\"></div><div class=\"line\">console.log(typeof f1);  //function</div><div class=\"line\">console.log(typeof f2);  //function</div><div class=\"line\">console.log(typeof f3);  //function</div><div class=\"line\"></div><div class=\"line\">console.log(typeof o1);  //object</div><div class=\"line\">console.log(typeof o2);  //object</div><div class=\"line\">console.log(typeof o3);  //object</div></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>构造函数： 通过<code>new</code>关键字方式调用的函数。</p>\n<p>在构造函数内部（也就是被调用的函数内）：</p>\n<ol>\n<li><code>this</code> 指向实例对象 <code>Object</code>；</li>\n<li>这个实例对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code>；</li>\n<li>这个实例对象的<code>constructor</code>属性指向<code>构造函数</code>；</li>\n<li>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 —— 也就是实例对象。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name) &#123;</div><div class=\"line\">\tthis.name = name;</div><div class=\"line\">\tthis.sayName = function() &#123;</div><div class=\"line\">\t\tconsole.log(this.name);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">var person1 = new Person(&quot;Hysunny&quot;);</div><div class=\"line\">var person2 = new Person(&quot;Max&quot;);</div><div class=\"line\"></div><div class=\"line\">console.log(person1 instanceof Person);\t\t// true</div><div class=\"line\">console.log(person1.constructor === person2.constructor);\t\t// true</div><div class=\"line\"></div><div class=\"line\">// 实例的__proto__属性指向构造函数的prototype</div><div class=\"line\">console.log(person1.__proto__ === Person.prototype);\t\t// true</div><div class=\"line\"></div><div class=\"line\">// 实例的constructor指向构造函数</div><div class=\"line\">console.log(person1.constructor === Person);\t\t// true</div></pre></td></tr></table></figure>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><p>在 JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中就包含<code>prototype</code>属性，这个属性指向函数的<code>原型对象</code>。</p>\n<ol>\n<li>原型对象是一个<code>普通对象</code>(除<code>Function.prototype</code>之外)，存储所有实例对象共享的方法和属性；</li>\n<li>构造函数原型对象是<code>构造函数</code>的一个实例。</li>\n<li>原型对象的<code>constructor</code>属性指向<code>prototype</code>属性所在的函数；</li>\n<li>每个对象都有 <code>__proto__</code> 属性，但只有函数对象才有 <code>prototype</code> 属性，这两个属性指向函数的<strong>原型对象</strong>。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Person(name) &#123;</div><div class=\"line\">  this.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype. sayName = function() &#123;</div><div class=\"line\">  console.log(this.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var person1 = new Person(&quot;Hysunny&quot;);</div><div class=\"line\">var person2 = new Person(&quot;Max&quot;);</div><div class=\"line\"></div><div class=\"line\">// 构造函数、原型对象和实例之间有这样的联系</div><div class=\"line\">Person.prototype.constructor === Person;</div><div class=\"line\">person1.__proto__ === Person.prototype;</div><div class=\"line\">person1.constructor === Person;</div><div class=\"line\"></div><div class=\"line\">console.log(person1.constructor === Person);\t\t// true</div><div class=\"line\">console.log(Person.prototype.constructor === Person);\t\t// true</div><div class=\"line\">console.log(Person.prototype.constructor === person1.constructor);\t\t// true</div><div class=\"line\">// =&gt; 原型对象是构造函数的一个实例</div><div class=\"line\"></div><div class=\"line\">console.log(Person.prototype.constructor == Person);\t\t// true</div><div class=\"line\">// =&gt; 原型对象的constructor属性指向prototype属性所在的函数</div><div class=\"line\"></div><div class=\"line\">console.log(person1.__proto__ === Person.prototype);\t\t// true</div><div class=\"line\">// =&gt; __proto__属性指向函数的原型对象</div></pre></td></tr></table></figure>\n<p><strong>注：</strong> <code>Function.prototype</code>虽为函数对象，但是是个空函数，没有<code>prototype</code>属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(typeof Function.prototype) // function</div><div class=\"line\">console.log(typeof Function.prototype.prototype) // undefined</div></pre></td></tr></table></figure>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>从上面的分析我们可以知道：JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个<code>__proto__</code>内置属性，用于指向创建它的函数对象的原型对象<code>prototype</code>。</p>\n<p>以上面的例子为例：</p>\n<ol>\n<li><code>person1</code>具有<code>__proto__</code>属性，指向<code>Person.prototype</code></li>\n<li><code>Person.prototype</code>具有<code>__proto__</code>属性，指向<code>Object.prototype</code></li>\n<li><code>Object.prototype</code>具有<code>__proto__</code>属性，指向<code>null</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(person1.__proto__ === Person.prototype) // true</div><div class=\"line\">console.log(Person.prototype.__proto__ === Object.prototype) // true</div><div class=\"line\">console.log(Object.prototype.__proto__) // null</div></pre></td></tr></table></figure>\n<p>这些<code>__proto__</code>串起来，就构成了原型链，原型链的顶端为<code>null</code>。绘出原型链图如下：</p>\n<p><img src=\"/images/prototype-chain.png\" alt=\"原型链\"></p>\n<p>简化如下：<br><img src=\"/images/prototype.png\" alt=\"原型链\"></p>\n<p>疑点解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. Object.__proto__ === Function.prototype \t// true</div><div class=\"line\">// Object是函数对象，是通过new Function()创建，所以Object.__proto__指向Function.prototype。</div><div class=\"line\"></div><div class=\"line\">2. Function.__proto__ === Function.prototype\t\t// true</div><div class=\"line\">// Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。</div><div class=\"line\"></div><div class=\"line\">3. Function.prototype.__proto__ === Object.prototype // true</div><div class=\"line\">// Function本身也是一个构造函数，所以`Function.prototype.__proto__`指向`Object.prototype`</div></pre></td></tr></table></figure>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><blockquote>\n<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <code>接口继承</code> 和 <code>实现继承</code> 。接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>\n</blockquote>\n<p>为什么要实现继承呢？</p>\n<p>最重要的原因之一就是为了<code>抽象（复用代码）</code></p>\n<p>将公共的代码封装成一个基类，其他子类继承基类，并发展自己特有的属性和样式。</p>\n<p>关于实现<code>继承</code>的方式，我们将在下一篇文章中进行讨论。</p>\n<hr>\n<p>参考资料：</p>\n<p>《JavaScript 高级程序设计》 第三版</p>\n<p><a href=\"http://www.jianshu.com/p/e241568f8d3f\" target=\"_blank\" rel=\"external\">js原型与原型链终极详解</a></p>\n","categories":[],"tags":[]},{"title":"JavaScript深入理解 —— 创建对象","url":"http://hysunny.me/2017/09/16/javascript-create-object/","content":"<p>JavaScript中创建对象的方式有很多种，下面对这些方法进行分析和优缺点对比。</p>\n<h2 id=\"Object构造函数\"><a href=\"#Object构造函数\" class=\"headerlink\" title=\"Object构造函数\"></a>Object构造函数</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">\"Hysunny\"</span>;</div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong> </p>\n<p>使用同一个接口创建很多对象，会产生大量的重复代码。</p>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">\"Hysunny\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong> </p>\n<p>同Object构造函数。使用同一个接口创建很多对象，会产生大量的重复代码。</p>\n<h3 id=\"Object-create-方式\"><a href=\"#Object-create-方式\" class=\"headerlink\" title=\"Object.create 方式\"></a>Object.create 方式</h3><blockquote>\n<p>Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = &#123;</div><div class=\"line\">  name: <span class=\"string\">\"Hysunny\"</span>,</div><div class=\"line\">  sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"built_in\">Object</span>.create(Person);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"built_in\">Object</span>.create(Person);</div><div class=\"line\"></div><div class=\"line\">person1.sayName();\t<span class=\"comment\">// \"Hysunny\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);    <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>单例继承，语法简单。</p>\n<p><strong>缺点：</strong></p>\n<p>封装性不好，多实例需要重复初始化过程。</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">\to.name = name;</div><div class=\"line\">\to.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">\"Max\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>实现函数封装，无数次调用，都返回一个对象。</p>\n<p><strong>缺点：</strong></p>\n<p>无法识别对象，因为所有实例的<code>constructor</code>都指向<code>Object</code>。</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><blockquote>\n<p>构造函数：通过<code>new</code>关键字方式调用的函数。</p>\n<p>在构造函数内部（也就是被调用的函数内）：<br><code>this</code> 指向新创建的实例对象 <code>Object</code>；<br>这个新创建的实例对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code>；<br>这个新创建的实例对象的<code>constructor</code>属性指向<code>构造函数</code>；<br>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 —— 也就是实例对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName)  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>通过<code>constructor</code>或者<code>instanceof</code>可以识别对象实例的类别。</p>\n<p><strong>缺点：</strong></p>\n<p>浪费内存。每个方法都要在每个实例上重新创建一遍。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><blockquote>\n<p>原型（prototype）：每个<strong>函数对象</strong>都有一个 <code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。原型对象（Person.prototype）是 构造函数（Person）的一个实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">Person.prototype.name = <span class=\"string\">\"Hysunny\"</span>;</div><div class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">person1.sayName();    <span class=\"comment\">// Hysunny</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">person2.sayName();\t\t<span class=\"comment\">// Hysunny</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName)   <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<ol>\n<li>通过<code>prototype</code>添加的属性和方法所有实例共享</li>\n<li>可以动态的添加原型对象的属性和方法，并直接反映到实例上</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>实例无法重写原型中的值</li>\n<li>访问实例的某个属性时，会先搜索<code>对象实例</code>本身，如果对象实例中具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的<code>原型对象</code>，如果在原型对象中找到该属性，则返回该属性的值。</li>\n</ol>\n<h3 id=\"构造函数和原型的组合模式\"><a href=\"#构造函数和原型的组合模式\" class=\"headerlink\" title=\"构造函数和原型的组合模式\"></a>构造函数和原型的组合模式</h3><blockquote>\n<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"Jasper\"</span>, <span class=\"string\">\"Cindy\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Person.prototype = &#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>: Person,  // 手动将<span class=\"keyword\">constructor</span>指向Person，否则<span class=\"keyword\">constructor</span>将指向Object</div><div class=\"line\">  sayName: function() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\"></div><div class=\"line\">person1.friends.push(<span class=\"string\">\"Ann\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends);  <span class=\"comment\">// [\"Jasper\", \"Cindy\", \"Ann\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person2.friends);   <span class=\"comment\">// [\"Jasper\", \"Cindy\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends === person2.friends);   <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);   <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>是使用最广泛、认同度最高的一种创建自定义类型的方法。</p>\n<ol>\n<li>每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法引用，最大限度地节省了内存；</li>\n<li>支持向构造函数传递参数。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<p>缺乏更好的封装性。</p>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><blockquote>\n<p>动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 属性</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"comment\">// 方法</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.sayName !== <span class=\"string\">\"function\"</span>) &#123;</div><div class=\"line\">    Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<ol>\n<li>仅在需要的时候初始化原型，节省内存；</li>\n<li>对原型所做的修改，都能够立即在所有的实例中得到反映。</li>\n</ol>\n<p><strong>缺点：</strong> — —</p>\n<p><strong>注意：</strong></p>\n<p>使用动态原型模式时，不能使用<code>对象字面量</code>重写原型。因为，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>\n<h3 id=\"寄生构造模式\"><a href=\"#寄生构造模式\" class=\"headerlink\" title=\"寄生构造模式\"></a>寄生构造模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();  <span class=\"comment\">// \"Hysunny\"</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>在上面的几种模式都不适用的时候，可以使用该方法。比如：创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，可以使用这个模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SpecialArray</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建数组</span></div><div class=\"line\">  <span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 添加值</span></div><div class=\"line\">  array.push.apply(array, <span class=\"built_in\">arguments</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 添加方法</span></div><div class=\"line\">  array.toPipedString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.join(<span class=\"string\">\" | \"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 返回数组</span></div><div class=\"line\">  <span class=\"keyword\">return</span> array;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"keyword\">new</span> SpecialArray(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(colors.toPipedString());  <span class=\"comment\">// \"red | blue | green\"</span></div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong></p>\n<p>无法使用<code>instanceof</code>来识别对象所属类型</p>\n<h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><blockquote>\n<p>稳妥对象(durable objects):</p>\n<ol>\n<li>没有公共属性，而且其方法也不引用<code>this</code>的的对象；</li>\n<li>最适合在一些安全的环境中（这些环境中会禁止使用<code>this</code>和<code>new</code>），或者在防止数据被其他应用程序改动时使用。</li>\n</ol>\n<p>稳妥构造函数和寄生构造函数的区别：</p>\n<ol>\n<li>新创建对象的实例方法不引用<code>this</code>；</li>\n<li>不适用<code>new</code>操作符调用构造函数。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建要返回的对象</span></div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 可以在这里定义私有变量和函数</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 添加方法</span></div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(name)</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 返回对象</span></div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>非常适合在某些安全执行环境下使用。</p>\n<p><strong>缺点：</strong></p>\n<p>无法使用<code>instanceof</code>来识别对象所属类型</p>\n<hr>\n<p>参考：</p>\n<p>《JavaScript 高级程序设计》 第三版</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"external\">Object.create()</a></p>\n","categories":[],"tags":[]},{"title":"HTML块级元素、行内元素、可变元素以及空元素总结","url":"http://hysunny.me/2017/09/10/block-inline-element/","content":"<p>在HTML中元素可分为两大基本类型，<code>块级</code>元素(block element)和<code>行内</code>元素(inline element)。</p>\n<h2 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h2><ol>\n<li><p>元素前后带<code>有换行符</code>，此元素总是单独占据一行；</p>\n</li>\n<li><p>宽度缺省是它的容器的100%；</p>\n</li>\n<li><p><code>可以</code>设置width，height属性;(注意：块级元素即使设置了宽度，仍然是独占一行的)；</p>\n</li>\n<li><p>可以设置margin和padding；</p>\n</li>\n<li><p>块级元素<strong>只能</strong>出现在<code>body</code>元素内；</p>\n</li>\n<li><p>一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p>\n</li>\n</ol>\n<h2 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h2><ol>\n<li><p>元素前后<code>没有换行符</code>，和其他元素都在一行上；</p>\n</li>\n<li><p>设置width，height无效。（可以使用css将元素变为块级元素，设置宽高）；</p>\n</li>\n<li><p>宽度就是元素内文字或图片的宽度；</p>\n</li>\n<li><p>行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果（水平方向有效，竖直方向无效）；</p>\n</li>\n<li><p>行内元素<strong>只能</strong>包含文本或者其他行内元素。</p>\n</li>\n</ol>\n<h2 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h2><p>可变元素是根据上下文语境决定该元素为块级元素或者行内元素。</p>\n<h2 id=\"空元素\"><a href=\"#空元素\" class=\"headerlink\" title=\"空元素\"></a>空元素</h2><p>不存在子节点的元素。</p>\n<h2 id=\"附：\"><a href=\"#附：\" class=\"headerlink\" title=\"附：\"></a>附：</h2><h3 id=\"常见的块级元素\"><a href=\"#常见的块级元素\" class=\"headerlink\" title=\"常见的块级元素\"></a>常见的块级元素</h3><ul>\n<li>address - 地址  </li>\n<li>article - 文章内容 （HTML5）</li>\n<li>aside - 伴随内容（HTML5）</li>\n<li>audio - 音频播放（HTML5） </li>\n<li>blockquote - 块引用   </li>\n<li>canvas - 绘制图形 </li>\n<li>dd - 定义列表中定义条目描述</li>\n<li>div - 常用块级容易，也是css layout的主要标签   </li>\n<li>dl - 定义列表   </li>\n<li>fieldset - form控制组   </li>\n<li>form - 交互表单  </li>\n<li>figcaption - 图文信息组标题（HTML5）</li>\n<li>figure - 图文信息组（HTML5），参照 figcaption</li>\n<li>footer - 区段尾或页尾（HTML5）</li>\n<li>h1 - 大标题   </li>\n<li>h2 - 副标题   </li>\n<li>h3 - 3级标题   </li>\n<li>h4 - 4级标题   </li>\n<li>h5 - 5级标题   </li>\n<li>h6 - 6级标题   </li>\n<li>header - 区段头或页头</li>\n<li>hgroup - 标题组</li>\n<li>hr - 水平分隔线   </li>\n<li>noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）   </li>\n<li>menu - 菜单列表   </li>\n<li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容      </li>\n<li>ol - 有序列表</li>\n<li>output - 表单输出（HTML5）</li>\n<li>p - 段落   </li>\n<li>pre - 格式化文本 </li>\n<li>section - 一个页面片段  </li>\n<li>table - 表格   </li>\n<li>tfoot 表脚注</li>\n<li>ul - 非排序列表 </li>\n<li>video - 视频（HTML5）</li>\n</ul>\n<h3 id=\"常见的行内元素\"><a href=\"#常见的行内元素\" class=\"headerlink\" title=\"常见的行内元素\"></a>常见的行内元素</h3><ul>\n<li>a - 锚点   </li>\n<li>abbr - 缩写   </li>\n<li>acronym - 首字 (HTML5 中不支持 <acronym> 标签。请使用  <abbr>  标签代替。)  </abbr></acronym></li>\n<li>b - 粗体(不推荐) </li>\n<li>br - 换行 </li>\n<li>bdo - bidi override   </li>\n<li>big - 大字体   </li>\n<li>br - 换行   </li>\n<li>cite - 引用   </li>\n<li>code - 计算机代码(在引用源码的时候需要)   </li>\n<li>dfn - 定义字段   </li>\n<li>em - 强调   </li>\n<li>font - 字体设定(不推荐)   </li>\n<li>i - 斜体   </li>\n<li>img - 图片   </li>\n<li>input - 输入框   </li>\n<li>kbd - 定义键盘文本   </li>\n<li>label - 表格标签   </li>\n<li>q - 短引用   </li>\n<li>s - 中划线(不推荐)   </li>\n<li>samp - 定义范例计算机代码   </li>\n<li>select - 项目选择   </li>\n<li>small - 小字体文本   </li>\n<li>span - 常用内联容器，定义文本内区块   </li>\n<li>strike - 中划线   </li>\n<li>strong - 粗体强调   </li>\n<li>sub - 下标   </li>\n<li>sup - 上标   </li>\n<li>textarea - 多行文本输入框   </li>\n<li>tt - 电传文本   </li>\n<li>u - 下划线   </li>\n<li>var - 定义变量   </li>\n</ul>\n<h3 id=\"常见的可变元素\"><a href=\"#常见的可变元素\" class=\"headerlink\" title=\"常见的可变元素\"></a>常见的可变元素</h3><ul>\n<li>applet - java applet   </li>\n<li>button - 按钮   </li>\n<li>del - 删除文本   </li>\n<li>iframe - inline frame   </li>\n<li>ins - 插入的文本   </li>\n<li>map - 图片区块(map)   </li>\n<li>object - object对象   </li>\n<li>script - 客户端脚本  </li>\n</ul>\n<h3 id=\"常见的空元素\"><a href=\"#常见的空元素\" class=\"headerlink\" title=\"常见的空元素\"></a>常见的空元素</h3><ul>\n<li>area - 在图片上定义一个热点区域</li>\n<li>base    - 指定用于一个文档中包含的所有相对URL的基本URL。一份中只能有一个<base>元素。</li>\n<li>br - 换行</li>\n<li>col - 表格中的列</li>\n<li>colgroup when the span is present    // 表格列组</li>\n<li>command - 表示一个用户可以调用的命令</li>\n<li>embed - 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。</li>\n<li>hr - 分隔线</li>\n<li>img    - 图片</li>\n<li>input - 文本框等</li>\n<li>keygen    - 用于 HTML 表单与其他的所需信息一起构造一个证书请求（已废弃）</li>\n<li>link     - 指定了外部资源与当前文档的关系. 常用语引入css文件</li>\n<li>meta    - 表示那些不能由其它HTML元相关元素表示的任何元数据信息.</li>\n<li>param - 定义了 <object>的参数</object></li>\n<li>source    - 具体说明多媒体资源的类型</li>\n<li>track - 被当作媒体元素—<audio> 和 <video>的子元素来使用。</video></audio></li>\n<li>wbr - 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</li>\n</ul>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements\" target=\"_blank\" rel=\"external\">块级元素</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente\" target=\"_blank\" rel=\"external\">行内</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0\" target=\"_blank\" rel=\"external\">空元素</a></p>\n","categories":[],"tags":[]},{"title":"Vue.js 双向数据绑定原理分析","url":"http://hysunny.me/2017/07/02/two-way-data-binding-in-vuejs/","content":"<p>在使用Vue.js自定义组件时，很多时候，我们都期望数据是双向绑定的。</p>\n<hr>\n<h2 id=\"Vue-js实现双向数据绑定的两种方式\"><a href=\"#Vue-js实现双向数据绑定的两种方式\" class=\"headerlink\" title=\"Vue.js实现双向数据绑定的两种方式\"></a>Vue.js实现双向数据绑定的两种方式</h2><h3 id=\"1-v-model\"><a href=\"#1-v-model\" class=\"headerlink\" title=\"1. v-model\"></a>1. v-model</h3><p>调用组件时：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div><div class=\"line\">或</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:value</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组件内部，必须：</p>\n<ul>\n<li>接受一个 <code>value</code> 属性</li>\n<li>在有新的 value 时触发 <code>input</code> 事件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, newValue)</div></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;comp v-model=<span class=\"string\">\"something\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'comp'</span>, &#123;</div><div class=\"line\">\t...,</div><div class=\"line\">\tprops: [<span class=\"string\">'value'</span>],</div><div class=\"line\">\tcomputed: &#123;</div><div class=\"line\">\t\tcurrentValue: &#123;</div><div class=\"line\">\t\t\tget () &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\tset (val) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, val)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t...</div><div class=\"line\">&#125;）</div></pre></td></tr></table></figure>\n<h3 id=\"2-props-sync-修饰符\"><a href=\"#2-props-sync-修饰符\" class=\"headerlink\" title=\"2. props  .sync 修饰符\"></a>2. props  .sync 修饰符</h3><p>调用组件时：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo.sync</span>=<span class=\"string\">\"bar\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组件内部，</p>\n<ul>\n<li>接受一个 <code>foo</code> 属性</li>\n<li>需要更新 <code>foo</code> 时，它需要显式地触发一个更新事件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, newValue)</div></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;comp :foo.sync=<span class=\"string\">\"bar\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span></div><div class=\"line\"></div><div class=\"line\">Vue.component(<span class=\"string\">'comp'</span>, &#123;</div><div class=\"line\">\t...,</div><div class=\"line\">\tprops: [<span class=\"string\">'foo'</span>],</div><div class=\"line\">\tdata () &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\t\tcurrentValue: <span class=\"keyword\">this</span>.foo</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twatch: &#123;</div><div class=\"line\">\t\tcurrentValue (val, oldVal) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, val)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;）</div></pre></td></tr></table></figure>\n<h2 id=\"Vue实现双向数据绑定的原理分析\"><a href=\"#Vue实现双向数据绑定的原理分析\" class=\"headerlink\" title=\"Vue实现双向数据绑定的原理分析\"></a>Vue实现双向数据绑定的原理分析</h2><p><code>v-model</code> 用于双向绑定数据，其本质为语法糖，即</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = $event.target.value\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>props  <code>.sync</code> 修饰符 用于双向数据绑定，其本质也为语法糖，即</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>\n<p>以上，我们可以很容易的看出，实现一个自定义组件的双向数据绑定，其实就是父组件传递一个属性给子组件，在子组件中该属性的值改变时显式的去触发一个事件（v-model触发input事件，.sync触发update:props事件）。</p>\n<p>那在Vue.js内部究竟是如何实现双向数据绑定的呢？我们下面继续分析下。</p>\n<p>在Vue.js中，采用观察者-订阅者模式来进行双向数据绑定，通过<code>Object.defineProperty()</code>方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>既然是观察者-订阅者模式，那观察者-订阅者是如何实现的呢？我们来看源码</p>\n<p>观察者(Observer)关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span> (data) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.walk(data)</div><div class=\"line\">    &#125;</div><div class=\"line\">    walk (data) &#123;</div><div class=\"line\">        <span class=\"comment\">// 遍历 data 对象属性，调用 defineReactive 方法</span></div><div class=\"line\">        <span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.keys(data)</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++)&#123;</div><div class=\"line\">            defineReactive(data, keys[i], data[keys[i]])</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>订阅者（Watcher）关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(vm, expOrFn, cb) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cb = cb</div><div class=\"line\">    <span class=\"keyword\">this</span>.vm = vm</div><div class=\"line\">    <span class=\"keyword\">this</span>.expOrFn = expOrFn</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">  &#125;</div><div class=\"line\">  update()&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.run()</div><div class=\"line\">  &#125;</div><div class=\"line\">  run()&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span>  value = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">    <span class=\"keyword\">if</span>(value !==<span class=\"keyword\">this</span>.value)&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value = value</div><div class=\"line\">      <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  get()&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn]</div><div class=\"line\">    <span class=\"keyword\">return</span> value</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者和订阅者都有了，但是它们如何进行通信呢？</p>\n<p>首先，<br>观察者会遍历 data 对象的所有属性，每个属性通过调用 <code>defineReactive</code> 方法，转换为getter/setter</p>\n<p>defineReactive 关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">        enumerable: <span class=\"literal\">true</span>,</div><div class=\"line\">        configurable: <span class=\"literal\">true</span>,</div><div class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (Dep.target) &#123;</div><div class=\"line\">                dep.depend()  <span class=\"comment\">// 依赖收集</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">return</span> value</div><div class=\"line\">        &#125;,</div><div class=\"line\">        set: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span>(<span class=\"params\">newVal</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (value === newVal) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span></div><div class=\"line\">            &#125; </div><div class=\"line\">            value = newVal</div><div class=\"line\">            <span class=\"comment\">// 对新值进行观测，如果改变则通知订阅者</span></div><div class=\"line\">            dep.notify()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>defineReactive 方法将data的属性转换为访问器属性<br>get时进行依赖收集，<br>set时，如果数据有改变，则进行订阅通知</p>\n<p>通过上面的分析，我们知道了，观察者观测到数据更新时会通知订阅者，但是它是如何通知订阅者（Watcher）的呢？</p>\n<p>当然是通过订阅器了！</p>\n<p>订阅器(Dep)关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span> (id, subs) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.id = <span class=\"number\">0</span>++</div><div class=\"line\">        <span class=\"keyword\">this</span>.subs = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    addSub () &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subs.push(sub)</div><div class=\"line\">    &#125;</div><div class=\"line\">    removeSub () &#123;</div><div class=\"line\">        remove(<span class=\"keyword\">this</span>.subs, sub)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    depend () &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (Dep.target) &#123;</div><div class=\"line\">        Dep.target.addDep(<span class=\"keyword\">this</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    notify () &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class=\"line\">            subs[i].update()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过订阅器，订阅者接收到数据改变的通知</p>\n<p>由此，<code>Observer</code> 、 <code>Dep</code>、 <code>Watcher</code> 就形成了一个数据响应系统，也就是Vue.js实现双向数据绑定最核心的原理。</p>\n","categories":[],"tags":[]},{"title":"overflow:auto/scroll在ios7及以下失效的解决方法","url":"http://hysunny.me/2015/12/12/the-solution-of-overflow-auto-or-scroll-not-work-under-ios7/","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbodycontainer\"</span> &gt;</span></div><div class=\"line\">\t   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbody\"</span>&gt;</span></div><div class=\"line\">\t   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#mbodycontainer</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">\t<span class=\"attribute\">overflow</span>: auto;</div><div class=\"line\">\t<span class=\"attribute\">overflow-x</span>: hidden; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#mbody</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上代码。</p>\n<p>当mbody内容溢出时，在安卓设备及iphone6、iphone6 plus上，浏览器会自动显示滚动条以便查看剩余的内容，<code>overflow:auto;</code>正常起作用。</p>\n<p>而在iphone5S及以下ios设备上（后发现是ios7系统及以下设备上）<code>overflow:auto;</code>失效，滚动条无法滚动，相当于<code>overflow:hidden;</code></p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>给父元素设置 <code>-webkit-overflow-scrolling: touch;</code></p>\n<p>即代码变成如下这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbodycontainer\"</span> &gt;</span></div><div class=\"line\">\t   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbody\"</span>&gt;</span></div><div class=\"line\">\t   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#mbodycontainer</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">\t<span class=\"attribute\">overflow</span>: auto;</div><div class=\"line\">\t<span class=\"attribute\">overflow-x</span>: hidden; </div><div class=\"line\">\t<span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-id\">#mbody</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题解决！在iphone5S及以下ios设备上overflow:auto;表现正常，可以滚动！</p>\n<hr>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/8bb161beb05be8383975af4c8fc534a2.html\" target=\"_blank\" rel=\"external\">overflow:auto/scroll在ios7及以下失效的解决方法</a>，现迁移至此。</p>\n","categories":[],"tags":[]},{"title":"href=\"#\",javascript:;与javascript:void(0)的区别","url":"http://hysunny.me/2015/12/05/the-difference-between-empty-link-ways/","content":"<p>项目中，我们经常会使用<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>标签来代替<code>&lt;input type=&quot;button&quot; /&gt;</code></p>\n<p>这种情况下,很多时候href并不指定超链接目标的URL，而是使用<code>href=&quot;#&quot;</code>, <code>javascript:;</code>与<code>javascript:void(0)</code>。</p>\n<p>那它们有什么区别呢？</p>\n<p>现在就来总结一下~</p>\n<hr>\n<h2 id=\"1-href-”-”\"><a href=\"#1-href-”-”\" class=\"headerlink\" title=\"1. href=”#”\"></a>1. href=”#”</h2><p>一个#表示锚点，默认为#top，点击之后会自动跳转到页面的顶部。</p>\n<p>缺点：当快速点击此链接时会导致浏览器很慢甚至崩溃。</p>\n<p>使用###（href=”###”）效果和javascript:void(0)一样，不会跳转到页面顶部。</p>\n<h2 id=\"2-javascript\"><a href=\"#2-javascript\" class=\"headerlink\" title=\"2. javascript:;\"></a>2. javascript:;</h2><p>javascript:;”直接返回undefined。</p>\n<h2 id=\"3-javascript-void-0\"><a href=\"#3-javascript-void-0\" class=\"headerlink\" title=\"3. javascript:void(0)\"></a>3. javascript:void(0)</h2><p>void是一个操作符，这个操作符指定要计算一个表达式但是不返回值。如果在void中写入0（void(0)）, 则要去执行一次表达式“0”，然后返回undefined</p>\n<hr>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/e29158a787f793eedbb00929dd77b2be.html\" target=\"_blank\" rel=\"external\">href=”#”,javascript:;与javascript:void(0)的区别</a>，现迁移至此。</p>\n","categories":[],"tags":[]},{"title":"DIV + CSS 自适应布局","url":"http://hysunny.me/2015/09/24/div-css-adaptive-layout/","content":"<p>昨天面试时被问到一个布局的问题：<br>   <code>两栏布局，左边定宽200px，右边自适应。如何实现？</code><br>我的第一个反应就是：用flex伸缩盒呀，然后balabala…<br>说完之后，面试官说，还有没有别的方法？flex有些浏览器不支持<br>嗯…我愣了一下，平常遇到这种问题貌似都是这么写的…<br>别的方法？我又想了想。JS?对，JS肯定可以。<br>然后就说，可以用JS获取当前窗口宽度，然后减去200px就是右边的宽度了<br>面试官：嗯，这样的确可以，但是布局一般不要用JS，还有没有别的方法？CSS的<br>额，这下我完全愣住了好嘛，人也变得有些紧张。还要别的方法啊，什么方法呢？？？<br>哎呀妈呀，想不出来，肿么办…<br>然后面试官看了我半天，十分体谅的说，那我们进行下一个问题吧…</p>\n<p>回来后，经过百度，哇！原来方法如此之多~还如此简单~<br>下面就来总结一下~</p>\n<hr>\n<h2 id=\"一-两栏布局（左定宽，右自动）\"><a href=\"#一-两栏布局（左定宽，右自动）\" class=\"headerlink\" title=\"一. 两栏布局（左定宽，右自动）\"></a>一. 两栏布局（左定宽，右自动）</h2><h3 id=\"1-float-margin\"><a href=\"#1-float-margin\" class=\"headerlink\" title=\"1. float + margin\"></a>1. float + margin</h3><p>即固定宽度元素设置float属性为left，自适应元素设置margin属性，margin-left应 <code>&gt;=</code> 定宽元素宽度</p>\n<p>举例：</p>\n<p>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">        我是右栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注</strong>：使用的float属性，必要时清除一下浮动。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-margin-2.html\" target=\"_blank\">float + margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"2-position-margin\"><a href=\"#2-position-margin\" class=\"headerlink\" title=\"2. position + margin\"></a>2. position + margin</h3><p>即在父标签设置position属性为relative；子标签中定宽元素设置position属性为absolute；自适应元素设置margin属性，margin-left <code>&gt;=</code> 定宽元素宽度。</p>\n<p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">        我是右栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/position-margin-2.html\" target=\"_blank\">position + margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"3-float-负margin\"><a href=\"#3-float-负margin\" class=\"headerlink\" title=\"3. float + 负margin\"></a>3. float + 负margin</h3><p>即给自适应宽度元素定义一个父标签，并设置float属性为left；width为100%；自适应宽度元素设置margin，margin-left应 <code>&gt;=</code> 定宽元素宽度；<br>固定宽度元素设置margin-left属性为<code>负值</code>：-100%；<br>除此之外应注意HTML结构中应先写自适应元素，再写固定宽度元素。</p>\n<p>举例：</p>\n<p>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">        我是右栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span> <span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>注</strong>：使用的float属性，必要时清除一下浮动。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-negative-margin-2.html\" target=\"_blank\">float + 负margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"4-用table布局实现\"><a href=\"#4-用table布局实现\" class=\"headerlink\" title=\"4. 用table布局实现\"></a>4. 用table布局实现</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"green\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不过这个方法，一定要设置高度才可以~</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/table-2.html\" target=\"_blank\">table实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"5-触发BFC实现\"><a href=\"#5-触发BFC实现\" class=\"headerlink\" title=\"5. 触发BFC实现\"></a>5. 触发BFC实现</h3><p>关于BFC是什么、怎么触发BFC以及BFC可以用来做什么，大家可以看看这篇，<a href=\"http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html\" target=\"_blank\">前端精选文摘：BFC 神奇背后的原理</a></p>\n<p>实现方法，即为定宽元素设置float:left;自适应宽度元素设置可以触发BFC的属性。</p>\n<p>举例：<br>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/BFC-2.html\" target=\"_blank\">BFC实现左定宽，右自动的两栏布局</a></p>\n<p>前面有说到一般我都是用的flex伸缩盒，那也来说一下用flex怎么实现的吧</p>\n<h3 id=\"6-flex伸缩盒方法\"><a href=\"#6-flex伸缩盒方法\" class=\"headerlink\" title=\"6. flex伸缩盒方法\"></a>6. flex伸缩盒方法</h3><p>即父标签设置<code>display:flex</code>属性，自适应元素设置<code>flex-grow:1</code>;</p>\n<p>举例：</p>\n<p>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">        我是右栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;\t\t</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;\t</div><div class=\"line\">    <span class=\"attribute\">flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">-webkit-flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/flex-2.html\" target=\"_blank\">flex实现左定宽，右自动的两栏布局</a></p>\n<h2 id=\"二、三栏布局（两侧定宽，中间自适应）\"><a href=\"#二、三栏布局（两侧定宽，中间自适应）\" class=\"headerlink\" title=\"二、三栏布局（两侧定宽，中间自适应）\"></a>二、三栏布局（两侧定宽，中间自适应）</h2><p>掌握了上面的方法，我们会发现制作一个三栏布局也是非常容易的。<br>下面我们在上面栗子的基础上，看看实现一个两侧定宽，中间自适应的三栏布局如何实现</p>\n<h3 id=\"1-float-margin-1\"><a href=\"#1-float-margin-1\" class=\"headerlink\" title=\"1. float + margin\"></a>1. float + margin</h3><p>举例：</p>\n<p>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">    我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">float</span>: right;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-margin-3.html\" target=\"_blank\">float + margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"2-position-margin-1\"><a href=\"#2-position-margin-1\" class=\"headerlink\" title=\"2. position + margin\"></a>2. position + margin</h3><p>举例： </p>\n<p>HTML代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">    我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/position-margin-3.html\" target=\"_blank\">position + margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"3-float-负margin-1\"><a href=\"#3-float-负margin-1\" class=\"headerlink\" title=\"3. float + 负margin\"></a>3. float + 负margin</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">        我是中间栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">float</span>: left;</div><div class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-negative-margin-3.html\" target=\"_blank\">float + 负margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"4-table实现\"><a href=\"#4-table实现\" class=\"headerlink\" title=\"4. table实现\"></a>4. table实现</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"yellow\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"green\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/table-3.html\" target=\"_blank\">table实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"5-BFC方法\"><a href=\"#5-BFC方法\" class=\"headerlink\" title=\"5. BFC方法\"></a>5. BFC方法</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">    我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: left;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">float</span>: right;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：HTML中先写定宽元素，再写自适应宽度元素。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/BFC-3.html\" target=\"_blank\">BFC实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"6-flex伸缩盒方法-1\"><a href=\"#6-flex伸缩盒方法-1\" class=\"headerlink\" title=\"6. flex伸缩盒方法\"></a>6. flex伸缩盒方法</h3><p>即父标签设置display:flex属性，自适应元素设置flex-grow:1;<br>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">        我是中间栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">        我是右栏</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;\t\t</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;\t</div><div class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">-webkit-flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/flex-3.html\" target=\"_blank\">flex实现两侧定宽，中间自适应的三栏布局</a></p>\n<p>哦可~</p>\n","categories":[],"tags":[]},{"title":"CSS position 属性总结","url":"http://hysunny.me/2015/08/25/css-position/","content":"<p>CSS的position总是属性很容易让人弄混~</p>\n<p>为了仔细区别它们，所以今天总结一下CSS的position属性~</p>\n<p>下面是总结内容~</p>\n<p>有疏漏、错误之处敬请指出！~o(^▽^)o~</p>\n<hr>\n<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><p><strong>定义</strong>：position属性规定元素的定位类型。</p>\n<p><strong>说明</strong>：这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对定位或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。</p>\n<p><strong>默认值</strong>：static</p>\n<p><strong>继承性</strong>：no</p>\n<p><strong>形式语法</strong>：static | relative | absolute | sticky | fixed</p>\n<p><strong>JavaScript语法</strong>：object.style.position = “absolute”</p>\n<p><strong>浏览器支持</strong>：所有主流浏览器都支持position属性。但：任何版本的Internet Explorer(包括IE8)都不支持属性值“inhert”。</p>\n<h2 id=\"二、取值\"><a href=\"#二、取值\" class=\"headerlink\" title=\"二、取值\"></a>二、取值</h2><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static</td>\n<td>默认值，<code>没有定位</code>。元素出现在正常的流中。（忽略top、right、bottom、left和z-index属性）</td>\n</tr>\n<tr>\n<td>relative</td>\n<td>生成<code>相对定位</code>的元素，相对于其正常位置进行定位。</td>\n</tr>\n<tr>\n<td>absolute</td>\n<td>生成<code>绝对定位</code>的元素，相对于最近的非static父元素进行定位。绝对定位的元素可以设置外边距（margin），且不会与其他他边距合并。</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td>生成<code>绝对定位</code>的元素，相对于浏览器窗口(viewport)进行定位。</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td>盒位置根据正常流计算，然后相当于该元素在流中的flow root(BFC)和containing block（最近的块级元素）定位。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注：</strong> </p>\n<p>文档流：将窗体<code>自上而下</code>分成一行行，并在每行中按<code>从左至右</code>的顺序排放元素，即为文档流。</p>\n<p>元素脱离文档流的情况：浮动、绝对定位（absolute、fixed）。</p>\n<h2 id=\"三、-详解\"><a href=\"#三、-详解\" class=\"headerlink\" title=\"三、 详解\"></a>三、 详解</h2><p>我们以一个初始未定位示例为参照，其他属性值将和它进行比较。</p>\n<script async src=\"//jsfiddle.net/hysunny/3gwbeu3v/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-0.png\" alt=\"position-0\"></p>\n<h3 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1. static\"></a>1. static</h3><p>默认值。没有定位，元素出现在正常流中（忽略top，bottom，left，right或者z-index声明）</p>\n<p> <strong>解释</strong>：position设置为static或不设定position属性时，元素遵循正常的文档流，对象占用文档空间，该定位方式下，top、right、left、bottom、z-index属性是无效的。</p>\n<p> 示例：<br> <script async src=\"//jsfiddle.net/hysunny/zj2ogz8m/embed/html,css,result/\"></script></p>\n<p> 通过上例，可以看出position属性设置为static和不设置其实是一样的~</p>\n<p>所以，通常此属性值可以不设置，除非要<code>覆盖之前的定义。</code>下面举个栗子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">A</span>页面</div><div class=\"line\"><span class=\"selector-id\">#div-1</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>:absolute；</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">B</span>页面</div><div class=\"line\"><span class=\"selector-id\">#div-1</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>:absolute；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>页面B中`position:static;是为了覆盖页面A中position的定义。</p>\n<h3 id=\"2-relative\"><a href=\"#2-relative\" class=\"headerlink\" title=\"2. relative\"></a>2. relative</h3><p>生成相对定位的元素，相对于其正常位置进行定位。</p>\n<p><strong>解释：</strong> </p>\n<p>(1）position设置为relative时，top、right、left、bottom等属性有效，相对其<code>正常位置</code>移。</p>\n<p>(2）position设置为relative时，元素遵照正常的文档流，占据文档空间，但是占据的文档空间<code>不会</code>随top、right、left、bottom的偏移而发生变动，也就是说，它后面的元素是依据前一个元素正常位置（即未设置top、right、left、bottom属性之前）进行的定位。</p>\n<p>(3）position设置为relative时，如果没有进行任何的top、right、left、bottom设置，元素不会进行任何位置的改变。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/ae8s2cm4/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-1.png\" alt=\"position-1\"></p>\n<blockquote>\n<p>虚线是初始的位置空间。</p>\n</blockquote>\n<p>由图我们可以看出，相对定位是相对元素原本在文档流中的位置而进行的偏移。并且它后面的元素——second是依据虚线位置，也就是元素原本在文档流中的位置而进行的定位。</p>\n<p>好了，我们现在知道了top、right、left、bottom等属性不会改变relative定位的元素所占据的文档空间。，那么margin、padding会改变该元素占据的文档空间吗？我们来试一下：</p>\n<p>css代码中添加margin属性：</p>\n<script async src=\"//jsfiddle.net/hysunny/vxc9ctqs/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-2.png\" alt=\"position-2\"></p>\n<p>由图可以看出，我们将外边距设置为20px，second元素向下偏移40px，所以margin可以改变元素所占文档空间！同理，padding也可改变元素所占文档空间，这里不多做演示。</p>\n<h3 id=\"3-absolute\"><a href=\"#3-absolute\" class=\"headerlink\" title=\"3. absolute\"></a>3. absolute</h3><p>生成绝对定位的元素，相对于非static定位的第一个父元素进行定位。</p>\n<p><strong>解释</strong>：position设置为absolute，元素会脱离文档流，整个元素不再占据文档空间，就只能相对<code>非static</code>定位的<code>第一个</code>父元素进行定位<br>(1）absolute在无父级是非static定位时以<html>标签作为原点定位，而relative和static方式在最外层时是以<body>标签作为原点定位。<html>标签和<body>标签相差9px左右。</body></html></body></html></p>\n<p>(2）position设置为absolute或fixed时，必须指定left、right、top、bottom属性中的<code>至少一个</code>，否则left、right、top、bottom属性会使用它们的默认值auto，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative，会占用文档空间，不会脱离文档流。若多设，比如top和bottom一同存在的话，那么只有top生效；left和right一同存在的话，那么只有left生效。</p>\n<p>(3）绝对（absolute）定位对象和相对（relative）定位对象在可视区域之外会导致滚动条出现。而固定（fixed）定位对象放置在可视区域之外，滚动条不会出现。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/q325w0k6/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-3.png\" alt=\"position-3\"></p>\n<p>由此例我们可以发现absolute相对html定位，relative相对body定位。</p>\n<p>下面我们再来看看对absolute定位的元素的除static外第一个父元素设置margin/padding，看看会不会对文档空间有影响。</p>\n<p>在absolute定位中添加margin/padding属性：</p>\n<script async src=\"//jsfiddle.net/hysunny/59xv1qmx/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-4.png\" alt=\"position-4\"></p>\n<p>由上图我们可以看出，父元素的margin会让子元素的absolute定位跟着偏移，而padding却不会让子元素发生偏移。总结：absolute是根据父元素的<code>border</code>进行的定位。</p>\n<h3 id=\"4-fixed\"><a href=\"#4-fixed\" class=\"headerlink\" title=\"4.fixed\"></a>4.fixed</h3><p>生成绝对定位的元素，相对于浏览器窗口进行定位。</p>\n<p><strong>解释：</strong> fixed定位，又称固定定位，它和absolute定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据<code>窗口</code>为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/cubxLga9/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-5.png\" alt=\"position-5\"></p>\n<h3 id=\"5-sticky\"><a href=\"#5-sticky\" class=\"headerlink\" title=\"5. sticky\"></a>5. sticky</h3><p>粘性定位。CSS3新属性。它的表现类似<code>position:relative</code>和<code>position:fixed的</code>合体，在目标区域在屏幕中可见时，它的行为就像<code>position:relative</code>; 而当页面滚动超出目标区域时，它的表现就像<code>position:fixed</code>，它会固定在目标位置。</p>\n<p>目前<code>position: sticky;</code>的浏览器兼容性还比较差。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/rztoc45w/embed/html,css,result/\"></script>\n\n\n<h3 id=\"6-inherit\"><a href=\"#6-inherit\" class=\"headerlink\" title=\"6. inherit\"></a>6. inherit</h3><p>规定应该从父元素继承position属性的值。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/4uLp2ybv/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-6.png\" alt=\"position-6\"></p>\n<p>运行，我们发现second继承了first的position属性：fixed。同时超出可视区域之外时不会出现滚动条。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-相对定位的属性：\"><a href=\"#1-相对定位的属性：\" class=\"headerlink\" title=\"1. 相对定位的属性：\"></a>1. 相对定位的属性：</h3><p>(1）如果设定了top、right、left、bottom等属性，并且父元素<code>没有</code>设定position属性，元素以其父元素的左上角为原点进行定位。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/z2L92kqz/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-7.png\" alt=\"position-7\"></p>\n<p>(2）如果设定了top、right、left、bottom等属性，并且父元素设定position属性（无论是absolute还是relative），则以父元素的左上角为原点进行定位，位置由top、right、left、bottom决定，但是如果父元素存在padding属性，则以<code>content</code>的左上角为原点进行定位。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/2jgk2nzv/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-8.png\" alt=\"position-8\"></p>\n<p><img src=\"/images/position-9.png\" alt=\"position-9\"></p>\n<blockquote>\n<p>虚线框为正常原始位置。<br>点线框为content内区域</p>\n</blockquote>\n<p>我们可以看出，元素是以content为原点进行定位的~</p>\n<p>以上两点总结：相对定位总是以父元素左上角为原点进行定位的，如果父元素不存在或没有position属性或position属性值为static，则以浏览器左上角进行定位。</p>\n<h3 id=\"2-绝对定位的属性\"><a href=\"#2-绝对定位的属性\" class=\"headerlink\" title=\"2. 绝对定位的属性\"></a>2. 绝对定位的属性</h3><p>(1）如果设定了top、right、left、bottom等属性，并且父元素<code>没有</code>设定position属性，元素以浏览器左上角为原点进行定位，位置由top、right、left、bottom决定。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/dw2wfh6n/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-10.png\" alt=\"position-10\"></p>\n<p>由图可以看出，是相对于浏览器左上角进行定位的~</p>\n<p>(2）如果设定了top、right、left、bottom等属性，并且父元素设定position属性（无论是absolute还是relative），则以父元素的左上角为原点进行定位，位置由top、right、left、bottom决定。但是父元素存不存在padding属性，对定位原点没有影响。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/2yL8Lo3k/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-11.png\" alt=\"position-11\"></p>\n<blockquote>\n<p>虚线框为正常原始位置。<br>点线框为border内区域</p>\n</blockquote>\n<p>我们可以看出，父元素的padding并没有影响到子元素的定位。</p>\n<p>由以上两点可以总结出：<br>若想把一个定位为absolute的元素定位于其父元素内</p>\n<p>必须满足两个条件：</p>\n<p> 1）至少设定top、right、left、bottom中的一个</p>\n<p> 2）父元素设定position属性（值非static）</p>\n<p> 完。</p>\n<hr>\n<p>总结内容参考以下：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"external\">MDN: position</a><br><a href=\"http://www.jb51.net/web/77495.html\" target=\"_blank\" rel=\"external\">css中position属性(absolute|relative|static|fixed)概述及应用</a><br><a href=\"https://segmentfault.com/a/1190000000680773\" target=\"_blank\" rel=\"external\">详解css相对定位和绝对定位</a></p>\n<p>十分感谢你们的分享~n(<em>≧▽≦</em>)n~</p>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/8789b96cfceeeb31786f83fcd68d6ff0.html\" target=\"_blank\" rel=\"external\">CSS position属性总结</a>，现迁移至此。</p>\n","categories":[],"tags":[]},{"title":"CSS选择器、优先级以及!important知识总结","url":"http://hysunny.me/2015/08/12/css-selector/","content":"<h2 id=\"一、CSS选择器\"><a href=\"#一、CSS选择器\" class=\"headerlink\" title=\"一、CSS选择器\"></a>一、CSS选择器</h2><p>关于CSS选择器，首先请看这里：<a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"external\">CSS 选择器参考手册</a> </p>\n<p>通过以上，我们可以将CSS选择器分为以下几种：</p>\n<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><ol>\n<li>ID选择器（#footer），匹配所有id属性等于footer的元素。 </li>\n<li>类选择器（.info），匹配所有class属性中包含info的元素。</li>\n<li>通用选择器（*），匹配任何元素。</li>\n<li>标签选择器（E），匹配所有使用E标签的元素。</li>\n<li>同级元素选择器（E~F ），匹配任何在E元素之后的同级F元素(CSS3)。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#footer</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#999</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.info</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;&#125;</div><div class=\"line\">* &#123; <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;<span class=\"attribute\">padding</span>: <span class=\"number\">0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">div</span> &#123; <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#000000</span> solid; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> ~ <span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#000000</span>; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>说明：以下E表示元素，attr表示属性，val表示属性的值。</p>\n<ol>\n<li><p><code>E[attr]</code>选择器</p>\n<p> 匹配所有具有attr属性的E元素，不考虑它的值。（注：E在此处可以省略，比如“[checked]”.）</p>\n<p> 示例1：匹配所有含有title属性的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/qbLthqdo/embed/html,css,result/\"></script>\n\n<p> 示例2：匹配所有含有title属性的元素</p>\n <script async src=\"//jsfiddle.net/hysunny/xsero02u/1/embed/html,css,result/\"></script>\n\n<p> 看出区别了么~示例2就是比示例1省略了元素名div~    </p>\n</li>\n<li><p><code>E[attr=val]</code></p>\n<p> 匹配所有attr属性值为val的E元素。（注：同上，这里的E也可以省略。）</p>\n<p> 示例：匹配所有class值为test的p元素</p>\n <script async src=\"//jsfiddle.net/hysunny/2bpw297m/embed/html,css,result/\"></script>\n</li>\n<li><p><code>E[attr~=val]</code></p>\n<p> 匹配具有attr属性且属性值用空格分隔的字符列表。</p>\n<p> 示例：匹配具有class属性且其中一个属性值为name的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/fdpt62vw/embed/html,css,result/\"></script>\n\n<p> 运行代码，我们可以看到第一个div会应用上面的样式~</p>\n</li>\n<li><p><code>E[attr|=val]</code></p>\n<p> 匹配具有attr属性且属性值为用连接符（-）分隔的字符串，并以val开头的E元素。</p>\n<p> 示例: 匹配所有以test开头并以-连接的具有class属性的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/51L8p5jh/embed/html,css,result/\"></script>\n\n<p> 运行代码，可以看出第二个div会应用上面的样式~</p>\n</li>\n<li><p><code>E[attr^=&quot;val&quot;]</code>,属性attr的值以”val”开头的元素（CSS3）。</p>\n</li>\n<li><code>E[attr$=“val”]</code>,属性attr的值以”val”结尾的元素（CSS3）。</li>\n<li><code>E[attr*=&quot;val&quot;]</code>,属性attr的值包含”val”字符串的元素（CSS3）。    </li>\n</ol>\n<h3 id=\"组合选择器\"><a href=\"#组合选择器\" class=\"headerlink\" title=\"组合选择器\"></a>组合选择器</h3><ol>\n<li><p>多元素选择器（<code>E, F</code>），同时匹配多有E元素或F元素。</p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/5e4vunwt/embed/html,css,result/\"></script>\n</li>\n<li><p>后代选择器（<code>E F</code>），匹配所有属于E元素后代的F元素，E和F之间用空格分隔。    </p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/3u5edmcr/embed/html,css,result/\"></script>\n</li>\n<li><p>子元素选择器（<code>E &gt; F</code>）， 匹配所有E元素的子元素F。</p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/u2gtgbzu/embed/html,css,result/\"></script>\n</li>\n<li><p>相邻选择器（<code>E + F</code>），匹配所有紧随E元素之后的同级元素F。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/0xf31rbk/embed/html,css,result/\"></script>\n\n<p>可以发现，我们的样式只对紧跟div的第一个p元素起作用~</p>\n</li>\n</ol>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>说明：以下E表示元素</p>\n<h4 id=\"CSS2-1中的伪类：\"><a href=\"#CSS2-1中的伪类：\" class=\"headerlink\" title=\"CSS2.1中的伪类：\"></a>CSS2.1中的伪类：</h4><ol>\n<li><code>E:first-child</code>, 匹配父元素的第一个元素。</li>\n<li><code>E:link</code>, 匹配所有未被点击的链接.</li>\n<li><code>E:visited</code>, 匹配所有已被点击的链接。</li>\n<li><code>E:active</code>, 匹配鼠标已经将其按下，还没释放的E元素。</li>\n<li><code>E:hover</code>, 匹配鼠标悬停其上的E元素。</li>\n<li><code>E:focus</code>, 匹配获得当前焦点的E元素。</li>\n<li><code>E:lang(c)</code>, 匹配lang属性等于c的E元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-child</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-style</span>: italic;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=text]</span><span class=\"selector-pseudo\">:focus</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#ffe</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=text]</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">q</span><span class=\"selector-pseudo\">:lang(sv)</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">quotes</span>: <span class=\"string\">\"\\201D\"</span> <span class=\"string\">\"\\201D\"</span> <span class=\"string\">\"\\2019\"</span> <span class=\"string\">\"\\2019\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS2-1中的伪元素\"><a href=\"#CSS2-1中的伪元素\" class=\"headerlink\" title=\"CSS2.1中的伪元素\"></a>CSS2.1中的伪元素</h4><ol>\n<li><code>E:first-line</code>, 匹配E元素的第一行。</li>\n<li><code>E:first-letter</code>, 匹配E元素的第一个字母。</li>\n<li><code>E:before</code>, 在E元素之前插入生成的内容。</li>\n<li><code>E:after</code>, 在E元素之后插入生成的内容。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-line</span> &#123; </div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold; </div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#600</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.preamble</span><span class=\"selector-pseudo\">:first-letter</span> &#123; </div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>; </div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.cbb</span><span class=\"selector-pseudo\">:before</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</div><div class=\"line\">  <span class=\"attribute\">display</span>: block;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">17px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">18px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(top.png) no-repeat <span class=\"number\">0</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> -<span class=\"number\">18px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:link</span><span class=\"selector-pseudo\">:after</span> &#123;</div><div class=\"line\"> <span class=\"attribute\">content</span>: <span class=\"string\">\" (\"</span> <span class=\"built_in\">attr</span>(href) <span class=\"string\">\") \"</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中与用户界面有关的伪类\"><a href=\"#CSS3中与用户界面有关的伪类\" class=\"headerlink\" title=\"CSS3中与用户界面有关的伪类\"></a>CSS3中与用户界面有关的伪类</h4><ol>\n<li><code>E:enabled</code>, 匹配表单中激活的元素。</li>\n<li><code>E:disabled</code>, 匹配表单中禁用的元素。</li>\n<li><code>E:checked</code>, 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素。</li>\n<li><code>E::selection</code>, 匹配用户当前选中的元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=\"text\"]</span><span class=\"selector-pseudo\">:disabled</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ddd</span>; &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中的结构性伪类\"><a href=\"#CSS3中的结构性伪类\" class=\"headerlink\" title=\"CSS3中的结构性伪类\"></a>CSS3中的结构性伪类</h4><ol>\n<li><code>E:root</code>, 匹配文档的根元素，对于HTML文档，就是HTML元素。</li>\n<li><code>E:nth-child(n)</code>, 匹配其父元素的第n个子元素，第一个编号为1。</li>\n<li><code>E:nth-last-child(n)</code>, 匹配其父元素的倒数第n个子元素，第一个编号为1。</li>\n<li><code>E:nth-of-type(n)</code>, 与:nth-child()作用类似，但是仅匹配使用同种标签的元素。</li>\n<li><code>E:nth-last-of-type(n)</code>, 与:nth-last-child()作用类似，但是仅匹配使用同种标签的元素。</li>\n<li><code>E:last-child</code>, 匹配父元素的最后一个子元素，等同于:nth-last-child(1)。</li>\n<li><code>E:first-of-type</code>, 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1).</li>\n<li><code>E:last-of-type</code>, 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)。</li>\n<li><code>E:only-child</code>, 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或:nth-child(1):nth-last-child(1).</li>\n<li><code>E:only-of-type</code>, 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或:nth:first-of-type(1):nth-last-of-type(1).</li>\n<li><code>E:empty</code>, 匹配一个不包含任何子元素的元素，注意：文本节点也被看作子元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(odd)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;&#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(even)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3n+0)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3n)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-child(2n+11)</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-last-child(2)</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:last-child</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:only-child</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:empty</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3的反选伪类\"><a href=\"#CSS3的反选伪类\" class=\"headerlink\" title=\"CSS3的反选伪类\"></a>CSS3的反选伪类</h4><p><code>E:not(s)</code>,匹配不符合当前选择器的任何元素</p>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">:not(p)</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中的-target伪类\"><a href=\"#CSS3中的-target伪类\" class=\"headerlink\" title=\"CSS3中的:target伪类\"></a>CSS3中的:target伪类</h4><p><code>E:target</code>,匹配文档中特定”id”点击后的效果</p>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">h2</span><span class=\"selector-pseudo\">:target</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: white;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f60</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"后代元素选择器和子元素选择器的区别\"><a href=\"#后代元素选择器和子元素选择器的区别\" class=\"headerlink\" title=\"后代元素选择器和子元素选择器的区别\"></a>后代元素选择器和子元素选择器的区别</h3><p>这里我们简单讨论下后代元素选择器和子元素选择器的区别</p>\n<ol>\n<li><p>写法不一样：</p>\n<p> 后代元素选择器标识：空格</p>\n<p>   如：<code>ul li{ width:150px; }</code>,ul和li之间用空格隔开</p>\n<p> 子元素选择器标识：&gt;</p>\n<p>   如：<code>ul&gt;li{ width:150px; }</code>,ul和li之间用&gt;隔开</p>\n</li>\n<li><p>功能不一样<br> 接着上例来说:</p>\n<p> 后代选择器是选择ul包围的,所以元素中的所有li元素，包括子元素、孙元素、曾孙元素等等等。</p>\n<p> 子选择器仅仅选择ul包围的 子元素中的 li元素，不包括孙元素、曾孙元素等等等。</p>\n</li>\n<li><p>兼容性不一样：</p>\n<p> 后代选择器是所有浏览器都兼容的，都可使用。</p>\n<p> 子选择器在IE6、IE7、IE8中则是不被支持的选择器，各自bug！</p>\n</li>\n</ol>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/ouhvho5v/embed/html,css,result/\"></script>    \n\n<h2 id=\"二、CSS优先级\"><a href=\"#二、CSS优先级\" class=\"headerlink\" title=\"二、CSS优先级\"></a>二、CSS优先级</h2><h3 id=\"什么是CSS优先级？\"><a href=\"#什么是CSS优先级？\" class=\"headerlink\" title=\"什么是CSS优先级？\"></a>什么是CSS优先级？</h3><p>CSS优先级是指CSS样式在浏览器中被解析的<code>先后顺序</code>。</p>\n<h3 id=\"样式的优先级\"><a href=\"#样式的优先级\" class=\"headerlink\" title=\"样式的优先级\"></a>样式的优先级</h3><p>多重样式（Mutiple Styles）：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是多重样式的使用情况。</p>\n<p>一般情况下，（<code>外部</code>样式）External style sheet &lt;（<code>内部</code>样式）Internal style sheet &lt;（<code>内联</code>样式）Inline style</p>\n<p><strong>例外</strong>：如果外部样式放在内部样式的后面，则外部样式将会覆盖内部样式。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">utf-8</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"css\">      <span class=\"comment\">/* 内部样式 */</span></span></div><div class=\"line\"><span class=\"css\">      <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:green;&#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">&lt;!-- 外部样式 style.css --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>/&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>测试！<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"选择器的优先级\"><a href=\"#选择器的优先级\" class=\"headerlink\" title=\"选择器的优先级\"></a>选择器的优先级</h3><p>给不同的选择器分配不同的权值</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>内联样式（style=””）</th>\n<th>id选择器</th>\n<th>类选择器/属性选择器/伪类选择器</th>\n<th>标签选择器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>权重</td>\n<td>1000</td>\n<td>100</td>\n<td>10</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>解释：</p>\n<ol>\n<li>内联样式表的权值最高1000;</li>\n<li>id选择器权值100;</li>\n<li>类选择器/属性选择器/伪类选择器权值10;</li>\n<li>HTML标签选择器权值为1.</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"css\">        <span class=\"selector-id\">#redP</span> <span class=\"selector-tag\">p</span> &#123;</span></div><div class=\"line\"><span class=\"css\">             <span class=\"comment\">/* 权值 = 100+1=101 */</span></span></div><div class=\"line\"><span class=\"css\">             <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#F00</span>;  <span class=\"comment\">/* 红色 */</span></span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\"> </span></div><div class=\"line\"><span class=\"css\">        <span class=\"selector-id\">#redP</span> <span class=\"selector-class\">.red</span> <span class=\"selector-tag\">em</span> &#123;</span></div><div class=\"line\"><span class=\"css\">             <span class=\"comment\">/* 权值 = 100+10+1=111 */</span></span></div><div class=\"line\"><span class=\"css\">             <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#00F</span>; <span class=\"comment\">/* 蓝色 */</span></span></div><div class=\"line\"><span class=\"undefined\"> </span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\"> </span></div><div class=\"line\"><span class=\"css\">        <span class=\"selector-id\">#redP</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">span</span> <span class=\"selector-tag\">em</span> &#123;</span></div><div class=\"line\"><span class=\"css\">             <span class=\"comment\">/* 权值 = 100+1+1+1=103 */</span></span></div><div class=\"line\"><span class=\"css\">             <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#FF0</span>;<span class=\"comment\">/*黄色*/</span></span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"redP\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red\"</span>&gt;</span>red</div><div class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>em red<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>red<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：标签内的数据显示为蓝色。</p>\n<h3 id=\"CSS优先级法则\"><a href=\"#CSS优先级法则\" class=\"headerlink\" title=\"CSS优先级法则\"></a>CSS优先级法则</h3><p>比较样式的优先级是，只需统计不同选择器的个数，然后与对应的权值相乘即可。根据结果便可得出优先级。</p>\n<ol>\n<li>结果较大的优先级较高；</li>\n<li>结果相同，则<code>后定义</code>的优先级较高</li>\n<li>创作者的优先级高于浏览者，网页编写者设置的CSS样式的优先权高于浏览器所设置的样式。</li>\n<li>继承的CSS样式优先级低于后来指定的CSS样式</li>\n<li>若样式值中含有<code>!important</code>，则该值优先级最高</li>\n</ol>\n<p>看到这里，有些同学是不是对!important有点迷惑呀~为什么有了它，就优先级最高呐~下面我们再来详细讲一讲!important~</p>\n<h2 id=\"三、-important知识点\"><a href=\"#三、-important知识点\" class=\"headerlink\" title=\"三、!important知识点\"></a>三、!important知识点</h2><h3 id=\"important简介\"><a href=\"#important简介\" class=\"headerlink\" title=\"!important简介\"></a>!important简介</h3><p><code>!important</code> 是CSS1就定义的语法，作用是提高指定样式的应用优先权。</p>\n<p>语法格式：<code>{cssRule !important}</code>，即写在定义的最后面，例如：<code>box { color: red !important}</code></p>\n<p>声明了<code>!important</code>的样式，具有最高的优先级，相当于写在最下面（最后定义）</p>\n<h3 id=\"IE-6-0下的-important\"><a href=\"#IE-6-0下的-important\" class=\"headerlink\" title=\"IE 6.0下的!important\"></a>IE 6.0下的!important</h3><p>IE 6.0<code>不完全</code>支持!important</p>\n<p>IE支持重定义中的!important，例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#e00</span> <span class=\"meta\">!important</span>; &#125;</div><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; &#125;</div></pre></td></tr></table></figure>\n<p>你将会发现定义了样式<code>class=&quot;yuanxin&quot;</code>时，在IE下，字体显示为红色（#e00）。<br>但不支持同一定义中的<code>!important</code>。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#e00</span> <span class=\"meta\">!important</span>; <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>; &#125;</div></pre></td></tr></table></figure>\n<p>此时在IE6下不支持，你将会发现定义了样式<code>class=&quot;yuanxin&quot;</code>时，字体显示为黑色（#000）。</p>\n<p><strong>解释</strong>：</p>\n<p>important的样式属性和覆盖它的样式属性单独使用时(不在一个{}里)，IE 6.0认为!important优先级较高，否则当含!important的样式属性被同一个{}里的样式覆盖时，IE 6.0认为!important较低!<br>再举一个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*样式1*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span>&#123;<span class=\"attribute\">width</span>:<span class=\"number\">100</span> <span class=\"meta\">!important</span>;&#125; <span class=\"comment\">/*有效*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span>&#123;<span class=\"attribute\">width</span>:<span class=\"number\">50px</span>;&#125; <span class=\"comment\">/*无效*/</span></div><div class=\"line\"><span class=\"comment\">/*样式2*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span>&#123;<span class=\"attribute\">width</span>:<span class=\"number\">100px</span> <span class=\"meta\">!important</span>; <span class=\"attribute\">width</span>:<span class=\"number\">50px</span>;&#125; <span class=\"comment\">/*width:100px无效，width:50px 有效*/</span></div></pre></td></tr></table></figure>\n<p>因为IE 6.0一直都不完全支持这个语法，而其他的浏览器都支持。因此我们就可以利用这一点来分别利用!important，我们可以针对IE和非IE浏览器设置不同的样式，只要在非IE浏览器样式的后面加上!important。</p>\n<p>完。</p>\n<hr>\n<p>总结内容参考以下：</p>\n<p><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"external\">w3school_CSS 选择器参考手册</a><br><a href=\"http://www.ruanyifeng.com/blog/2009/03/css_selectors.html\" target=\"_blank\" rel=\"external\">阮一峰_CSS选择器笔记</a><br><a href=\"http://www.jb51.net/css/67029.html\" target=\"_blank\" rel=\"external\">css选择器优先级深入理解</a><br><a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\" target=\"_blank\" rel=\"external\">CSS 的优先级机制[总结]</a></p>\n<p>十分感谢你们的分享~n(<em>≧▽≦</em>)n~</p>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/428bcf01ddf5adf75e5c3a3bdaccc44d.html\" target=\"_blank\" rel=\"external\">CSS选择器、优先级以及!important知识总结</a>，现迁移至此。</p>\n","categories":[],"tags":[]},{"title":"link","url":"http://hysunny.me/link/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hysunny.me/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hysunny.me/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hysunny.me/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hysunny.me/tag/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://hysunny.me/about/index.html","content":"","categories":[],"tags":[]},{"title":"demo","url":"http://hysunny.me/demo/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/BFC-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            overflow: hidden;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/flex-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            display: flex;\n            display: -webkit-flex;\n        }\n        .wrap_left{\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            width: 200px;\n            background-color: green;\n        }\n        .wrap_content{\n            flex-grow:1;\n            -webkit-flex-grow:1;\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_content\">\n        我是中间栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/BFC-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            float: right;\n            width: 200px;\n            background-color: green;\n        }\n        .wrap_content{\n            overflow: hidden;\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n    <div class=\"wrap_content\">\n        我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/flex-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            display: flex;\n            display: -webkit-flex;\n        }\n        .wrap_left{\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            flex-grow:1;\n            -webkit-flex-grow:1;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            margin: 10px;\n        }\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap_left{\n            width: 200px;\n            float: left;\n            background-color: red;\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            float: right;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n<div class=\"wrap_content\">\n    我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-negative-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            float: left;;\n            width: 100%;\n        }\n        .wrap_left{\n            width: 200px;\n            float: left;\n            margin-left: -100%;\n            background-color: red;\n\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            float: left;\n            margin-left: -200px;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_content\">\n        我是中间栏\n    </div>\n</div>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/position-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            margin: 10px;\n            position: relative;\n        }\n        .wrap_left{\n            position: absolute;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-negative-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            float: left;\n            width: 100%;\n        }\n        .wrap .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n        .wrap_left{\n            float: left;\n            width: 200px;\n            margin-left: -100%;\n            background-color: red;\n        }\n\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/position-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap_left{\n            width: 200px;\n            position: absolute;\n            background-color: red;\n            left: 0;\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            position: absolute;\n            right: 0;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n<div class=\"wrap_content\">\n    我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/table-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,table{\n            margin: 0;\n            padding: 0;\n        }\n\n    </style>\n</head>\n<body>\n<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\" border=\"1\" height=\"300\">\n    <tr>\n        <td width=\"200\" bgcolor=\"red\"></td>\n        <td bgcolor=\"green\"></td>\n    </tr>\n</table>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/table-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,table{\n            margin: 0;\n            padding: 0;\n        }\n\n    </style>\n</head>\n<body>\n<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\" border=\"1\" height=\"300\">\n    <tr>\n        <td width=\"200\" bgcolor=\"red\"></td>\n        <td bgcolor=\"yellow\"></td>\n        <td width=\"200\" bgcolor=\"green\"></td>\n    </tr>\n</table>\n</body>\n</html>","categories":[],"tags":[]}]