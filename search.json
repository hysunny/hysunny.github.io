[{"title":"Vue.js 2.0 最佳实践 & 踩坑记录","url":"http://hysunny.me/2018/08/25/Vue/vue-best-practise/","content":"<blockquote>\n<p>最近在团队的小组里做了一次关于<code>Vue.js 2.0</code>的一些 <strong>最佳实践</strong> 和常见的 <strong>采坑记录</strong> 的小分享，这里总结了一下分享给大家~ 如果哪里有问题欢迎大家<code>diss</code> ~^_^~</p>\n</blockquote>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><p>关于代码规范，我的理解是不一定非要用什么特别严苛的标准或是特别权威的规范，只要项目团队遵循一套统一的约定就可以。当然，参考他人的经验沉淀从而制定自己的代码规范还是很有必要的。</p>\n<h3 id=\"1-对齐\"><a href=\"#1-对齐\" class=\"headerlink\" title=\"1. 对齐\"></a>1. 对齐</h3><ul>\n<li>静态属性 (static binding) 在前， 动态属性 (dynamic binding) 在后</li>\n<li>属性绑定 (:属性)在前， 事件绑定 (@事件) 在后</li>\n<li>如果有使用指令，则指令语句写在最前面</li>\n</ul>\n<p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bad --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:name</span>=<span class=\"string\">\"n.name\"</span></span></div><div class=\"line\"><span class=\"tag\">    @<span class=\"attr\">click</span>=<span class=\"string\">\"check\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in list\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:key</span>=<span class=\"string\">\"n.id\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"list-item\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:tag</span>=<span class=\"string\">\"n.tag\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">\"product\"</span></span></div><div class=\"line\"><span class=\"tag\">&gt;</span>&#123;&#123; n.name &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- good --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">v-for</span>=<span class=\"string\">\"n in list\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"list-item\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">type</span>=<span class=\"string\">\"product\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:key</span>=<span class=\"string\">\"n.id\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:name</span>=<span class=\"string\">\"n.name\"</span></span></div><div class=\"line\"><span class=\"tag\">    <span class=\"attr\">:tag</span>=<span class=\"string\">\"n.tag\"</span></span></div><div class=\"line\"><span class=\"tag\">    @<span class=\"attr\">click</span>=<span class=\"string\">\"check\"</span></span></div><div class=\"line\"><span class=\"tag\">&gt;</span>&#123;&#123; n.name &#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-简化的表达式（不要在模版里使用复杂的表达式）\"><a href=\"#2-简化的表达式（不要在模版里使用复杂的表达式）\" class=\"headerlink\" title=\"2. 简化的表达式（不要在模版里使用复杂的表达式）\"></a>2. 简化的表达式（不要在模版里使用复杂的表达式）</h3><ul>\n<li>对于列表里的数据表达式，可以用 <code>filter</code> 来处理</li>\n<li>其他情况下，可以使用 <code>computed property</code></li>\n</ul>\n<p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bad --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">          &#123;&#123; `$&#123;(new Date()).getUTCFullYear()&#125;-$&#123;('0' + ((new Date()).getUTCMonth()+1)).slice(-2)&#125;` &#125;&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- good --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\">        &#123;&#123; `$&#123;year&#125;-$&#123;month&#125;` &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></div><div class=\"line\"><span class=\"undefined\">        computed: &#123;</span></div><div class=\"line\"><span class=\"undefined\">            month() &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.twoDigits((<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getUTCMonth() + <span class=\"number\">1</span>);</span></div><div class=\"line\"><span class=\"undefined\">            &#125;,</span></div><div class=\"line\"><span class=\"undefined\">            year() &#123;</span></div><div class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getUTCFullYear();</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;,</span></div><div class=\"line\"><span class=\"undefined\">        methods: &#123;</span></div><div class=\"line\"><span class=\"undefined\">            twoDigits(num) &#123;</span></div><div class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">return</span> (<span class=\"string\">'0'</span> + num).slice(<span class=\"number\">-2</span>);</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;,</span></div><div class=\"line\"><span class=\"undefined\">    &#125;;</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-组件编码规范\"><a href=\"#3-组件编码规范\" class=\"headerlink\" title=\"3. 组件编码规范\"></a>3. 组件编码规范</h3><ul>\n<li>导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。</li>\n<li>能避免操作 <code>dom</code> 就尽量避免，实在要用的话最好使用 <code>ref</code> 来代替 <code>querySelector</code> 等选择器方法</li>\n<li>一个 <code>.vue</code> 的文件行数最好控制在 <strong>200</strong> 行左右</li>\n<li>善用 <code>v-if</code> 和 <code>v-show</code>。比如，涉及到权限的必须用 <code>v-if</code> 而非 <code>v-show</code>。例如，用户必须登录后才能查看的，请用 <code>v-if</code></li>\n<li>请尽量保证数据流的可追踪性。尽量不要使用 <code>$parent</code>，而是通过 <code>props</code> 属性接收父组件的传入</li>\n</ul>\n<p>参考：<a href=\"https://pablohpsilva.github.io/vuejs-component-style-guide/#/chinese\" target=\"_blank\" rel=\"external\">Vue组件设计规范</a></p>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-属性绑定\"><a href=\"#1-属性绑定\" class=\"headerlink\" title=\"1. 属性绑定\"></a>1. 属性绑定</h3><h4 id=\"1-1-绑定字符串不需要加冒号\"><a href=\"#1-1-绑定字符串不需要加冒号\" class=\"headerlink\" title=\"1.1 绑定字符串不需要加冒号\"></a>1.1 绑定字符串不需要加冒号</h4><p>e.g: </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bad --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">:message</span>=<span class=\"string\">\"hello\"</span> /&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- good --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">message</span>=<span class=\"string\">\"hello\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"1-2-布尔属性省略值时默认为-true\"><a href=\"#1-2-布尔属性省略值时默认为-true\" class=\"headerlink\" title=\"1.2 布尔属性省略值时默认为 true\"></a>1.2 布尔属性省略值时默认为 true</h4><p>e.g :</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-modal</span> <span class=\"attr\">visible</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!--等价于--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-modal</span> <span class=\"attr\">:visible</span>=<span class=\"string\">\"true\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"1-3-HTML原生属性可以不用-props-绑定-或者-组件特有的特性也不用-props-绑定\"><a href=\"#1-3-HTML原生属性可以不用-props-绑定-或者-组件特有的特性也不用-props-绑定\" class=\"headerlink\" title=\"1.3 HTML原生属性可以不用 props 绑定 或者 组件特有的特性也不用 props 绑定\"></a>1.3 HTML原生属性可以不用 <code>props</code> 绑定 或者 组件特有的特性也不用 <code>props</code> 绑定</h4><p>e.g: </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">component</span> <span class=\"attr\">class</span>=<span class=\"string\">\"className\"</span> /&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bootstrap-date-input</span> <span class=\"attr\">data-date-picker</span>=<span class=\"string\">\"activated\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-事件绑定\"><a href=\"#2-事件绑定\" class=\"headerlink\" title=\"2. 事件绑定\"></a>2. 事件绑定</h3><h4 id=\"2-绑定无参函数不需要加\"><a href=\"#2-绑定无参函数不需要加\" class=\"headerlink\" title=\"2. 绑定无参函数不需要加 ()\"></a>2. 绑定无参函数不需要加 <strong>()</strong></h4><p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- bad，括号多余 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"onClick()\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- good，隐式传递了 event 对象 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"onClick\"</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-2-只有一行代码的事件函数，可以直接写在标签上\"><a href=\"#2-2-只有一行代码的事件函数，可以直接写在标签上\" class=\"headerlink\" title=\"2.2 只有一行代码的事件函数，可以直接写在标签上\"></a>2.2 只有一行代码的事件函数，可以直接写在标签上</h4><p>e.g:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"visible = !visible\"</span>&gt;</span>显示/隐藏<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<h4 id=\"2-3-在监听原生DOM事件时，方法以-事件-为唯一的参数。如果使用内联语句，语句可以访问一个-event-属性：\"><a href=\"#2-3-在监听原生DOM事件时，方法以-事件-为唯一的参数。如果使用内联语句，语句可以访问一个-event-属性：\" class=\"headerlink\" title=\"2.3 在监听原生DOM事件时，方法以 事件 为唯一的参数。如果使用内联语句，语句可以访问一个 $event 属性：\"></a>2.3 在监听原生DOM事件时，方法以 <strong>事件</strong> 为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> 属性：</h4><p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"handle($event, 1)\"</span>&gt;</span>click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果在父组件中想要给子组件抛出的事件添加自定义参数，可利用此属性：</p>\n<p>e.g: <a href=\"https://jsfiddle.net/hysunny/eywraw8t/228187/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/hysunny/eywraw8t/228187/</a></p>\n<h3 id=\"3-修饰符\"><a href=\"#3-修饰符\" class=\"headerlink\" title=\"3. 修饰符\"></a>3. 修饰符</h3><p>Vue 内置了许多常用的 <a href=\"https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"external\">修饰符</a> ，可以让你少写几行代码，提高开发效率。</p>\n<p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 阻止单击事件继续传播 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">\"doThis\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- 提交事件不再重载页面 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>=<span class=\"string\">\"onSubmit\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- 修饰符可以串联 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">\"doThat\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- 只有修饰符 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">v-on:submit.prevent</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.capture</span>=<span class=\"string\">\"doThis\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-on:click.self</span>=<span class=\"string\">\"doThat\"</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-按需加载组件\"><a href=\"#4-按需加载组件\" class=\"headerlink\" title=\"4. 按需加载组件\"></a>4. 按需加载组件</h3><p>一般配合 <code>Vue-Router</code> 使用，适用于大型应用，将应用分割成小的代码块，只在需要的时候才从服务器加载。</p>\n<p>实现方式: </p>\n<ul>\n<li>异步组件实现</li>\n<li>es6 import</li>\n</ul>\n<p>好处: </p>\n<ul>\n<li>按需加载，节省首次加载实践，提高速度，也算是一个性能优化；</li>\n<li>组件只会加载一次，加载完成后会缓存下来，使用一个组件多次使用的场景。</li>\n</ul>\n<p>e.g: </p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 异步组件实现</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">    routes: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            path: <span class=\"string\">'/test'</span>,</div><div class=\"line\">            name: <span class=\"string\">'test'</span>,</div><div class=\"line\">            component: <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> <span class=\"built_in\">require</span>([<span class=\"string\">'../components/Test'</span>], resolve)</div><div class=\"line\">        &#125;,</div><div class=\"line\">    ]</div><div class=\"line\">&#125;)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// ES6 import</span></div><div class=\"line\"><span class=\"keyword\">const</span> Test1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'../components/Test1'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> Test2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'../components/Test2'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Router(&#123;</div><div class=\"line\">    routes: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            path: <span class=\"string\">'/test1'</span>,</div><div class=\"line\">            name: <span class=\"string\">'test1'</span>,</div><div class=\"line\">            component: Test1</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">            path: <span class=\"string\">'/test2'</span>,</div><div class=\"line\">            name: <span class=\"string\">'test2'</span>,</div><div class=\"line\">            component: Test2</div><div class=\"line\">        &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"5-过滤器\"><a href=\"#5-过滤器\" class=\"headerlink\" title=\"5. 过滤器\"></a>5. 过滤器</h3><p>用于一些常见的文本格式化，如展示发布时间。</p>\n<p>e.g:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 在双花括号中 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;&#123; message | capitalize &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- 在 `v-bind` 中 --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">:message</span>=<span class=\"string\">\"message | capitalize\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></div><div class=\"line\"><span class=\"undefined\">        data() &#123;</span></div><div class=\"line\"><span class=\"actionscript\">            <span class=\"keyword\">return</span> &#123;</span></div><div class=\"line\"><span class=\"undefined\">                message:1</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;,</span></div><div class=\"line\"><span class=\"undefined\">        filters: &#123;</span></div><div class=\"line\"><span class=\"actionscript\">            capitalize: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(value)</span> </span>&#123;</span></div><div class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">if</span> (!value) <span class=\"keyword\">return</span> <span class=\"string\">''</span></span></div><div class=\"line\"><span class=\"undefined\">                value = value.toString()</span></div><div class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">return</span> value.charAt(<span class=\"number\">0</span>).toUpperCase() + value.slice(<span class=\"number\">1</span>)</span></div><div class=\"line\"><span class=\"undefined\">            &#125;</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"6-多个元素块可以用template包裹\"><a href=\"#6-多个元素块可以用template包裹\" class=\"headerlink\" title=\"6. 多个元素块可以用template包裹\"></a>6. 多个元素块可以用template包裹</h3><p>参考: <a href=\"https://cn.vuejs.org/v2/guide/conditional.html#%E5%9C%A8-lt-template-gt-%E5%85%83%E7%B4%A0%E4%B8%8A%E4%BD%BF%E7%94%A8-v-if-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%88%86%E7%BB%84\" target=\"_blank\" rel=\"external\">Vue.js 在-lt-template-gt-元素上使用-v-if-条件渲染分组</a></p>\n<p>e.g: </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"list.length\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>header<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>list<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>footer<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-else</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>no list<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"7-v-for-循环加-key\"><a href=\"#7-v-for-循环加-key\" class=\"headerlink\" title=\"7. v-for 循环加 key\"></a>7. v-for 循环加 key</h3><p>当 <code>Vue.js</code> 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用 <strong>就地复用</strong> 策略。如果数据项的顺序被改变，<code>Vue</code> 将不会移动 <code>DOM</code> 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>\n<p>稍微深入一点，加 <code>key</code> 的原因是为了给 <code>virtualDom中</code> 的 <code>diff</code> 做优化，结果就是提高 <code>virtualDom</code> 更新效率。</p>\n<p>patch参考： <a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"external\">https://github.com/aooy/blog/issues/2</a></p>\n<h3 id=\"8-使用频率较高的方法挂载到Vue实例上\"><a href=\"#8-使用频率较高的方法挂载到Vue实例上\" class=\"headerlink\" title=\"8. 使用频率较高的方法挂载到Vue实例上\"></a>8. 使用频率较高的方法挂载到Vue实例上</h3><p>这样做的好处是不需要每次使用都要 <code>import</code>，提高开发效率。</p>\n<p>e.g: </p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype.$utils = &#123;</div><div class=\"line\">    cookie,</div><div class=\"line\">    formatDate,</div><div class=\"line\">    <span class=\"params\">...</span>vdom,</div><div class=\"line\">    getQueryString</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"literal\">new</span> Vue();</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 使用</span></div><div class=\"line\">this.$utils.getQueryString(<span class=\"string\">'from_url'</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"9-多级组件传递数据使用-attrs-和-listeners\"><a href=\"#9-多级组件传递数据使用-attrs-和-listeners\" class=\"headerlink\" title=\"9. 多级组件传递数据使用 $attrs 和 $listeners\"></a>9. 多级组件传递数据使用 <code>$attrs</code> 和 <code>$listeners</code></h3><p>在 <code>Vue 2.4</code> 版本，配合 <code>interitAttrs</code> 选项，<strong>父组件中未被 props(v-on) 绑定的属性(事件) 可以在子组件中，通过 $attrs， $listeners 获取</strong>。个人认为好处是不用再每个组件都显式绑定 <code>props</code> 或 事件，坏处是传递的属性或事件不够明确。一般情况下不需要使用，但是在创建更高层次的组件时非常有用。</p>\n<p>参考：</p>\n<p>$attrs: <a href=\"https://cn.vuejs.org/v2/api/#vm-attrs\" target=\"_blank\" rel=\"external\">https://cn.vuejs.org/v2/api/#vm-attrs</a></p>\n<p>$listeners: <a href=\"https://cn.vuejs.org/v2/api/#vm-listeners\" target=\"_blank\" rel=\"external\">https://cn.vuejs.org/v2/api/#vm-listeners</a></p>\n<h2 id=\"常见的坑\"><a href=\"#常见的坑\" class=\"headerlink\" title=\"常见的坑\"></a>常见的坑</h2><h3 id=\"1-对象和数组的更新检测\"><a href=\"#1-对象和数组的更新检测\" class=\"headerlink\" title=\"1. 对象和数组的更新检测\"></a>1. 对象和数组的更新检测</h3><p>由于 <code>JavaScript</code> 的限制，<strong>Vue 不能检测以下变动的数组</strong>：</p>\n<ul>\n<li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>\n</ul>\n<p>还是由于 <code>JavaScript</code> 的限制，<strong>Vue 不能检测对象属性的添加或删除</strong></p>\n<p>解决方法： <strong>对于数组来说可以使用vm.$set或改用可观察数组的变异方法，对于对象来说可以使用vm.$set或Object.assign</strong></p>\n<p>e.g. <a href=\"https://jsfiddle.net/hysunny/eywraw8t/228152/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/hysunny/eywraw8t/228152/</a></p>\n<h3 id=\"2-mixins同名选项混合问题\"><a href=\"#2-mixins同名选项混合问题\" class=\"headerlink\" title=\"2. mixins同名选项混合问题\"></a>2. mixins同名选项混合问题</h3><p>当我们想覆盖一个组件的一些东西或想扩展某个组件时，可以用 <code>Vue</code> 的 <code>mixins</code></p>\n<p><strong>不过要注意</strong>:</p>\n<blockquote>\n<p>当组件和混合对象含有同名选项时，同名钩子函数将混合为一个数组， 都会被调用;混合对象的钩子将在组件自身钩子之前调用。<br>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>\n</blockquote>\n<p>e.g: <a href=\"https://jsfiddle.net/hysunny/eywraw8t/228225/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/hysunny/eywraw8t/228225/</a></p>\n<h3 id=\"3-v-if-与-v-for-的优先级问题\"><a href=\"#3-v-if-与-v-for-的优先级问题\" class=\"headerlink\" title=\"3. v-if 与 v-for 的优先级问题\"></a>3. v-if 与 v-for 的优先级问题</h3><p><code>v-if</code> 与 <code>v-for</code> 一起使用时，<strong>v-for 具有比 v-if 更高的优先级</strong>，因此如果想有条件的跳过循环的执行，则需将 <code>v-if</code> 置于外层元素（或 <code>template</code>）上。如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"todos.length\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> </span></div><div class=\"line\"><span class=\"tag\">        <span class=\"attr\">v-for</span>=<span class=\"string\">\"todo in todos\"</span> </span></div><div class=\"line\"><span class=\"tag\">        <span class=\"attr\">:key</span>=<span class=\"string\">\"todo.id\"</span></span></div><div class=\"line\"><span class=\"tag\">    &gt;</span></div><div class=\"line\">       &#123;&#123; todo.name &#125;&#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-else</span>&gt;</span>No todos left!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-遍历对象顺序不一致\"><a href=\"#4-遍历对象顺序不一致\" class=\"headerlink\" title=\"4. 遍历对象顺序不一致\"></a>4. 遍历对象顺序不一致</h3><p>使用 <code>v-for</code> 遍历对象时，是按 <code>Object.keys()</code> 的结果遍历，但是不能保证它的结果在不同的 <code>JavaScript 引擎</code> 下是一致的。</p>\n<p>比如： 在 ios 下当对象的key为字母时，排序为降序，其他机型为升序。</p>\n<p>解决方法： 如果要保证顺序，可以加个排序的 <code>filter</code> 或者 改用数组。</p>\n<p>参考： <a href=\"https://github.com/vuejs/vue/issues/1827\" target=\"_blank\" rel=\"external\">https://github.com/vuejs/vue/issues/1827</a></p>\n<h3 id=\"5-event-bus-多次触发\"><a href=\"#5-event-bus-多次触发\" class=\"headerlink\" title=\"5. event bus 多次触发\"></a>5. event bus 多次触发</h3><p><code>$on</code> 的事件可在 <code>created</code> 或 <code>mounted</code> 注册</p>\n<p>需在 <code>beforeDestroy</code> 或 <code>destoryed</code> 的时候使用用 <code>$off</code> 销毁</p>\n<p>否则在某些情况下会被被多次触发</p>\n<p>e.g. <a href=\"https://jsfiddle.net/hysunny/eywraw8t/232163/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/hysunny/eywraw8t/232163/</a></p>\n<h3 id=\"6-变量命名\"><a href=\"#6-变量命名\" class=\"headerlink\" title=\"6. 变量命名\"></a>6. 变量命名</h3><p>变量名不要以<code>_</code>、<code>$</code>开头，因为名字以 <code>_</code> 或 <code>$</code> 开始的属性不会被 <code>Vue</code> 实例代理，</p>\n<p>因为它们可能与 <code>Vue</code> 的内置属性与 <code>API</code> 方法冲突。</p>\n<p>需要用 <code>vm.$data._property</code> 访问它们。</p>\n<p>e.g: <a href=\"https://jsfiddle.net/hysunny/eywraw8t/224835/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/hysunny/eywraw8t/224835/</a></p>\n<h3 id=\"7-vue-2-0-给组件绑定事件无效\"><a href=\"#7-vue-2-0-给组件绑定事件无效\" class=\"headerlink\" title=\"7. vue 2.0 给组件绑定事件无效\"></a>7. vue 2.0 给组件绑定事件无效</h3><p>对于一般的 <code>html</code> 元素，绑定自定义事件使用 <code>v-on</code>即可，但是在某个组件的 <strong>根元素</strong> 上监听一个 <strong>原生事件</strong> ，比如：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"keyword\">my</span>-component v-<span class=\"keyword\">on</span>:click=<span class=\"string\">\"handleClick\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>我们会发现这样是不起作用的，可以使用 <code>.native</code> 修饰符(某些情况) 或是 <a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6\" target=\"_blank\" rel=\"external\">$listeners</a></p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"keyword\">my</span>-component v-<span class=\"keyword\">on</span>:click.native=<span class=\"string\">\"handleClick\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>e.g. <a href=\"https://jsfiddle.net/hysunny/eywraw8t/224950/\" target=\"_blank\" rel=\"external\">用.native给自定义组件绑定事件</a></p>\n<p>哦啦~</p>\n<p>以上部分内容参考了: <a href=\"https://imys.net/20180320/vue-best-practices.html\" target=\"_blank\" rel=\"external\">Vue最佳实践</a>，非常感谢!O(∩_∩)O~</p>\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"前端开发中对安全问题的一点思考","url":"http://hysunny.me/2018/05/28/others/the-thinking-of-safety-problem/","content":"<p>最近的项目开发中写出了一个高危安全问题：</p>\n<blockquote>\n<p>项目的许多功能（比如留言@人、指定任务负责人）后需要发送企业微信通知给相应的目标用户。因为通知内容的许多字段Node端很难获取到，所以我就在前端页面拼接好内容后调用推送接口发送通知。但是由于我的疏忽，并没有对<strong>跳转链接</strong>和<strong>目标用户</strong>做校验，所以就被安全部门抓包了T^T</p>\n</blockquote>\n<p>一开始我很不以为然，觉得不是什么大问题，不晓得为什么会判定为高危漏洞。</p>\n<p>因为我觉得首先这是一个公司内部用的产品，不涉及到外部，遭到攻击的可能性很小。然后发送的通知一般也不是什么敏感信息，不至于是高危漏洞呀(*ﾟﾛﾟ)!!</p>\n<p>后来和后端大哥讨论了下，才明白是我的安全意识太薄弱啦</p>\n<p>首先，没对<strong>跳转链接</strong>最校验，就很可能遭遇“钓鱼攻击”。</p>\n<p>因为我们的项目是需要登录的，一旦非法者篡改为一个恶意链接，用户点击后，输入用户名和密码，就把自己的账号信息暴露了。</p>\n<p>其次，没对<strong>目标用户</strong>做校验，就很可能遭遇“消息泄露”。</p>\n<p>非法者拦截到请求后，把目标用户改为其他人，那么这个其他人就会收到原本不该他收到的消息，就造成了消息泄露。一旦有什么敏感信息，这就是很大的安全问题了。</p>\n<p>这些问题虽然出现的概率很低，但是一旦有非法者有心搞事情，那么很可能会带来严重的后果。</p>\n<p>充分了解了事情的严重性后，我立刻对这个问题进行了修复：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><div class=\"line\">在<span class=\"keyword\">Node</span><span class=\"title\">端：</span></div><div class=\"line\"><span class=\"title\"></span></div><div class=\"line\"><span class=\"title\">1</span>. 对跳转链接增加域名校验，只有在配置的合法域名中的链接才调用接口。</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"number\">2</span>. 增加消息类型字段，根据不同的消息类型，对目标用户进行校验。比如：项目层级的消息，就校验目标用户是不是项目成员</div></pre></td></tr></table></figure>\n<p>经过这个安全事件，尤其是和后端大哥讨论后，我才真正意识到前端开发中也是要多关注安全问题的。很多时候，一些对数据源的校验都会丢给后端去做，以至于养成了自己不严谨的毛病。安全问题不是发生的概率低就不去关注，而是首先要考虑它的严重性，它会带来哪些危害，要在开发阶段就充分考虑然后去避免安全问题。</p>\n<p>以后自己要多注意啦~(≧▽≦)/~</p>\n","categories":["开发杂记"],"tags":[]},{"title":"Chrome 浏览器 模拟 微信浏览器","url":"http://hysunny.me/2018/05/06/notes/chrome-simulate-weixin/","content":"<p>最近wap项目开发中遇到这么一个问题：</p>\n<blockquote>\n<p>我们的一个功能需要调第三方的接口，但是这个接口必须要在微信浏览器中才能调用，这就给调试工作带来了麻烦。<br>原想使用微信开发者工具进行调试，但是却提示“没有绑定开发者账号”。<br>后面灵机一动，可以用Chrome来仿真微信浏览器呀~(˘▾˘~)</p>\n</blockquote>\n<p>解决方法： <strong>增加一个自定义设备，将其User Agent设置为微信的UA</strong></p>\n<p>主要步骤为：</p>\n<p>打开<code>控制台</code> -&gt; <code>settings</code> -&gt; <code>Devices</code> -&gt; <code>Add custom device</code></p>\n<p>设备名称和大小可以随便自定义，但是UA要改成微信浏览器的，比如，我改成了：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">Mozilla/<span class=\"number\">5.0</span> (Linux; Android <span class=\"number\">7.0</span>; MI <span class=\"number\">5</span>s Build/NRD90M; wv) AppleWebKit/<span class=\"number\">537.36</span> (KHTML, like Gecko) Version/<span class=\"number\">4.0</span> Chrome/<span class=\"number\">64.0</span><span class=\"number\">.3282</span><span class=\"number\">.137</span> Mobile Safari/<span class=\"number\">537.36</span> wxwork/<span class=\"number\">2.4</span><span class=\"number\">.16</span> MicroMessenger/<span class=\"number\">6.3</span><span class=\"number\">.22</span> NetType/WIFI Language/zh</div></pre></td></tr></table></figure>\n<p>成功调用第三方接口！✌️✌️✌️</p>\n<p>其他模拟方法可参考： <a href=\"https://segmentfault.com/q/1010000002553506\" target=\"_blank\" rel=\"external\">如何用chrome在电脑上模拟微信内置浏览器</a></p>\n<p>记录完毕~</p>\n","categories":["开发杂记"],"tags":["前端"]},{"title":"XMLHttpRequest简单了解一下","url":"http://hysunny.me/2018/04/30/JavaScript/XMLHttpRequest/","content":"<p>最近的项目开发中遇到这么一个问题：</p>\n<blockquote>\n<p>因为某些历史原因，后端大大需要对线上数据做些修复处理，但是因为不是简单执行个<code>SQL</code>就能解决，所以就需要前端触发哈。<br>但是呢，我们的前端小妹又懒得写个页面写个按钮事件，所以打算就直接写个<code>HTTP GET</code>请求，调用后端的<code>Dubbo</code>接口来进行修复处理。<br>这样就很简单咯~<br>上线后直接在浏览器中调用这个get请求，数据就修复啦~<br>嗯，想象很美好，可是一上线就傻眼了，调用接口直接 <strong>403 Forbidden</strong>了，<br>查看了一下代码才想起，当初为了避免<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0\" target=\"_blank\" rel=\"external\"><code>csrf</code></a>攻击，我们在生产环境的Node端做了<strong>Referer来源校验</strong>, 代码如下：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.use(<span class=\"string\">'/api/*'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 引入 \"来源\" 判断，避免 CSRF 攻击</span></div><div class=\"line\">  <span class=\"keyword\">const</span> baseUri = <span class=\"string\">'.xxx.com'</span>  <span class=\"comment\">// 合法域名</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (runtime === <span class=\"string\">'product'</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果 referer 不存在那么返回 403</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!req.headers.referer) &#123;</div><div class=\"line\">      res.sendStatus(<span class=\"number\">403</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 利用 url.parse 获取 hostname</span></div><div class=\"line\">    <span class=\"keyword\">const</span> refererURL = url.parse(req.headers.referer)</div><div class=\"line\">    <span class=\"comment\">// 判断 hostname 是否合法</span></div><div class=\"line\">    <span class=\"keyword\">const</span> isAllowed = refererURL.hostname.endsWith(baseUri)</div><div class=\"line\">    <span class=\"keyword\">if</span> (!isAllowed) &#123;</div><div class=\"line\">      res.sendStatus(<span class=\"number\">403</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  next()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>OMG！难不成我们要修改代码重新走上线流程么？！就为了一个按钮？！想想就可怕…</p>\n<p>冷静了一会儿后，我们开始想办法解决。</p>\n<p>这时，我们想到了原生的ajax请求（即使用XMLHttpRequest）。</p>\n<p>首先，打开控制台，创建一个<strong>异步对象</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"keyword\">new</span> XMLHttpRequest();</div></pre></td></tr></table></figure>\n<p>然后，设置请求的<strong>url参数</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ajax.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/api/hotfix/'</span>);</div><div class=\"line\"><span class=\"comment\">// 参数一是请求的类型, 参数二是请求的url, 可以带参数</span></div></pre></td></tr></table></figure>\n<p>最后， <strong>发送请求</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">ajax.send();</div></pre></td></tr></table></figure>\n<p>完美 └(^^<em>)┐ ┌(</em>^^)┘</p>\n<p>当然如果需要<strong>查看请求是否发送成功</strong>还可以做如下操作：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注册事件 onreadystatechange 状态改变就会调用</span></div><div class=\"line\">ajax.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (ajax.readyState === <span class=\"number\">4</span> &amp;&amp; ajax.status === <span class=\"number\">200</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 如果能够进到这个判断 说明请求成功</span></div><div class=\"line\">　　 <span class=\"built_in\">console</span>.log(<span class=\"string\">'请求成功'</span>);</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>记录完毕~(๑¯◡¯๑)</p>\n<p>关于<code>XMLHttpRequest</code>更多了解可移步<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\" target=\"_blank\" rel=\"external\">XMLHttpRequest MDN</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"数据结构与算法JavaScript描述（13） —— 高级算法（Algorithm）","url":"http://hysunny.me/2018/02/05/JavaScript-DataStructures-and-Algorithms/Algorithm/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/371000cece4b\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/371000cece4b</a></p>\n</blockquote>\n<h3 id=\"1-动态规划\"><a href=\"#1-动态规划\" class=\"headerlink\" title=\"1. 动态规划\"></a>1. 动态规划</h3><blockquote>\n<p>与递归相反的技术。<br><code>递归</code>是从<strong>顶部</strong>开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。<strong>代码简洁，但效率不高</strong>。</p>\n<p>如计算<code>斐波那契数列</code>,存在很多值在递归调用中被<strong>重复计算</strong>。</p>\n<p><code>动态规划方案</code>从<strong>底部</strong>开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。</p>\n<p><code>动态规划方案</code>通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。<br>当算法执行完毕，最终的解将会在这个表中很明显的地方被找到。</p>\n</blockquote>\n<p>(1) 例一: 计算斐波那契数列</p>\n<blockquote>\n<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p>\n</blockquote>\n<p><code>递归方案</code>实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recurFib</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> n</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> recurFib(n - <span class=\"number\">1</span>) + recurFib(n - <span class=\"number\">2</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>动态规划方案</code>实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynFib</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">const</span> rs = []</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">    rs[i] = <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  rs[<span class=\"number\">1</span>] = <span class=\"number\">1</span></div><div class=\"line\">  rs[<span class=\"number\">2</span>] = <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// 当前值为前两个值之和</span></div><div class=\"line\">    rs[i] = rs[i - <span class=\"number\">1</span>] + rs[i - <span class=\"number\">2</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> rs[n]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'递归计算斐波那契数列'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> result1 = recurFib(<span class=\"number\">40</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result1)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'递归计算斐波那契数列'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'动态规划斐波那契数列'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> result2 = dynFib(<span class=\"number\">40</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result2)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'动态规划斐波那契数列'</span>)</div></pre></td></tr></table></figure>\n<p>多执行几次，得出测试结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">递归计算斐波那契数列: <span class=\"number\">1730.80322265625</span>ms</div><div class=\"line\">动态规划斐波那契数列: <span class=\"number\">0.30810546875</span>ms</div><div class=\"line\">&nbsp</div><div class=\"line\">递归计算斐波那契数列: <span class=\"number\">2223.50390625</span>ms</div><div class=\"line\">动态规划斐波那契数列: <span class=\"number\">0.34814453125</span>ms</div><div class=\"line\">&nbsp</div><div class=\"line\">递归计算斐波那契数列: <span class=\"number\">1730.210693359375</span>ms</div><div class=\"line\">动态规划斐波那契数列: <span class=\"number\">0.176025390625</span>ms</div></pre></td></tr></table></figure>\n<p>可以看出：<code>动态规划斐波那契数列</code>比<code>递归计算斐波那契数列</code>效率高很多。</p>\n<p>(2) 例二: 寻找两个字符串的公共子串（匹配同一位置）</p>\n<p><code>暴力方式</code>实现:</p>\n<blockquote>\n<p>给出两个字符串A和B，<br>我们可以通过从A的第一个字符开始与B对应的<strong>每一个字符</strong>进行比对的方式找到他们的最长公共子串;<br>如果此时没有找到匹配的字母，则移动到A的第二个字符处，然后从B的第一个字符开始匹配，依次类推。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lcs</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len1 = str1.length</div><div class=\"line\">  <span class=\"keyword\">const</span> len2 = str2.length</div><div class=\"line\">  <span class=\"keyword\">let</span> rs = <span class=\"string\">''</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len1; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (str1[i] === str2[i]) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> m = i</div><div class=\"line\">      <span class=\"keyword\">let</span> str = <span class=\"string\">''</span></div><div class=\"line\">      <span class=\"keyword\">while</span> (m &lt; len1 &amp;&amp; m &lt; len2 &amp;&amp; str1[m] === str2[m]) &#123;</div><div class=\"line\">        str += str1[m]</div><div class=\"line\">        m++</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (rs.length &lt; str.length) &#123;</div><div class=\"line\">        rs = str</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> rs</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>动态规划方式</code>实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dynLcs</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len1 = str1.length</div><div class=\"line\">  <span class=\"keyword\">const</span> len2 = str2.length</div><div class=\"line\">  <span class=\"keyword\">let</span> maxLen = <span class=\"number\">0</span>\t<span class=\"comment\">// 存储最长子串的长度</span></div><div class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>\t<span class=\"comment\">// 存储最长子串的最后一个字符的索引</span></div><div class=\"line\">  <span class=\"keyword\">const</span> lcsarr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len1 + <span class=\"number\">1</span>) <span class=\"comment\">// 初始化一个二维数组，来分别存储两个字符串的索引值</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len1 + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    lcsarr[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len2 + <span class=\"number\">1</span>) </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">1</span>; j &lt; len2 + <span class=\"number\">1</span>; j++) &#123;</div><div class=\"line\">      lcsarr[i][j] = <span class=\"number\">0</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (str1[i - <span class=\"number\">1</span>] !== str2[j - <span class=\"number\">1</span>] || i !== j) &#123;</div><div class=\"line\">        <span class=\"keyword\">continue</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 如果两个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元素保存的值加一</span></div><div class=\"line\">      lcsarr[i][j] = lcsarr[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (maxLen &lt; lcsarr[i][j]) &#123;</div><div class=\"line\">        maxLen = lcsarr[i][j]</div><div class=\"line\">        index = i</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 构建最长子串</span></div><div class=\"line\">  <span class=\"keyword\">let</span> str = <span class=\"string\">''</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maxLen; i++) &#123;</div><div class=\"line\">    str += str2[index - maxLen + i]</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> str</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 模拟数据</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"string\">\"abcdefghijklmnopqrstuvwxyz\"</span>.split(<span class=\"string\">''</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initData</span> (<span class=\"params\">nums</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> str = []</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; nums; i++) &#123;</div><div class=\"line\">      index = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (arr.length + <span class=\"number\">1</span>))</div><div class=\"line\">      str += arr[index] || arr[index - <span class=\"number\">1</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> str</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = initData(<span class=\"number\">1000</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> str2 = initData(<span class=\"number\">1000</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'自定义lcs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> result1 = lcs(str1, str2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result1)\t<span class=\"comment\">// ye</span></div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'自定义lcs'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'动态规划lcs'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> result2 = dynLcs(str1, str2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result2)\t<span class=\"comment\">// ye</span></div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'动态规划lcs'</span>)</div></pre></td></tr></table></figure>\n<p>多执行几次，得出测试结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">自定义lcs: <span class=\"number\">0.76904296875</span>ms</div><div class=\"line\">动态规划lcs: <span class=\"number\">46.73095703125</span>ms</div><div class=\"line\">&nbsp</div><div class=\"line\">自定义lcs: <span class=\"number\">0.77197265625</span>ms</div><div class=\"line\">动态规划lcs: <span class=\"number\">44.8828125</span>ms</div><div class=\"line\">&nbsp</div><div class=\"line\">自定义lcs: <span class=\"number\">0.296142578125</span>ms</div><div class=\"line\">动态规划lcs: <span class=\"number\">59.943115234375</span>ms</div></pre></td></tr></table></figure>\n<p>可以看出：<code>自定义lcs</code>比<code>动态规划lcs</code>效率高很多。<br><strong>注:</strong> 查了很多资料是说<code>动态规划lcs</code>要比<code>自定义lcs</code>效率高,但是经过自己测试后却是反的,不晓得是不是哪里出问题了ㄟ( ▔, ▔ )ㄏ</p>\n<p>(3) 例三: 背包问题</p>\n<blockquote>\n<p>试想你是一个保险箱大盗，打开了一个装满奇珍异宝的保险箱，但是你必须将这些宝贝放入你的一个小背包中<br>保险箱中的物品规格和价值不同，你希望自己的背包装进的宝贝总价值最大<br><strong>关键思路</strong>：计算装入背包的每一个物品的最大价值，直到背包装满</p>\n</blockquote>\n<p><code>递归方法</code>实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">knapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (capacity === <span class=\"number\">0</span> || n === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (size[n - <span class=\"number\">1</span>] &gt; capacity) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> knapsack(capacity, size, value, n - <span class=\"number\">1</span>)</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> val1 = value[n - <span class=\"number\">1</span>] + knapsack(capacity - size[n - <span class=\"number\">1</span>], size, value, n - <span class=\"number\">1</span>)</div><div class=\"line\">    <span class=\"keyword\">const</span> val2 = knapsack(capacity, size, value, n - <span class=\"number\">1</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> val1 &gt; val2 ? val1 : val2</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>动态规划方法</code>实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dKnapsack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> K = []</div><div class=\"line\">  <span class=\"comment\">// 初始化一个二维数组，来分别存储物品个数和背包容量</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; capacity + <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    K[i] = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt;= capacity; j++) &#123;</div><div class=\"line\">      <span class=\"comment\">// j 为背包容量</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (i === <span class=\"number\">0</span> || j === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// 数组的第一个元素总被设置为0</span></div><div class=\"line\">        K[i][j] = <span class=\"number\">0</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size[i - <span class=\"number\">1</span>] &lt;= j) &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> val1 = value[i - <span class=\"number\">1</span>] + K[i - <span class=\"number\">1</span>][j - size[i - <span class=\"number\">1</span>]]</div><div class=\"line\">        <span class=\"keyword\">const</span> val2 = K[i - <span class=\"number\">1</span>][j]</div><div class=\"line\">        K[i][j] = val1 &gt; val2 ? val1 : val2</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        K[i][j] = K[i - <span class=\"number\">1</span>][j]</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> K[n][capacity]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包容积</span></div><div class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"number\">5</span>     <span class=\"comment\">// 保险箱中的物品数</span></div><div class=\"line\"><span class=\"keyword\">const</span> size = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]    <span class=\"comment\">// 保险箱里的物品尺寸</span></div><div class=\"line\"><span class=\"keyword\">const</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]    <span class=\"comment\">// 保险箱里的物品价值</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'递归解决knapsack'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> maxValue1 = knapsack(capacity, size, value, n)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxValue1)\t</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'递归解决knapsack'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'动态规划解决knapsack'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> maxValue2 = dKnapsack(capacity, size, value, n)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxValue2)\t</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'动态规划解决knapsack'</span>)</div></pre></td></tr></table></figure>\n<p>得出测试结果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\">递归解决<span class=\"selector-tag\">knapsack</span>: 0<span class=\"selector-class\">.77392578125ms</span></div><div class=\"line\">动态规划解决<span class=\"selector-tag\">knapsack</span>: 0<span class=\"selector-class\">.39697265625ms</span></div></pre></td></tr></table></figure>\n<p>可以看出：<code>动态规划解决knapsack</code>效率高于<code>递归解决knapsack</code></p>\n<h3 id=\"2-贪心算法\"><a href=\"#2-贪心算法\" class=\"headerlink\" title=\"2. 贪心算法\"></a>2. 贪心算法</h3><blockquote>\n<p>总是选择当下的<strong>最优解</strong>，而不去考虑这一次的选择会不会对未来的选择造成影响。<br>使用贪心算法通常表明，实现者希望做出的这一系列<strong>局部“最优”</strong>选择能够带来最终<strong>整体“最优”</strong>选择<br>如果是这样的话，该算法将会产生一个最优解，否则，则会得到一个次优解。</p>\n</blockquote>\n<p>(1) 例一: 找零问题</p>\n<blockquote>\n<p>你从商店购买了一些商品，找零 63 美分，店员要 怎样给你这些零钱呢</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mackChange</span>(<span class=\"params\">origAmt</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> coins = []</div><div class=\"line\">  <span class=\"keyword\">if</span> (origAmt % <span class=\"number\">.25</span> &lt; origAmt) &#123;</div><div class=\"line\">    coins[<span class=\"number\">3</span>] = <span class=\"built_in\">parseInt</span>(origAmt / <span class=\"number\">.25</span>)</div><div class=\"line\">    origAmt = origAmt % <span class=\"number\">.25</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`25 美分的数量 - <span class=\"subst\">$&#123;coins[<span class=\"number\">3</span>] &#125;</span> - $<span class=\"subst\">$&#123;coins[<span class=\"number\">3</span>] * <span class=\"number\">.25</span>&#125;</span>`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (origAmt % <span class=\"number\">.1</span> &lt; origAmt) &#123;</div><div class=\"line\">    coins[<span class=\"number\">2</span>] = <span class=\"built_in\">parseInt</span>(origAmt / <span class=\"number\">.1</span>)</div><div class=\"line\">    origAmt = origAmt % <span class=\"number\">.1</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`10 美分的数量 - <span class=\"subst\">$&#123;coins[<span class=\"number\">2</span>] &#125;</span> - $<span class=\"subst\">$&#123;coins[<span class=\"number\">2</span>] * <span class=\"number\">.1</span>&#125;</span>`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (origAmt % <span class=\"number\">.05</span> &lt; origAmt) &#123;</div><div class=\"line\">    coins[<span class=\"number\">1</span>] = <span class=\"built_in\">parseInt</span>(origAmt / <span class=\"number\">.05</span>)</div><div class=\"line\">    origAmt = origAmt % <span class=\"number\">.05</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`5 美分的数量 - <span class=\"subst\">$&#123;coins[<span class=\"number\">1</span>] &#125;</span> - $<span class=\"subst\">$&#123;coins[<span class=\"number\">1</span>] * <span class=\"number\">.05</span>&#125;</span>`</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  coins[<span class=\"number\">0</span>] = <span class=\"built_in\">parseInt</span>(origAmt / <span class=\"number\">.01</span>)</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`1 美分的数量 - <span class=\"subst\">$&#123;coins[<span class=\"number\">0</span>] &#125;</span> - $<span class=\"subst\">$&#123;coins[<span class=\"number\">0</span>] * <span class=\"number\">.01</span>&#125;</span>`</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\">mackChange(<span class=\"number\">.63</span>)</div><div class=\"line\"><span class=\"comment\">// 25 美分的数量 - 2 - $0.5</span></div><div class=\"line\"><span class=\"comment\">// 10 美分的数量 - 1 - $0.1</span></div><div class=\"line\"><span class=\"comment\">// 1 美分的数量 - 3 - $0.03</span></div></pre></td></tr></table></figure>\n<p>(2) 例二: 贪心算法解决背包问题</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ksack</span>(<span class=\"params\">capacity, size, value, n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> load = <span class=\"number\">0</span>\t<span class=\"comment\">// 已放进背包的容量</span></div><div class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>\t\t<span class=\"comment\">// 放进背包的物品个数</span></div><div class=\"line\">  <span class=\"keyword\">let</span> maxValue = <span class=\"number\">0</span>\t<span class=\"comment\">// 最大价值</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (load &lt; capacity &amp;&amp; i &lt; n) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (size[i] &lt;= (capacity - load)) &#123;</div><div class=\"line\">      maxValue += value[i]</div><div class=\"line\">      load += size[i]</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> r = (capacity - load) / size[i]</div><div class=\"line\">      maxValue += r * value[i]</div><div class=\"line\">      load += size[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">    i++</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> maxValue</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> capacity = <span class=\"number\">16</span> <span class=\"comment\">// 背包容积</span></div><div class=\"line\"><span class=\"keyword\">const</span> n = <span class=\"number\">5</span>     <span class=\"comment\">// 保险箱中的物品数</span></div><div class=\"line\"><span class=\"keyword\">const</span> size = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]    <span class=\"comment\">// 保险箱里的物品尺寸</span></div><div class=\"line\"><span class=\"keyword\">const</span> value = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]    <span class=\"comment\">// 保险箱里的物品价值</span></div><div class=\"line\"><span class=\"keyword\">const</span> maxValue = ksack(capacity, size, value, n)     </div><div class=\"line\"><span class=\"built_in\">console</span>.log(maxValue) <span class=\"comment\">// 21.75</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（12） —— 检索算法（Search）","url":"http://hysunny.me/2018/01/24/JavaScript-DataStructures-and-Algorithms/Search/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/45445f69e5fa\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/45445f69e5fa</a></p>\n</blockquote>\n<h3 id=\"1-顺序查找\"><a href=\"#1-顺序查找\" class=\"headerlink\" title=\"1. 顺序查找\"></a>1. 顺序查找</h3><p>（1）查找某值<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seqSearch</span>(<span class=\"params\">arr, target</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr &amp;&amp; arr.length</div><div class=\"line\">  <span class=\"keyword\">if</span> (!len) <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === target) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> i</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> result1 = seqSearch(arr1, <span class=\"number\">82</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result1)\t<span class=\"comment\">// 8</span></div></pre></td></tr></table></figure></p>\n<p>（2）查找最小值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMin</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr &amp;&amp; arr.length</div><div class=\"line\">  <span class=\"keyword\">if</span> (!len) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">let</span> min = arr[<span class=\"number\">0</span>]</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &lt; min) &#123;</div><div class=\"line\">      min = arr[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> min</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> result2 = findMin(arr2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result2)\t<span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>（3）查找最大值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findMax</span>(<span class=\"params\">arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr &amp;&amp; arr.length</div><div class=\"line\">  <span class=\"keyword\">if</span> (!len) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">  <span class=\"keyword\">let</span> max = arr[<span class=\"number\">0</span>]</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] &gt; max) &#123;</div><div class=\"line\">      max = arr[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> max</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr3 = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> result3 = findMax(arr3)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result3)\t<span class=\"comment\">// 82</span></div></pre></td></tr></table></figure>\n<p>（4）包含<strong>自组织方式</strong>的顺序查找</p>\n<blockquote>\n<p>使用自组织（数据的位置并非由程序员在执行之前就组织好，而是<strong>在程序运行过程中由程序自动组织的</strong>）数据<br>通过将频繁查找到的元素置于数据集的起始位置来<strong>最小化查找次数</strong>。</p>\n</blockquote>\n<p>a. 包含自组织方式的seqSearch（1）：不断检查确认已找到的数据是否已经排在最前面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seqSearch</span>(<span class=\"params\">arr, target</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr.length</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === target) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        [arr[i - <span class=\"number\">1</span>], arr[i]] = [arr[i], arr[i - <span class=\"number\">1</span>]]</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr4 =  [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> result4 =  seqSearch(arr4, <span class=\"number\">77</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(arr4)</div><div class=\"line\">    <span class=\"comment\">// [72, 54, 59, 30, 31, 78, 77, 2, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [72, 54, 59, 30, 31, 77, 78, 2, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [72, 54, 59, 30, 77, 31, 78, 2, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [72, 54, 59, 77, 30, 31, 78, 2, 82, 72]</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>b. 包含自组织方式的seqSearch（2）：将找到的元素移动到数据集的<strong>起始</strong>位置，但是如果这个元素已经很接近起始位置，则不会对它的位置进行交换。</p>\n<blockquote>\n<p>80-20原则：对某一数据集执行的80%的查找操作都是对其中20%的数据元素进行查找。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seqSearch</span>(<span class=\"params\">arr, target</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr.length</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === target) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (i &gt; (arr.length * <span class=\"number\">0.2</span>)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 仅当数据位于数据集的前20%元素之外时，该数据才需要被重新移动到数据集的起始位置。</span></div><div class=\"line\">        [arr[<span class=\"number\">0</span>], arr[i]] = [arr[i], arr[<span class=\"number\">0</span>]]</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr5 =  [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">4</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> result5 =  seqSearch(arr5, <span class=\"number\">77</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(arr5)</div><div class=\"line\">    <span class=\"comment\">// [77, 54, 59, 30, 31, 78, 2, 72, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [77, 54, 59, 30, 31, 78, 2, 72, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [77, 54, 59, 30, 31, 78, 2, 72, 82, 72]</span></div><div class=\"line\">    <span class=\"comment\">// [77, 54, 59, 30, 31, 78, 2, 72, 82, 72]</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-二分查找算法【已排序数据】\"><a href=\"#2-二分查找算法【已排序数据】\" class=\"headerlink\" title=\"2. 二分查找算法【已排序数据】\"></a>2. 二分查找算法【已排序数据】</h3><blockquote>\n<p>算法描述：<br>（1）将数组的第一个位置设置为下边界（0）<br>（2）将数组最后一个元素所在的位置设置为上边界（数组的长度减1）<br>（3）若下边界等于或小于上边界，则做如下操作：<br>a. 将中点设置为（上边界加上下边界）除以2<br>b. 如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加1<br>c. 如果中点的元素大于查询的值，则将上边界设置为中点元素所在下标减1<br>d. 否则中点元素即为要查找的数据，可以进行返回</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binSearch</span>(<span class=\"params\">arr, target</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr.length</div><div class=\"line\">  <span class=\"keyword\">let</span> upperBound = len - <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">let</span> lowBound = <span class=\"number\">0</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (lowBound &lt;= upperBound) &#123;</div><div class=\"line\">    <span class=\"comment\">// 将中点设置为 (上边界 + 下边界) / 2</span></div><div class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor((lowBound + upperBound) / <span class=\"number\">2</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`当前的中点值：<span class=\"subst\">$&#123;arr[mid]&#125;</span>`</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span> (arr[mid] &lt; target) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果中点的元素小于查询的值，则将下边界设置为中点元素所在的下标加一</span></div><div class=\"line\">      lowBound = mid + <span class=\"number\">1</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (arr[mid] &gt; target) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果中点的元素大于查询的值，则将上边界设置为中点元素所在的下标减一</span></div><div class=\"line\">      upperBound = mid - <span class=\"number\">1</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 否则中点元素即为要查找的数据，可以进行返回</span></div><div class=\"line\">      <span class=\"keyword\">return</span> mid</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr6 = [<span class=\"number\">2</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">72</span>, <span class=\"number\">72</span>, <span class=\"number\">77</span>, <span class=\"number\">78</span>, <span class=\"number\">82</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> result6 = binSearch(arr6, <span class=\"number\">78</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(result6)</div><div class=\"line\"><span class=\"comment\">// 当前的中点值：59</span></div><div class=\"line\"><span class=\"comment\">// 当前的中点值：77</span></div><div class=\"line\"><span class=\"comment\">// 当前的中点值：78</span></div><div class=\"line\"><span class=\"comment\">// 8</span></div></pre></td></tr></table></figure>\n<p>示例：计算一个数组中某个数的重复次数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">arr, target</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = arr.length</div><div class=\"line\">  <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></div><div class=\"line\">  arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123; <span class=\"keyword\">return</span> a - b &#125;)</div><div class=\"line\">  <span class=\"keyword\">let</span> pos = binSearch(arr, target)</div><div class=\"line\">  <span class=\"keyword\">if</span> (pos &gt; <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">    count++</div><div class=\"line\">    <span class=\"comment\">// 向下（左）遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时停止计数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = pos - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === target) &#123;</div><div class=\"line\">        count++</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">break</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 向上(右)遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时停止计数</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = pos + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (arr[j] === target) &#123;</div><div class=\"line\">        count++</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">break</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> count</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> arr7 = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> result7 = count(arr7, <span class=\"number\">72</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`重复次数为：<span class=\"subst\">$&#123;result7&#125;</span>次`</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 当前的中点值：59</span></div><div class=\"line\"><span class=\"comment\">// 当前的中点值：77</span></div><div class=\"line\"><span class=\"comment\">// 当前的中点值：72</span></div><div class=\"line\"><span class=\"comment\">// 重复次数为：2次</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（11） —— 高级排序算法（Sort）","url":"http://hysunny.me/2018/01/24/JavaScript-DataStructures-and-Algorithms/advanced-Sort/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/d99183687cf1\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/d99183687cf1</a></p>\n</blockquote>\n<h3 id=\"1-希尔排序\"><a href=\"#1-希尔排序\" class=\"headerlink\" title=\"1. 希尔排序\"></a>1. 希尔排序</h3><blockquote>\n<p><code>希尔排序</code>的核心理念与<code>插入排序</code>不同，它会首先比较距离<strong>较远</strong>的元素，而非相邻的元素。<br>和简单地比较相邻元素相比，使用这种方案可以<strong>使离正确位置很远的元素更快地回到合适的位置</strong>。<br>当开始用这个算法遍历数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的就是相邻元素了。</p>\n</blockquote>\n<p>间隔序列：701, 301, 132, 57, 23, 10, 4, 1<br>参照：<a href=\"http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf\" target=\"_blank\" rel=\"external\">Best Increments for the Average Case of Shell Sort</a></p>\n<p>（1）自定义间隔值（硬编码间隔序列）</p>\n<p> 实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">data, gaps</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> dLen = data.length</div><div class=\"line\">  <span class=\"keyword\">const</span> gLen = gaps.length</div><div class=\"line\">  <span class=\"comment\">// 根据间隔序列循环数组数据</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> g = <span class=\"number\">0</span>; g &lt; gLen; g++) &#123;</div><div class=\"line\">    <span class=\"comment\">// 循环间隔下的分组数据，从每个分组的第二个数开始</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gaps[g]; i &lt; dLen; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> temp = data[i]</div><div class=\"line\">      <span class=\"keyword\">let</span> j = i</div><div class=\"line\">      <span class=\"comment\">// 将 data[j] 和 data[j - gaps[g]] 进行比较，也就是比较间隔 gaps[g] 的两个数字的大小向右移 gaps[g] 位</span></div><div class=\"line\">      <span class=\"comment\">// 从右至左，如果 data[j - gaps[g]] 大于temp，则已排序数据</span></div><div class=\"line\">      <span class=\"keyword\">while</span> ((j &gt;= gaps[g]) &amp;&amp; (data[j - gaps[g]] &gt; temp)) &#123;</div><div class=\"line\">        data[j] = data[j - gaps[g]]</div><div class=\"line\">        j -= gaps[g]</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"comment\">// 空出来的位置放置 temp</span></div><div class=\"line\">      data[j] = temp</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">shellSort(a, [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>])</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a)  <span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行<code>硬编码间隔序列希尔排序</code>的过程</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-86175b3403be7551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>（2）动态计算间隔值（动态间隔序列）</p>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dShellSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">let</span> gap = <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"comment\">// 计算间隔最大值</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (gap &lt; len / <span class=\"number\">3</span>) &#123;</div><div class=\"line\">    gap = <span class=\"number\">3</span> * gap + <span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 循环间隔值</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (gap &gt;= <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 循环间隔下的分组数据，从每个分组的第二个数开始</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = gap; i &lt; len; i++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 从右至左，如果 data[j - gap] 大于 data[j] 并且 j &gt; gap，则交换两值</span></div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i; j &gt;= gap &amp;&amp; data[j] &lt; data[j - gap]; j -= gap) &#123;</div><div class=\"line\">        [data[j], data[j - gap]] = [data[j - gap], data[j]]</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    gap = (gap - <span class=\"number\">1</span>) / <span class=\"number\">3</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">dShellSort(b)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>（3）测试两种希尔排序效率</p>\n<p>a. 实现一个测试平台</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CArray</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(count) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.data = []</div><div class=\"line\">    <span class=\"keyword\">this</span>.count = count</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  setData() &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.count; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.data[i] = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (<span class=\"keyword\">this</span>.count + <span class=\"number\">1</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>b. 进行测试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> CArray(<span class=\"number\">1000</span>)</div><div class=\"line\">arr.setData()</div><div class=\"line\"><span class=\"keyword\">var</span> data1 = arr.data</div><div class=\"line\"><span class=\"keyword\">var</span> data2 = data1.concat()</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'硬编码间隔序列shellSort'</span>)</div><div class=\"line\">shellSort(data1, [<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>])</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data1)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'硬编码间隔序列shellSort'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'动态间隔序列shellSort'</span>)</div><div class=\"line\">dShellSort(data2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data2)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'动态间隔序列shellSort'</span>)</div></pre></td></tr></table></figure>\n<p>多执行几次，得出测试结果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\">硬编码间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.715087890625ms</span></div><div class=\"line\">动态间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.251220703125ms</span></div><div class=\"line\">&nbsp</div><div class=\"line\">硬编码间隔序列<span class=\"selector-tag\">shellSort</span>: 3<span class=\"selector-class\">.259765625ms</span></div><div class=\"line\">动态间隔序列<span class=\"selector-tag\">shellSort</span>: 3<span class=\"selector-class\">.214111328125ms</span></div><div class=\"line\">&nbsp</div><div class=\"line\">硬编码间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.001953125ms</span></div><div class=\"line\">动态间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.109130859375ms</span></div><div class=\"line\">&nbsp</div><div class=\"line\">硬编码间隔序列<span class=\"selector-tag\">shellSort</span>: 1<span class=\"selector-class\">.935791015625ms</span></div><div class=\"line\">动态间隔序列<span class=\"selector-tag\">shellSort</span>: 3<span class=\"selector-class\">.258056640625ms</span></div><div class=\"line\">&nbsp</div><div class=\"line\">硬编码间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.023193359375ms</span></div><div class=\"line\">动态间隔序列<span class=\"selector-tag\">shellSort</span>: 2<span class=\"selector-class\">.18994140625ms</span></div></pre></td></tr></table></figure>\n<p>可以看出：<code>硬编码间隔序列shellSort</code>和<code>动态间隔序列shellSort</code>效率差不多。</p>\n<h3 id=\"2-归并排序\"><a href=\"#2-归并排序\" class=\"headerlink\" title=\"2. 归并排序\"></a>2. 归并排序</h3><blockquote>\n<p>原理：把一系列排好序的子序列<strong>合并</strong>成一个大的完整有序序列 —— <strong>自底向上</strong>的<code>归并排序</code>。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">let</span> step = <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">let</span> left, right</div><div class=\"line\">  <span class=\"comment\">// 从 step = 1开始，分割 2 * step 个子序列</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (step &lt; len) &#123;</div><div class=\"line\">    left = <span class=\"number\">0</span></div><div class=\"line\">    right = step</div><div class=\"line\">    <span class=\"comment\">// 循环数据</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (right + step &lt;= len) &#123;</div><div class=\"line\">      <span class=\"comment\">// 合并左右子序列</span></div><div class=\"line\">      mergeArrays(data, left, left + step, right, right + step)</div><div class=\"line\">      left = right + step</div><div class=\"line\">      right = left + step</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (right &lt; len) &#123;</div><div class=\"line\">      mergeArrays(data, left, left + step, right, len)</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    step *= <span class=\"number\">2</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 合并数组</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeArrays</span>(<span class=\"params\">arr, startLeft, stopLeft, startRight, stopRight</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> leftArr = []</div><div class=\"line\">  <span class=\"keyword\">const</span> rightArr = []</div><div class=\"line\">  <span class=\"comment\">// 生成左子序列数组</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = startLeft; i &lt; stopLeft; i++) &#123;</div><div class=\"line\">    leftArr.push(arr[i])</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 生成右子序列数组</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = startRight; j &lt; stopRight; j++) &#123;</div><div class=\"line\">    rightArr.push(arr[j])</div><div class=\"line\">  &#125;</div><div class=\"line\">  leftArr.push(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// 添加哨兵值</span></div><div class=\"line\">  rightArr.push(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// 添加哨兵值</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 合并两个子序列数组并替换原数组序列</span></div><div class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">0</span></div><div class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">0</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = startLeft; k &lt; stopRight; k++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (leftArr[m] &lt;= rightArr[n]) &#123;</div><div class=\"line\">      arr[k] = leftArr[m]</div><div class=\"line\">      m++</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      arr[k] = rightArr[n]</div><div class=\"line\">      n++</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> e = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">mergeSort(e)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(e)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行<code>归并排序</code>的过程</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-28d4358ff69c7e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"3-快速排序\"><a href=\"#3-快速排序\" class=\"headerlink\" title=\"3. 快速排序\"></a>3. 快速排序</h3><blockquote>\n<p><code>快速排序</code>是处理大数据集<strong>最快</strong>的排序算法之一。<br>它是一种<strong>分而治之</strong>的算法，通过递归的方法将数据依次分解为包含较小元素和较大元素的不同子序列。<br>该算法不断重复这个步骤直到所有数据都是有序的。</p>\n<p>步骤：<br>（1）选择一个元素作为<strong>基准值</strong>(pivot)，将列表分割成两个子序列。<br>（2）将列表重新排序，将所有<strong>小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面</strong>；<br>（3）分别对较小元素的子序列和较大元素的子序列重复步骤1和2</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">qSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> data</div><div class=\"line\">  <span class=\"keyword\">const</span> leftArr = []</div><div class=\"line\">  <span class=\"keyword\">const</span> rightArr = []</div><div class=\"line\">  <span class=\"comment\">// 设数组第一个元素为基准值(pivot)</span></div><div class=\"line\">  <span class=\"keyword\">let</span> pivot = data[<span class=\"number\">0</span>]</div><div class=\"line\">  <span class=\"comment\">// 将列表重新排序，将所有小于基准值的元素放在基准值的前面。所有大于基准值的元素放在基准值的后面</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (data[i] &lt; pivot) &#123;</div><div class=\"line\">      leftArr.push(data[i])</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      rightArr.push(data[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  <span class=\"keyword\">return</span> qSort(leftArr).concat(pivot, qSort(rightArr))</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test </span></div><div class=\"line\"><span class=\"keyword\">const</span> f = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> g = qSort(f)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(g)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行<code>快速排序</code>的过程</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-3d2157ae01299c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（10） —— 基本排序算法（Sort）","url":"http://hysunny.me/2018/01/23/JavaScript-DataStructures-and-Algorithms/Sort/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/b14c78e91571\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/b14c78e91571</a></p>\n</blockquote>\n<h3 id=\"1-冒泡排序算法\"><a href=\"#1-冒泡排序算法\" class=\"headerlink\" title=\"1. 冒泡排序算法\"></a>1. 冒泡排序算法</h3><blockquote>\n<p>是<strong>最慢</strong>的排序算法之一，但也是一种最容易实现的排序算法。<br>按照升序排列：依次比较相邻的数据，较小的值冒泡到左侧，较大的值冒泡到右侧<br>按照降序排列：依次比较相邻的数据，较小的值冒泡到右侧，较大的值冒泡到左侧</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;= outer - <span class=\"number\">1</span>; inner++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data[inner] &gt; data[inner + <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 若前一个值大于后一个值，则交换两个值</span></div><div class=\"line\">        [data[inner], data[inner + <span class=\"number\">1</span>]] = [data[inner + <span class=\"number\">1</span>], data[inner]]</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> a = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">bubbleSort(a)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行冒泡排序的过程（红框里的数据为我们为了观察冒泡过程而设定的两个特定值）</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-b1b0315e9a996c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2. 选择排序\"></a>2. 选择排序</h3><blockquote>\n<p>从数组的开头开始，将第一个元素和其他元素进行比较。检查完所有元素后，<strong>最小</strong>的元素会被放到数组的<strong>第一个位置</strong>，然后算法会从第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便完成了排序。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">let</span> min </div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = <span class=\"number\">0</span>; outer &lt; len - <span class=\"number\">1</span>; outer++) &#123;</div><div class=\"line\">    min = outer</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> inner = outer + <span class=\"number\">1</span>; inner &lt; len; inner++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data[inner] &lt; data[min]) &#123;</div><div class=\"line\">        min = inner</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [data[outer], data[min]] = [data[min], data[outer]]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> b = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">selectionSort(b)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(b)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行选择排序的过程（红框里的数据为每次循环中最小的元素）</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-c24fd6e85ee499f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><blockquote>\n<p><code>插入排序</code>类似于人类按数字或字母顺序对数据进行排序。<br><code>插入排序</code>有两个循环。<code>外循环</code>将数组元素挨个移动，而<code>内循环</code>则对外循环选中的元素及它后面的那个元素进行比较。如果外循环中选中的元素比内循环中的元素<strong>小</strong>，那么数组元素会<strong>向右</strong>移动，为内循环中的这个元素腾出位置。</p>\n<p>步骤：<br>（1）从第一个元素开始，该元素可以认为已经被排序<br>（2）取出下一个元素，在已经排序的元素序列中从后向前扫描<br>（3）如果该元素（已排序）大于新元素，将该元素移到下一位置<br>（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>（5）将新元素插入到该位置后<br>（6）重复步骤2~5</p>\n</blockquote>\n<p>实现：</p>\n<p>方法一：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">let</span> temp, inner</div><div class=\"line\">  <span class=\"comment\">// 外循环：待排序的数据</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = <span class=\"number\">1</span>; outer &lt; len; outer++) &#123;</div><div class=\"line\">    temp = data[outer]</div><div class=\"line\">    inner = outer</div><div class=\"line\">    <span class=\"keyword\">while</span>(inner &gt; <span class=\"number\">0</span> &amp;&amp; data[inner - <span class=\"number\">1</span>] &gt;= temp) &#123;</div><div class=\"line\">      <span class=\"comment\">// 内循环：已完成排序的数据</span></div><div class=\"line\">      <span class=\"comment\">// 比较待排序和已完成排序数据（从右至左），如果已排序的数据大于temp，则已排序数据向右移一位</span></div><div class=\"line\">      data[inner] = data[inner - <span class=\"number\">1</span>]</div><div class=\"line\">      inner--</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 空出来的 原已排序的位置 放置待排序的数据</span></div><div class=\"line\">    data[inner] = temp</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> c = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">insertSort(c)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(c)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>方法二：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"comment\">// 外循环：待排序的数据</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = <span class=\"number\">1</span>; outer &lt; len; outer++) &#123;</div><div class=\"line\">    <span class=\"comment\">// 内循环：已完成排序的数据</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt; outer; inner++) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果外循环小于内循环（待排序小于已排序），则数组元素将会向右移动</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (data[inner] &gt; data[outer]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将待排序数据插入到已排序的位置</span></div><div class=\"line\">        data.splice(inner, <span class=\"number\">0</span>, data[outer])</div><div class=\"line\">        <span class=\"comment\">// 删除原先待排序的数据</span></div><div class=\"line\">        data.splice(outer + <span class=\"number\">1</span>, <span class=\"number\">1</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> d = [<span class=\"number\">72</span>, <span class=\"number\">54</span>, <span class=\"number\">59</span>, <span class=\"number\">30</span>, <span class=\"number\">31</span>, <span class=\"number\">78</span>, <span class=\"number\">2</span>, <span class=\"number\">77</span>, <span class=\"number\">82</span>, <span class=\"number\">72</span>]</div><div class=\"line\">insertSort(d)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(d)\t<span class=\"comment\">// [2, 30, 31, 54, 59, 72, 72, 77, 78, 82]</span></div></pre></td></tr></table></figure>\n<p>下图展示了上例中的数据进行插入排序的过程（红框里的数据为每次外循环执行完后被插入的元素）</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-0080cfb3d8a9f109.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"4-三种基本排序的效率\"><a href=\"#4-三种基本排序的效率\" class=\"headerlink\" title=\"4. 三种基本排序的效率\"></a>4. 三种基本排序的效率</h3><p>（1）首先，实现一个测试平台，进行测试数据的生成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 测试平台</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CArray</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(count) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.data = []</div><div class=\"line\">    <span class=\"keyword\">this</span>.count = count</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  setData() &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.count; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.data[i] = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (<span class=\"keyword\">this</span>.count + <span class=\"number\">1</span>))</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）声明排序算法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 冒泡排序</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;= outer - <span class=\"number\">1</span>; inner++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data[inner] &gt; data[inner + <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 若前一个值大于后一个值，则交换两个值</span></div><div class=\"line\">        [data[inner], data[inner + <span class=\"number\">1</span>]] = [data[inner + <span class=\"number\">1</span>], data[inner]]</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 选择排序</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectionSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">let</span> min </div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = <span class=\"number\">0</span>; outer &lt; len - <span class=\"number\">1</span>; outer++) &#123;</div><div class=\"line\">    min = outer</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> inner = outer + <span class=\"number\">1</span>; inner &lt; len; inner++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data[inner] &lt; data[min]) &#123;</div><div class=\"line\">        min = inner</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    [data[outer], data[min]] = [data[min], data[outer]]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 插入排序</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> len = data.length</div><div class=\"line\">  <span class=\"keyword\">let</span> temp, inner</div><div class=\"line\">  <span class=\"comment\">// 外循环：待排序的数据</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = <span class=\"number\">1</span>; outer &lt; len; outer++) &#123;</div><div class=\"line\">    temp = data[outer]</div><div class=\"line\">    inner = outer</div><div class=\"line\">    <span class=\"keyword\">while</span>(inner &gt; <span class=\"number\">0</span> &amp;&amp; data[inner - <span class=\"number\">1</span>] &gt;= temp) &#123;</div><div class=\"line\">      <span class=\"comment\">// 内循环：已完成排序的数据</span></div><div class=\"line\">      <span class=\"comment\">// 比较待排序和已完成排序数据（从右至左），如果已排序的数据大于temp，则已排序数据向右移一位</span></div><div class=\"line\">      data[inner] = data[inner - <span class=\"number\">1</span>]</div><div class=\"line\">      inner--</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 空出来的 原已排序的位置 放置待排序的数据</span></div><div class=\"line\">    data[inner] = temp</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（3）进行测试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> CArray(<span class=\"number\">1000</span>)</div><div class=\"line\">arr.setData()</div><div class=\"line\"><span class=\"keyword\">var</span> data1 = arr.data</div><div class=\"line\"><span class=\"keyword\">var</span> data2 = data1.concat()</div><div class=\"line\"><span class=\"keyword\">var</span> data3 = data1.concat()</div><div class=\"line\"><span class=\"comment\">// 冒泡排序</span></div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'bubbleSort'</span>)</div><div class=\"line\">bubbleSort(data1)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data1)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'bubbleSort'</span>) </div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 选择排序</span></div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'selectionSort'</span>)</div><div class=\"line\">bubbleSort(data2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data2)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'selectionSort'</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 插入排序</span></div><div class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'insertSort'</span>)</div><div class=\"line\">bubbleSort(data3)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(data3)</div><div class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'insertSort'</span>)</div></pre></td></tr></table></figure>\n<p>多执行几次测试代码，我们可以看到测试结果<br><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">bubbleSort</span>: 29.56201171875ms</div><div class=\"line\"><span class=\"attribute\">selectionSort</span>: 24.248046875ms</div><div class=\"line\"><span class=\"attribute\">insertSort</span>: 15.97119140625ms</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"attribute\">bubbleSort</span>: 25.317138671875ms</div><div class=\"line\"><span class=\"attribute\">selectionSort</span>: 20.39404296875ms</div><div class=\"line\"><span class=\"attribute\">insertSort</span>: 13.625ms</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"attribute\">bubbleSort</span>: 28.112060546875ms</div><div class=\"line\"><span class=\"attribute\">selectionSort</span>: 21.611083984375ms</div><div class=\"line\"><span class=\"attribute\">insertSort</span>: 16.8720703125ms</div></pre></td></tr></table></figure></p>\n<p>我们可以得出如下结论：</p>\n<p>效率： <code>插入排序</code> &gt; <code>选择排序</code> &gt; <code>冒泡排序</code></p>\n","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（9） —— 图（Graph）","url":"http://hysunny.me/2018/01/19/JavaScript-DataStructures-and-Algorithms/Graph/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/9d9a16019859\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/9d9a16019859</a></p>\n</blockquote>\n<h3 id=\"1-图的定义\"><a href=\"#1-图的定义\" class=\"headerlink\" title=\"1. 图的定义\"></a>1. 图的定义</h3><blockquote>\n<p>图由<code>边</code>的集合及<code>顶点</code>的集合组成。<br>边由<code>顶点对</code>(v1, v2)定义，v1和v2分别是图中的两个顶点。<br>顶点也有<code>权重</code>，也称为成本。<br>图中的一系列顶点构成<code>路径</code>，路径中所有的顶点都由边连接。<br>路径的长度用路径中<strong>第一个顶点</strong>到<strong>最后一个顶点</strong>之间边的数量表示。</p>\n<p>如果一个图的顶点对是有序的，则可以称之为有向图。有向图表明了顶点的流向。<br><img src=\"http://upload-images.jianshu.io/upload_images/3779867-93462eaf87298b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"有向图.png\"></p>\n<p>如果图是无序的，则称之为无序图，或无向图：<br><img src=\"http://upload-images.jianshu.io/upload_images/3779867-4a6fa78fc35a7a31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"无序图.png\"></p>\n</blockquote>\n<p>本篇主要讨论无序图。</p>\n<blockquote>\n<p>表示图的边的方法称为<code>邻接表</code>或者<code>邻接数组</code>。<br>这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。<br><img src=\"http://upload-images.jianshu.io/upload_images/3779867-fa8aee35eb7e7baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"邻接表.png\"></p>\n</blockquote>\n<h3 id=\"2-图算法-——-搜索图\"><a href=\"#2-图算法-——-搜索图\" class=\"headerlink\" title=\"2. 图算法 —— 搜索图\"></a>2. 图算法 —— 搜索图</h3><p>（1）深度优先搜索<br>深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-2265f83922065e63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"深度优先搜索.png\"></p>\n</blockquote>\n<p>（2）广度优先搜索<br>广度优先搜索从第一个顶点开始，尝试尽可能靠近它的顶点。本质上，这种搜索在图上是<strong>逐层</strong>移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层。<br>广度优先算法使用了抽象队列来对已访问过的顶点进行排序。原理如下：<br><figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">a</span>. 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中；</div><div class=\"line\"><span class=\"selector-tag\">b</span>. 从图中取出下一个顶点v，添加到已访问的顶点列表</div><div class=\"line\">c. 将所有与v相邻的未访问顶点添加到队列</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-89f084546a7d0453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"广度优先搜索.png\"></p>\n</blockquote>\n<h3 id=\"3-实现一个图类\"><a href=\"#3-实现一个图类\" class=\"headerlink\" title=\"3. 实现一个图类\"></a>3. 实现一个图类</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Graph</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(v = 0, vertexList = []) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.vertices = v <span class=\"comment\">// 顶点数</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.edges = <span class=\"number\">0</span>\t<span class=\"comment\">// 边数</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adj = []\t\t<span class=\"comment\">// 邻接数组</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.marked = []\t<span class=\"comment\">// 存储已访问的节点</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.edgeTo = []\t<span class=\"comment\">// 保存一个顶点到下一个顶点的所有边</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.vertexList = vertexList\t<span class=\"comment\">// 将各个顶点关联到一个符号</span></div><div class=\"line\">    <span class=\"comment\">// 为每个顶点初始化一个数组用来存储与他相连的节点</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.adj[i] = []</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 初始化所有顶点为未访问过</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.marked[i] = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 添加一条边</span></div><div class=\"line\">  addEdge(v, w) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.adj[v].push(w)</div><div class=\"line\">    <span class=\"keyword\">this</span>.adj[w].push(v)</div><div class=\"line\">    <span class=\"keyword\">this</span>.edges++</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 深度优先搜索</span></div><div class=\"line\">  <span class=\"comment\">// 访问一个没有被访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有被访问顶点</span></div><div class=\"line\">  dfs(v = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.marked[v] = <span class=\"literal\">true</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.adj[v] !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Visited vertex: <span class=\"subst\">$&#123;v&#125;</span>`</span>)</div><div class=\"line\">        <span class=\"keyword\">this</span>.adj[v].forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.marked[item]) &#123;</div><div class=\"line\">                <span class=\"keyword\">this</span>.dfs(item)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 广度优先搜索</span></div><div class=\"line\">  <span class=\"comment\">// (1) 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中</span></div><div class=\"line\">  <span class=\"comment\">// (2) 从图中取出下一个顶点v，添加到已访问的顶点列表中</span></div><div class=\"line\">  <span class=\"comment\">// (3) 将所有与v相邻的未访问顶点添加到队列中</span></div><div class=\"line\">  bfs(s = <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.resetMarked()</div><div class=\"line\">    <span class=\"keyword\">const</span> queue = []</div><div class=\"line\">    <span class=\"keyword\">this</span>.marked[s] = <span class=\"literal\">true</span></div><div class=\"line\">    queue.push(s) <span class=\"comment\">// 添加到队尾</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(queue.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> v = queue.shift() <span class=\"comment\">// 从队首移除</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.adj[v] !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Visited vertex: <span class=\"subst\">$&#123;v&#125;</span>`</span>)</div><div class=\"line\">        <span class=\"comment\">// 遍历访问与v的邻接表中其他没有被访问的顶点</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.adj[v].forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.marked[item]) &#123;</div><div class=\"line\">            <span class=\"comment\">// 保存 item =&gt; v 的边</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.edgeTo[item] = v</div><div class=\"line\">            <span class=\"comment\">// 将 item 标记为已访问</span></div><div class=\"line\">            <span class=\"keyword\">this</span>.marked[item] = <span class=\"literal\">true</span></div><div class=\"line\">            queue.push(item)</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.resetMarked()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 存储与指定顶点有共同边的所有顶点</span></div><div class=\"line\">  pathTo(v) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.dfs()</div><div class=\"line\">    <span class=\"keyword\">let</span> source = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.marked[v]) <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span></div><div class=\"line\">    <span class=\"keyword\">const</span> path = []</div><div class=\"line\">    <span class=\"keyword\">let</span> i = v</div><div class=\"line\">    <span class=\"keyword\">while</span>  (i !== source) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.edgeTo[i] !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        path.push(i)</div><div class=\"line\">        i = <span class=\"keyword\">this</span>.edgeTo[i]</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        i = source</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    path.push(source)</div><div class=\"line\">    <span class=\"keyword\">this</span>.resetMarked()</div><div class=\"line\">    <span class=\"keyword\">return</span> path.reverse()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 拓扑排序</span></div><div class=\"line\">  <span class=\"comment\">// 设置排序进程并调用一个辅助函数 topSortHelper()</span></div><div class=\"line\">  <span class=\"comment\">// 然后显示排序好的顶点列表</span></div><div class=\"line\">  topSort() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> stack = []</div><div class=\"line\">    <span class=\"keyword\">const</span> visited = []</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      visited[i] = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!visited[i]) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.topSortHelper(i, visited, stack)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = stack.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (stack[i] !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.vertexList[stack[i]])</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 拓扑排序辅助函数</span></div><div class=\"line\">  <span class=\"comment\">// 将当前顶点标记为已访问，然后递归地访问当前顶点邻接表中每个相邻顶点，标记这些顶点为已访问。</span></div><div class=\"line\">  <span class=\"comment\">// 最后将当前顶点压入栈</span></div><div class=\"line\">  topSortHelper(v, visited, stack) &#123;</div><div class=\"line\">    visited[v] = <span class=\"literal\">true</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.adj[v].forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!visited[item]) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.topSortHelper(item, visited, stack)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    stack.push(v)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  showGraph() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> visited = []</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">' '</span>)</div><div class=\"line\">      visited.push(<span class=\"keyword\">this</span>.vertexList[i])</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"keyword\">this</span>.vertices; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.adj[i][j] !== <span class=\"literal\">undefined</span> &amp;&amp; visited.indexOf(<span class=\"keyword\">this</span>.vertexList[j] === <span class=\"number\">-1</span>)) &#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.vertexList[i]&#125;</span> -&gt; <span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.adj[i][j]&#125;</span>`</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        visited.pop()</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 重置所有顶点为未访问过</span></div><div class=\"line\">  resetMarked() &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.vertices; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.marked[i] = <span class=\"literal\">false</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> lessons = [<span class=\"string\">'CS1'</span>, <span class=\"string\">'CS2'</span>, <span class=\"string\">'Data Structures'</span>,</div><div class=\"line\">                     <span class=\"string\">'Assembly Language'</span>, <span class=\"string\">'Operating Systems'</span>,</div><div class=\"line\">                     <span class=\"string\">'Algorithms'</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> g = <span class=\"keyword\">new</span> Graph(<span class=\"number\">6</span>, lessons)</div><div class=\"line\">g.addEdge(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\">g.addEdge(<span class=\"number\">2</span>, <span class=\"number\">5</span>)</div><div class=\"line\">g.addEdge(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</div><div class=\"line\">g.addEdge(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</div><div class=\"line\">g.addEdge(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'======= showGraph ======='</span>)</div><div class=\"line\">g.showGraph()</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'======= 深度优先 ======='</span>)</div><div class=\"line\">g.dfs()</div><div class=\"line\"><span class=\"comment\">// Visited vertex: 0</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 1</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 2</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 5</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 3</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 4</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'======= 广度优先 ======='</span>)</div><div class=\"line\">g.bfs() </div><div class=\"line\"><span class=\"comment\">// Visited vertex: 0</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 1</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 2</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 3</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 4</span></div><div class=\"line\"><span class=\"comment\">// Visited vertex: 5</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'拓扑排序 ======='</span>)</div><div class=\"line\">g.topSort() </div><div class=\"line\"><span class=\"comment\">// CS1</span></div><div class=\"line\"><span class=\"comment\">// CS2 </span></div><div class=\"line\"><span class=\"comment\">// Operating Systems</span></div><div class=\"line\"><span class=\"comment\">// Assembly Language</span></div><div class=\"line\"><span class=\"comment\">// Data Structures</span></div><div class=\"line\"><span class=\"comment\">// Algorithms </span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'最短路径 ======='</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> path = g.pathTo(<span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(path) <span class=\"comment\">// [0, 1, 4]</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（8） —— 二叉查找树（BST）","url":"http://hysunny.me/2018/01/15/JavaScript-DataStructures-and-Algorithms/BST/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/45952104878a\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/45952104878a</a></p>\n</blockquote>\n<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><blockquote>\n<p>二叉查找树（BST）：一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(data) &#123;</div><div class=\"line\">    <span class=\"comment\">// Node既保存数据也保存和其他节点的链接</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.data = data</div><div class=\"line\">    <span class=\"keyword\">this</span>.left = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.right = <span class=\"literal\">null</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data.toString()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BST</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 向树中加入新节点</span></div><div class=\"line\">  insert(...datalist) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> data <span class=\"keyword\">of</span> datalist) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"keyword\">new</span> Node(data)</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.root === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.root = node</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.root</div><div class=\"line\">        <span class=\"keyword\">let</span> parent</div><div class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">          parent = current</div><div class=\"line\">          <span class=\"keyword\">if</span> (data &lt; current.data) &#123;</div><div class=\"line\">            current = current.left</div><div class=\"line\">            <span class=\"keyword\">if</span> (current === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">              parent.left = node</div><div class=\"line\">              <span class=\"keyword\">break</span></div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            current = current.right</div><div class=\"line\">            <span class=\"keyword\">if</span> (current === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">              parent.right = node</div><div class=\"line\">              <span class=\"keyword\">break</span></div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 前序遍历：根节点 -&gt; 左子树 -&gt; 右子树</span></div><div class=\"line\">  preOrder() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> order = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;node.data&#125;</span> `</span>)</div><div class=\"line\">        order(node.left)</div><div class=\"line\">        order(node.right)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    order(<span class=\"keyword\">this</span>.root)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 中序遍历：左子树 -&gt; 根节点 -&gt; 右子树</span></div><div class=\"line\">  inOrder() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> order = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        order(node.left)</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;node.data&#125;</span> `</span>)</div><div class=\"line\">        order(node.right)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    order(<span class=\"keyword\">this</span>.root)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 后序遍历：左子树 -&gt; 右子树 -&gt; 根节点</span></div><div class=\"line\">  postOrder() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> order = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        order(node.left)</div><div class=\"line\">        order(node.right)</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;node.data&#125;</span> `</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    order(<span class=\"keyword\">this</span>.root)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 找到最小值</span></div><div class=\"line\">  findMin() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.root</div><div class=\"line\">    <span class=\"keyword\">while</span>(current.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      current = current.left</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.data</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 找到最大值</span></div><div class=\"line\">  findMax() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.root</div><div class=\"line\">    <span class=\"keyword\">while</span>(current.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      current = current.right</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> current.data</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 找到指定值</span></div><div class=\"line\">  find(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.root</div><div class=\"line\">    <span class=\"keyword\">while</span>(current !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data === current.data) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; current.data) &#123;</div><div class=\"line\">        current = current.left</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &gt; current.data) &#123;</div><div class=\"line\">        current = current.right</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 找到指定值</span></div><div class=\"line\">  find(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> current = <span class=\"keyword\">this</span>.root</div><div class=\"line\">    <span class=\"keyword\">while</span>(current !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data === current.data) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> current</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; current.data) &#123;</div><div class=\"line\">        current = current.left</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &gt; current.data) &#123;</div><div class=\"line\">        current = current.right</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除指定值</span></div><div class=\"line\">  remove(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> findMin = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> current = node</div><div class=\"line\">      <span class=\"keyword\">while</span>(current.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        current = current.left</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> current</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">const</span> removeNode = <span class=\"function\">(<span class=\"params\">node, data</span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (data === node.data) &#123;</div><div class=\"line\">        <span class=\"comment\">// 没有子节点的节点</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (node.left === <span class=\"literal\">null</span> &amp;&amp;</div><div class=\"line\">            node.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 没有左子节点的节点</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (node.left === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> node.right</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 没有右子节点的节点</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (node.right === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> node.left</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 有两个子节点的节点</span></div><div class=\"line\">        <span class=\"comment\">// 找到右子树上的最小值，并用该值创建一个临时节点</span></div><div class=\"line\">        <span class=\"keyword\">const</span> tempNode = findMin(node.right)</div><div class=\"line\">        <span class=\"comment\">// 将临时节点上的值复制到待删除节点</span></div><div class=\"line\">        node.data = tempNode.data</div><div class=\"line\">        <span class=\"comment\">// 然后再删除临时节点</span></div><div class=\"line\">        node.right = removeNode(node.right, tempNode.data)</div><div class=\"line\">        <span class=\"keyword\">return</span> node</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data &lt; node.data) &#123;</div><div class=\"line\">        <span class=\"comment\">// 移至当前节点的左子节点进行比较</span></div><div class=\"line\">        node.left = removeNode(node.left, data)</div><div class=\"line\">        <span class=\"keyword\">return</span> node</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// 移至当前节点的右子节点进行比较</span></div><div class=\"line\">        node.right = removeNode(node.right, data)</div><div class=\"line\">        <span class=\"keyword\">return</span> node</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.root = removeNode(<span class=\"keyword\">this</span>.root, data)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回BST中节点的个数</span></div><div class=\"line\">  count() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> arr = []</div><div class=\"line\">    <span class=\"keyword\">const</span> order = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        order(node.left, arr)</div><div class=\"line\">        order(node.right, arr)</div><div class=\"line\">        arr.push(node.data)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    order(<span class=\"keyword\">this</span>.root)</div><div class=\"line\">    <span class=\"keyword\">return</span> arr.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回BST中边的个数</span></div><div class=\"line\">  edgesCount() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">const</span> edgesCount = <span class=\"function\"><span class=\"params\">node</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (node.left !== <span class=\"literal\">null</span> &amp;&amp; node.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        count++</div><div class=\"line\">        edgesCount(node.left)</div><div class=\"line\">        count++</div><div class=\"line\">        edgesCount(node.right)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.left !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        count++</div><div class=\"line\">        edgesCount(node.left)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node.right !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">        count++</div><div class=\"line\">        edgesCount(node.right)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    edgesCount(<span class=\"keyword\">this</span>.root)</div><div class=\"line\">    <span class=\"keyword\">return</span> count</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> bst = <span class=\"keyword\">new</span> BST()</div><div class=\"line\">bst.insert(<span class=\"number\">23</span>,<span class=\"number\">16</span>,<span class=\"number\">99</span>,<span class=\"number\">30</span>,<span class=\"number\">18</span>,<span class=\"number\">3</span>,<span class=\"number\">120</span>,<span class=\"number\">45</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.count())\t<span class=\"comment\">// 8</span></div><div class=\"line\">bst.preOrder() <span class=\"comment\">// 23 16 3 18 99 30 45 120</span></div><div class=\"line\">bst.inOrder() <span class=\"comment\">// 3 16 18 23 30 45 99 120</span></div><div class=\"line\">bst.postOrder()\t<span class=\"comment\">// 3 18 16 45 30 120 99 23</span></div><div class=\"line\">bst.remove(<span class=\"number\">99</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.count())\t<span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.findMin())\t<span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.findMax())\t<span class=\"comment\">// 120</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.find(<span class=\"number\">30</span>))\t\t<span class=\"comment\">// Node &#123;data: 30, left: null, right: Node&#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bst.edgesCount())\t<span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（7） —— 集合（Set）","url":"http://hysunny.me/2018/01/10/JavaScript-DataStructures-and-Algorithms/Set/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/5c76b3dc41bb\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/5c76b3dc41bb</a></p>\n</blockquote>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><blockquote>\n<p>一组无序但彼此之间又有一定相关性的成员构成，每个成员在集合中只能出现一次。</p>\n</blockquote>\n<h4 id=\"集合相关的一些基本概念\"><a href=\"#集合相关的一些基本概念\" class=\"headerlink\" title=\"集合相关的一些基本概念\"></a>集合相关的一些基本概念</h4><ol>\n<li>集合的定义：</li>\n</ol>\n<blockquote>\n<p>（1）不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合<br>（2）如果两个集合的成员完全相同，则两个集合相等<br>（3）如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。</p>\n</blockquote>\n<ol>\n<li>集合的操作：</li>\n</ol>\n<blockquote>\n<p>（1）并集（合并）<br>（2）交集（共同存在的）<br>（3）补集（属于一个集合不属于另一个集合的成员组成的集合）</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Set</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get size() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 添加元素，确保元素是唯一的</span></div><div class=\"line\">  add(...eles) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> eles) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.contains(ele)) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.warn(<span class=\"string\">`集合中已存在该元素: <span class=\"subst\">$&#123;ele&#125;</span>`</span>)</div><div class=\"line\">        <span class=\"keyword\">continue</span></div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.elements.push(ele)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除元素</span></div><div class=\"line\">  remove(...eles) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> ele <span class=\"keyword\">of</span> eles) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> pos = <span class=\"keyword\">this</span>.elements.indexOf(ele)</div><div class=\"line\">      <span class=\"keyword\">if</span> (pos &gt; <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.elements.splice(pos, <span class=\"number\">1</span>)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.warn(<span class=\"string\">`集合中不存在元素: <span class=\"subst\">$&#123;ele&#125;</span>， 无法删除`</span>)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 判断集合中是否包含某个元素</span></div><div class=\"line\">  contains(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.includes(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 并集</span></div><div class=\"line\">  union(set) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> tempSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">      tempSet.add(item)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    set.elements.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.contains(item)) &#123;</div><div class=\"line\">        tempSet.add(item)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span> tempSet</div><div class=\"line\">  &#125; </div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 交集</span></div><div class=\"line\">  intersect(set) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> tempSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</div><div class=\"line\">    set.elements.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.contains(item)) &#123;</div><div class=\"line\">        tempSet.add(item)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span> tempSet</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 判断子集，当前集合是不是入参集合的一个子集</span></div><div class=\"line\">  subsetOf(set) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (set.size &lt; <span class=\"keyword\">this</span>.size) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.size; i++) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!set.contains(<span class=\"keyword\">this</span>.elements[i])) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 补集，属于当前集合，而不属于入参集合的元素</span></div><div class=\"line\">  difference(set) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> tempSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!set.contains(item)) &#123;</div><div class=\"line\">        tempSet.add(item)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    <span class=\"keyword\">return</span> tempSet</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回比传入元素大的元素中最小的那个</span></div><div class=\"line\">  higher(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temp = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"keyword\">this</span>.size</div><div class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elements[i] &gt; ele &amp;&amp; </div><div class=\"line\">        (temp !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.elements[i] &lt; temp ||</div><div class=\"line\">          temp === <span class=\"literal\">null</span>)</div><div class=\"line\">        ) &#123;</div><div class=\"line\">        temp = <span class=\"keyword\">this</span>.elements[i]</div><div class=\"line\">      &#125;</div><div class=\"line\">      i--</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> temp</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回比传入元素小的元素中最大的那个</span></div><div class=\"line\">  lower(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temp = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"keyword\">this</span>.size</div><div class=\"line\">    <span class=\"keyword\">while</span>(i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elements[i] &lt; ele &amp;&amp; </div><div class=\"line\">        (temp !== <span class=\"literal\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.elements[i] &gt; temp ||</div><div class=\"line\">        temp === <span class=\"literal\">null</span>)</div><div class=\"line\">        ) &#123;</div><div class=\"line\">        temp = <span class=\"keyword\">this</span>.elements[i]</div><div class=\"line\">      &#125;</div><div class=\"line\">      i--</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> temp </div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 元素的字符串形式显示</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.toString()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</div><div class=\"line\">set.add(<span class=\"number\">49</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>, <span class=\"number\">30</span>, <span class=\"number\">18</span>, <span class=\"number\">256</span>, <span class=\"number\">99</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.toString())\t\t<span class=\"comment\">// 49,100,2,30,18,256,99</span></div><div class=\"line\">set.remove(<span class=\"number\">49</span>, <span class=\"number\">18</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.toString())\t\t<span class=\"comment\">// 100,2,30,256,99</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.size)\t\t\t\t\t<span class=\"comment\">// 5</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</div><div class=\"line\">set1.add(<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">100</span>, <span class=\"number\">30</span>, <span class=\"number\">256</span>)\t</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set1.toString())  <span class=\"comment\">// 5,8,100,30,256</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 并集</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.union(set1).toString())\t<span class=\"comment\">// 100,2,30,256,99,5,8</span></div><div class=\"line\"><span class=\"comment\">// 交集</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.intersect(set1).toString())\t\t<span class=\"comment\">// 100,30,256</span></div><div class=\"line\"><span class=\"comment\">// 子集</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.subsetOf(set1).toString())\t\t<span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"comment\">// 补集</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.difference(set1).toString())\t<span class=\"comment\">// 2,99</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.toString())\t\t<span class=\"comment\">// 100,2,30,256,99</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.higher(<span class=\"number\">99</span>))\t\t<span class=\"comment\">// 100</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(set.lower(<span class=\"number\">99</span>))\t\t<span class=\"comment\">// 30</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（6） —— 散列（Hash）","url":"http://hysunny.me/2018/01/04/JavaScript-DataStructures-and-Algorithms/Hash/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/d5d7fb58bf5f\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/d5d7fb58bf5f</a></p>\n</blockquote>\n<h3 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h3><blockquote>\n<p>散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据结构叫做<code>散列表</code>。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下，比如查找一组数据中的最大值和最小值。</p>\n</blockquote>\n<p>散列表的实现基于数组，键为整型时，一般使用<strong>除留余数法</strong>（以数组的长度对键取值）来实现散列函数，数组的大小一般为<strong>质数</strong>。尽量避免键为字符串或其他类型。</p>\n<p> 散列表中两个键映射成同一个值的情况，叫作碰撞（collision）。</p>\n<p> 碰撞处理的方法：</p>\n<ol>\n<li>开链法（使用多维数组）</li>\n<li>线性检测法（开放寻址散列）<br> 当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。</li>\n</ol>\n<p>如何选择？<br>如果数组的大小是待存储数据的1.5倍，那么使用开链法；如果数组大小是待存储数据的两倍及两倍以上时，那么使用线性探测法。</p>\n<h4 id=\"开链法实现HashTable\"><a href=\"#开链法实现HashTable\" class=\"headerlink\" title=\"开链法实现HashTable\"></a>开链法实现HashTable</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.table = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">137</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 除留余数（简单方法）：当发生碰撞时，后面的值会覆盖之前的值</span></div><div class=\"line\">  simpleHash(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">      total += data.charCodeAt(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total % <span class=\"keyword\">this</span>.table.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 除留余数（霍纳算法）</span></div><div class=\"line\">  <span class=\"comment\">// 数组的长度最好在100以上，这样会让数据在散列表中分布得更加均匀</span></div><div class=\"line\">  <span class=\"comment\">// 为了避免碰撞，在给散列表一个合适的大小后，新的散列函数仍然先计算字符串中各字符的 ASCII 码值，不过求和时每次要乘以一个质数</span></div><div class=\"line\">  betterHash(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> H = <span class=\"number\">37</span></div><div class=\"line\">    <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">      total += H * total + data.charCodeAt(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    total = total % <span class=\"keyword\">this</span>.table.length</div><div class=\"line\">    <span class=\"keyword\">if</span> (total &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      total += <span class=\"keyword\">this</span>.table.length - <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 显示散列表中的数据</span></div><div class=\"line\">  showDistro() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.table(<span class=\"keyword\">this</span>.table)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将数据存入散列表</span></div><div class=\"line\">  put(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> pos = <span class=\"keyword\">this</span>.betterHash(data)</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.table[pos]) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.table[pos].push(data)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.table[pos] = []</div><div class=\"line\">      <span class=\"keyword\">this</span>.table[pos].push(data)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">'David'</span>, <span class=\"string\">'Jennifer'</span>, <span class=\"string\">'Donnie'</span>, <span class=\"string\">'Hysunny'</span>, <span class=\"string\">'Raymond'</span>, <span class=\"string\">'Cynthia'</span>, <span class=\"string\">'Mike'</span>, <span class=\"string\">'Clayton'</span>, <span class=\"string\">'Danny'</span>, <span class=\"string\">'Jonathan'</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> table = <span class=\"keyword\">new</span> HashTable()</div><div class=\"line\">names.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">\ttable.put(item)</div><div class=\"line\">&#125;)</div><div class=\"line\">table.showDistro()</div></pre></td></tr></table></figure>\n<h4 id=\"线性检测法实现HashTable\"><a href=\"#线性检测法实现HashTable\" class=\"headerlink\" title=\"线性检测法实现HashTable\"></a>线性检测法实现HashTable</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashTable</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.table = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">137</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 除留余数（简单方法）：当发生碰撞时，后面的值会覆盖之前的值</span></div><div class=\"line\">  simpleHash(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">      total += data.charCodeAt(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total % <span class=\"keyword\">this</span>.table.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 除留余数（霍纳算法）</span></div><div class=\"line\">  <span class=\"comment\">// 数组的长度最好在100以上，这样会让数据在散列表中分布得更加均匀</span></div><div class=\"line\">  <span class=\"comment\">// 为了避免碰撞，在给散列表一个合适的大小后，新的散列函数仍然先计算字符串中各字符的 ASCII 码值，不过求和时每次要乘以一个质数</span></div><div class=\"line\">  betterHash(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> H = <span class=\"number\">37</span></div><div class=\"line\">    <span class=\"keyword\">let</span> total = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</div><div class=\"line\">      total += H * total + data.charCodeAt(i)</div><div class=\"line\">    &#125;</div><div class=\"line\">    total = total % <span class=\"keyword\">this</span>.table.length</div><div class=\"line\">    <span class=\"keyword\">if</span> (total &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      total += <span class=\"keyword\">this</span>.table.length - <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 显示散列表中的数据</span></div><div class=\"line\">  showDistro() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.table(<span class=\"keyword\">this</span>.table)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将数据存入散列表</span></div><div class=\"line\">  put(data) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> pos = <span class=\"keyword\">this</span>.betterHash(data)</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.table[pos]) &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">this</span>.table[pos] !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">        pos++</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"keyword\">this</span>.table[pos] = data</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> names = [<span class=\"string\">'David'</span>, <span class=\"string\">'Jennifer'</span>, <span class=\"string\">'Donnie'</span>, <span class=\"string\">'Hysunny'</span>, <span class=\"string\">'Raymond'</span>, <span class=\"string\">'Cynthia'</span>, <span class=\"string\">'Mike'</span>, <span class=\"string\">'Clayton'</span>, <span class=\"string\">'Danny'</span>, <span class=\"string\">'Jonathan'</span>]</div><div class=\"line\"><span class=\"keyword\">const</span> table = <span class=\"keyword\">new</span> HashTable()</div><div class=\"line\">names.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">  table.put(item)</div><div class=\"line\">&#125;)</div><div class=\"line\">table.showDistro()</div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（5） —— 字典（Dictionary）","url":"http://hysunny.me/2018/01/03/JavaScript-DataStructures-and-Algorithms/Dictionary/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/b670efe417e8\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/b670efe417e8</a></p>\n</blockquote>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><blockquote>\n<p>一种以key-value形式存储数据的数据结构。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dictionary</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 字典中元素个数</span></div><div class=\"line\">  get length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.elements).length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找元素</span></div><div class=\"line\">  find(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[key]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 添加元素</span></div><div class=\"line\">  add(key, val) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements[key] = val</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 移除元素</span></div><div class=\"line\">  remove(key) &#123;</div><div class=\"line\">    <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.elements[key]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 清空字典</span></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 展示字典中的所有键值对</span></div><div class=\"line\">  display() &#123;</div><div class=\"line\">    <span class=\"comment\">// 按字典顺序显示所有元素</span></div><div class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.elements).sort()) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(key + <span class=\"string\">' -&gt; '</span> + <span class=\"keyword\">this</span>.elements[key])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>示例：按字母顺序显示来一段文本中各个单词出现的次数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wordCount</span>(<span class=\"params\">s</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> words = s.split(<span class=\"string\">' '</span>)</div><div class=\"line\">  <span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> Dictionary()</div><div class=\"line\">  words.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (d.find(item)) &#123;</div><div class=\"line\">        d.add(item, d.find(item) + <span class=\"number\">1</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        d.add(item, <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  d.display()</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\">wordCount(<span class=\"string\">'the brown fox jumped over the blue fox'</span>) <span class=\"comment\">// blue -&gt; 1 brown -&gt; 1 fox -&gt; 2 jumped -&gt; 1 over -&gt; 1 the -&gt; 2</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（4） —— 链表（LinkedList ）","url":"http://hysunny.me/2018/01/03/JavaScript-DataStructures-and-Algorithms/LinkedList/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/1c4b88f847e5\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/1c4b88f847e5</a></p>\n</blockquote>\n<h3 id=\"单向链表\"><a href=\"#单向链表\" class=\"headerlink\" title=\"单向链表\"></a>单向链表</h3><blockquote>\n<p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一 个节点的引用叫做链。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.val = val   \t<span class=\"comment\">// 节点数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span> \t\t<span class=\"comment\">// 指向下一个节点的链接</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> Node(<span class=\"string\">'head'</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>\t\t\t<span class=\"comment\">// 链表的长度，默认为0，不算头节点</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 遍历链表，查找指定索引节点</span></div><div class=\"line\">  find(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找指定节点的索引</span></div><div class=\"line\">  findIndex(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> index</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在任意位置插入节点</span></div><div class=\"line\">  insert(position, val) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"comment\">// 找到插入点的节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    newNode.next = curNode.next</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在链表最后插入一个新元素</span></div><div class=\"line\">  append(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除指定位置的节点</span></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> prevNode = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt;= position) &#123;</div><div class=\"line\">      prevNode = curNode</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    prevNode.next = curNode.next</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode.val</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除节点</span></div><div class=\"line\">  remove(val) &#123;</div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点前面的节点，然后修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点</span></div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.findIndex(val)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.removeAt(index)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"string\">''</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      str += curNode.next.val + <span class=\"string\">', '</span></div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.slice(<span class=\"number\">0</span>, <span class=\"number\">-2</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> cities = <span class=\"keyword\">new</span> LinkedList()</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'BeiJing'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">1</span>, <span class=\"string\">'ShangHai'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'ChongQing'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cities.toString())\t\t<span class=\"comment\">// ChongQing, BeiJing, ShangHai</span></div><div class=\"line\">cities.remove(<span class=\"string\">'BeiJing'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cities.toString())\t\t<span class=\"comment\">// ChongQing, ShangHai</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cities.length)\t\t\t\t<span class=\"comment\">// 2</span></div><div class=\"line\">cities.removeAt(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cities.toString())\t\t<span class=\"comment\">// ChongQing</span></div><div class=\"line\">cities.append(<span class=\"string\">'GuangZhou'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cities.toString())\t\t<span class=\"comment\">// ChongQing, GuangZhou</span></div></pre></td></tr></table></figure>\n<h3 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h3><blockquote>\n<p>与普通列表类似，只是多了一个指向前驱节点的链接。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.val = val   \t<span class=\"comment\">// 节点数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span> \t\t<span class=\"comment\">// 指向下一个节点的链接</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.prev = <span class=\"literal\">null</span>\t<span class=\"comment\">// 指向前一个节点</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DbLinkedList</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> Node(<span class=\"string\">'head'</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>\t\t\t<span class=\"comment\">// 链表的长度，默认为0，不算头节点</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 遍历链表，查找指定索引节点</span></div><div class=\"line\">  find(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找最后的节点</span></div><div class=\"line\">  findLast() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找指定节点的索引</span></div><div class=\"line\">  findIndex(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> index</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在任意位置插入节点</span></div><div class=\"line\">  insert(position, val) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"comment\">// 找到插入点的节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    newNode.next = curNode.next</div><div class=\"line\">    newNode.prev = curNode</div><div class=\"line\">    <span class=\"keyword\">if</span> (curNode.next &amp;&amp; curNode.next.prev) &#123;</div><div class=\"line\">      curNode.next.prev = newNode</div><div class=\"line\">    &#125;</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在链表最后插入一个新元素</span></div><div class=\"line\">  append(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    newNode.prev = curNode</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除指定位置的节点</span></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> prevNode = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt;= position) &#123;</div><div class=\"line\">      prevNode = curNode</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    prevNode.next = curNode.next</div><div class=\"line\">    curNode.next.prev = prevNode</div><div class=\"line\">    curNode.prev = <span class=\"literal\">null</span></div><div class=\"line\">    curNode.next = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.length--</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode.val</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除节点</span></div><div class=\"line\">  remove(val) &#123;</div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点前面的节点，然后修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点</span></div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.findIndex(val)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.removeAt(index)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"string\">''</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      str += curNode.next.val + <span class=\"string\">', '</span></div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.slice(<span class=\"number\">0</span>, <span class=\"number\">-2</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  display() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.toString())</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  displayReverse() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">this</span>.toString().split(<span class=\"string\">', '</span>).reverse().join(<span class=\"string\">', '</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在链表中向前移动 n 个节点</span></div><div class=\"line\">  advance(n) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">this</span>.current.next !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.current.next</div><div class=\"line\">      n--</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在双向链表中后退 n 个节点</span></div><div class=\"line\">  back(n) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span> &amp;&amp; <span class=\"keyword\">this</span>.current.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.current.prev</div><div class=\"line\">      n--</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 只显示当前节点</span></div><div class=\"line\">  show() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.current)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> cities = <span class=\"keyword\">new</span> DbLinkedList()</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'BeiJing'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">1</span>, <span class=\"string\">'ShangHai'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'ChongQing'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'GuangZhou'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'TianJin'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'Taiwan'</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, BeiJing, ShangHai, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.remove(<span class=\"string\">'BeiJing'</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, ShangHai, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.removeAt(<span class=\"number\">1</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.displayReverse()\t\t\t\t<span class=\"comment\">// Taiwan, TianJin, GuangZhou, ChongQing</span></div><div class=\"line\">cities.show()</div><div class=\"line\">cities.advance(<span class=\"number\">2</span>)</div><div class=\"line\">cities.show()\t\t\t\t\t\t\t\t\t<span class=\"comment\">// Node &#123;val: \"GuangZhou\", next: Node, prev: Node&#125;</span></div><div class=\"line\">cities.back(<span class=\"number\">1</span>)</div><div class=\"line\">cities.show()\t\t\t\t\t\t\t\t\t<span class=\"comment\">// Node &#123;val: \"ChongQing\", next: Node, prev: Node&#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h3><blockquote>\n<p>循环链表和单向链表相似，节点类型都是一样的。唯一的区别是，在创建循环链表时，让其头节点的 next 属性指向它本身，即: <code>head.next = head</code></p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.val = val   \t<span class=\"comment\">// 节点数据</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span> \t\t<span class=\"comment\">// 指向下一个节点的链接</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircularLinkedList</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> Node(<span class=\"string\">'head'</span>)</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span>\t\t\t<span class=\"comment\">// 链表的长度，默认为0，不算头节点</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.head</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 遍历链表，查找指定索引节点</span></div><div class=\"line\">  find(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val &amp;&amp; curNode.next.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找指定节点的索引</span></div><div class=\"line\">  findIndex(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.val !== val &amp;&amp; curNode.next.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (index == <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"number\">-1</span></div><div class=\"line\">    <span class=\"keyword\">return</span> index</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 查找最后的节点</span></div><div class=\"line\">  findLast() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span> &amp;&amp; curNode.next.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在任意位置插入节点</span></div><div class=\"line\">  insert(position, val) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"comment\">// 找到插入点的节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt; position) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    newNode.next = curNode.next</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    <span class=\"comment\">// 链表的尾节点指向头节点</span></div><div class=\"line\">    <span class=\"keyword\">const</span> lastNode = <span class=\"keyword\">this</span>.findLast()</div><div class=\"line\">    lastNode.next = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在链表最后插入一个新元素</span></div><div class=\"line\">  append(val) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> newNode = <span class=\"keyword\">new</span> Node(val)</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span> &amp;&amp; curNode.next.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    curNode.next = newNode</div><div class=\"line\">    <span class=\"comment\">// 链表的尾节点指向头节点</span></div><div class=\"line\">    newNode.next = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">this</span>.length++</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除指定位置的节点</span></div><div class=\"line\">  removeAt(position) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">0</span> || position &gt; <span class=\"keyword\">this</span>.length) <span class=\"keyword\">return</span> <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> prevNode = <span class=\"literal\">null</span></div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(index &lt;= position) &#123;</div><div class=\"line\">      prevNode = curNode</div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">      index++</div><div class=\"line\">    &#125;</div><div class=\"line\">    prevNode.next = curNode.next</div><div class=\"line\">    <span class=\"keyword\">this</span>.length--</div><div class=\"line\">    <span class=\"keyword\">return</span> curNode.val</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 删除节点</span></div><div class=\"line\">  remove(val) &#123;</div><div class=\"line\">    <span class=\"comment\">// 找到待删除节点前面的节点，然后修改它的next属性，使其不再指向待删除节点，而是指向待删除节点的下一个节点</span></div><div class=\"line\">    <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.findIndex(val)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.removeAt(index)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在链表中向前移动 n 个节点</span></div><div class=\"line\">  advance(n) &#123;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.current.next</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.current.val === <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.current = <span class=\"keyword\">this</span>.current.next</div><div class=\"line\">        &#125;</div><div class=\"line\">        n--</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 只显示当前节点</span></div><div class=\"line\">  show() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.current)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  display() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.toString())</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  displayReverse() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">this</span>.toString().split(<span class=\"string\">', '</span>).reverse().join(<span class=\"string\">', '</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> curNode = <span class=\"keyword\">this</span>.head</div><div class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"string\">''</span></div><div class=\"line\">    <span class=\"keyword\">while</span>(curNode.next !== <span class=\"literal\">null</span> &amp;&amp; curNode.next.val !== <span class=\"string\">'head'</span>) &#123;</div><div class=\"line\">      str += curNode.next.val + <span class=\"string\">', '</span></div><div class=\"line\">      curNode = curNode.next</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.slice(<span class=\"number\">0</span>, <span class=\"number\">-2</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> cities = <span class=\"keyword\">new</span> CircularLinkedList()</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'BeiJing'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">1</span>, <span class=\"string\">'ShangHai'</span>)</div><div class=\"line\">cities.insert(<span class=\"number\">0</span>, <span class=\"string\">'ChongQing'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'GuangZhou'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'TianJin'</span>)</div><div class=\"line\">cities.append(<span class=\"string\">'Taiwan'</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, BeiJing, ShangHai, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.remove(<span class=\"string\">'BeiJing'</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, ShangHai, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.removeAt(<span class=\"number\">1</span>)</div><div class=\"line\">cities.display()\t\t\t\t\t\t\t<span class=\"comment\">// ChongQing, GuangZhou, TianJin, Taiwan</span></div><div class=\"line\">cities.displayReverse()\t\t\t\t<span class=\"comment\">// Taiwan, TianJin, GuangZhou, ChongQing</span></div><div class=\"line\">cities.advance(<span class=\"number\">2</span>)</div><div class=\"line\">cities.show()\t\t\t\t\t\t\t\t\t<span class=\"comment\">// Node &#123;val: \"GuangZhou\", next: Node&#125;</span></div></pre></td></tr></table></figure>\n<p>示例：约瑟夫环问题</p>\n<blockquote>\n<p>传说在公元 1 世纪的犹太战争中，犹太历史学家弗拉维奥·约瑟夫斯和他的 40 个同胞 被罗马士兵包围。犹太士兵决定宁可自杀也不做俘虏，于是商量出了一个自杀方案。他 们围成一个圈，从一个人开始，数到第三个人时将第三个人杀死，然后再数，直到杀光 所有人。约瑟夫和另外一个人决定不参加这个疯狂的游戏，他们快速地计算出了两个位 置，站在那里得以幸存。写一段程序将 n 个人围成一圈，并且第 m 个人会被杀掉，计算 一圈人中哪两个人最后会存活。使用循环链表解决该问题。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123; Number &#125; n \t// 总人数</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123; Number &#125; m\t// 间隔人数</span></div><div class=\"line\"><span class=\"comment\"> * @return &#123; String &#125;</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">game</span>(<span class=\"params\">n, m</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> links = <span class=\"keyword\">new</span> CircularLinkedList()</div><div class=\"line\">  links.insert(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</div><div class=\"line\">  <span class=\"keyword\">var</span> sign = <span class=\"number\">2</span></div><div class=\"line\">  <span class=\"comment\">// 生成循环链表</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(sign &lt;= n) &#123;</div><div class=\"line\">      links.insert(sign - <span class=\"number\">1</span>, sign)</div><div class=\"line\">      sign++</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">// 循环遍历，直到剩余的人数少于间隔数</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(n &gt;= m) &#123;</div><div class=\"line\">      links.advance(m)</div><div class=\"line\">      links.remove(links.current.val)</div><div class=\"line\">      n--</div><div class=\"line\">  &#125;</div><div class=\"line\">  links.display()</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\">game(<span class=\"number\">40</span>, <span class=\"number\">3</span>)        <span class=\"comment\">// 13, 28</span></div></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（3） —— 队列（Queue）","url":"http://hysunny.me/2018/01/01/JavaScript-DataStructures-and-Algorithms/Queue/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/6785a6a1c30a\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/6785a6a1c30a</a></p>\n</blockquote>\n<h3 id=\"顺序队列\"><a href=\"#顺序队列\" class=\"headerlink\" title=\"顺序队列\"></a>顺序队列</h3><blockquote>\n<p>一种遵循<strong>先进先出</strong>的(FIFO，first-in-first-out)的有序列表。队列只能在<strong>队尾</strong>插入元素（<code>入队</code>），在队首删除元素（<code>出队</code>）。</p>\n</blockquote>\n<p>应用：舞伴问题、基数排序等</p>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Queue</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 入队</span></div><div class=\"line\">  enqueue(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.push(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 出队</span></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.shift()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队首元素</span></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"number\">0</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队尾元素</span></div><div class=\"line\">  back() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.toString()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>示例：基数排序</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123; Array &#125; arr</span></div><div class=\"line\"><span class=\"comment\"> * @param &#123; Number &#125; maxDigit\t// 数组中最大数的位数</span></div><div class=\"line\"><span class=\"comment\"> * @return &#123; Array &#125;</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">radixSort</span>(<span class=\"params\">arr, maxDigit</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> mod = <span class=\"number\">10</span>\t</div><div class=\"line\">  <span class=\"keyword\">let</span> base = <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"comment\">// init queue</span></div><div class=\"line\">  <span class=\"keyword\">const</span> queues = []</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">    queues.push(<span class=\"keyword\">new</span> Queue())</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, base *= <span class=\"number\">10</span>, mod *= <span class=\"number\">10</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// distribute —— 分配数字到相应队列</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; arr.length; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"built_in\">Math</span>.floor((arr[j] % mod) / base)</div><div class=\"line\">      queues[index].enqueue(arr[j])</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// collect —— 从队列中收集数字</span></div><div class=\"line\">    <span class=\"keyword\">let</span> k = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</div><div class=\"line\">      <span class=\"keyword\">while</span>(!queues[j].isEmpty) &#123;</div><div class=\"line\">        arr[k++] = queues[j].dequeue()</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> arr</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">324</span>, <span class=\"number\">100</span>]</div><div class=\"line\">radixSort(arr, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr)</div></pre></td></tr></table></figure>\n<h3 id=\"优先队列\"><a href=\"#优先队列\" class=\"headerlink\" title=\"优先队列\"></a>优先队列</h3><blockquote>\n<p>元素的添加和删除基于优先级。如急诊室中会根据患者病情的严重程度放号。</p>\n</blockquote>\n<p>实现：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 入队</span></div><div class=\"line\">  enqueue(ele, priority) &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> queueEle = &#123; ele, priority &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isEmpty) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.elements.push(queueEle)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> preIndex = <span class=\"keyword\">this</span>.elements.findIndex(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> queueEle.priority &lt; item.priority)</div><div class=\"line\">      <span class=\"keyword\">if</span> (preIndex &gt; <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.elements.splice(preIndex, <span class=\"number\">0</span>, queueEle)</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.elements.push(queueEle)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 出队</span></div><div class=\"line\">  dequeue() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.shift()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队首元素</span></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"number\">0</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队尾元素</span></div><div class=\"line\">  back() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.table(<span class=\"keyword\">this</span>.elements)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>示例：急诊室排号</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> patient = <span class=\"keyword\">new</span> PriorityQueue()</div><div class=\"line\">patient.enqueue(<span class=\"string\">'Clayton'</span>, <span class=\"number\">3</span>)</div><div class=\"line\">patient.enqueue(<span class=\"string\">'Raymond'</span>, <span class=\"number\">2</span>)</div><div class=\"line\">patient.enqueue(<span class=\"string\">'Cynthia'</span>, <span class=\"number\">3</span>)</div><div class=\"line\">patient.enqueue(<span class=\"string\">'Jennifer'</span>, <span class=\"number\">1</span>)</div><div class=\"line\">patient.enqueue(<span class=\"string\">'Danny'</span>, <span class=\"number\">4</span>)</div><div class=\"line\">&nbsp</div><div class=\"line\">patient.toString()</div></pre></td></tr></table></figure>\n<h3 id=\"双向队列\"><a href=\"#双向队列\" class=\"headerlink\" title=\"双向队列\"></a>双向队列</h3><blockquote>\n<p>和队列类似的数据结构，允许从队列<strong>两端</strong>添加和删除元素。</p>\n</blockquote>\n<p>实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Deque</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  get isEmpty() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 队首入队</span></div><div class=\"line\">  enqueueFront(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.unshift(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 队尾出队</span></div><div class=\"line\">  dequeueBack() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.pop()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 队尾入队</span></div><div class=\"line\">  enqueueBack(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.push(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 队首出队</span></div><div class=\"line\">  dequeueFront() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.shift()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队首元素</span></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"number\">0</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取队尾元素</span></div><div class=\"line\">  back() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.toString()</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>示例：回文检测</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPalindrome</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> dqueue = <span class=\"keyword\">new</span> Deque()</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; str.length; i++) &#123;</div><div class=\"line\">    dqueue.enqueueBack(str[i])</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">while</span>(!dqueue.isEmpty) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dqueue.front() !== dqueue.back()) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      dqueue.dequeueFront()</div><div class=\"line\">      dqueue.dequeueBack()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> str1 = isPalindrome(<span class=\"string\">'hello'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str1)\t\t<span class=\"comment\">// false</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> str2 = isPalindrome(<span class=\"string\">'racecar'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2)\t\t<span class=\"comment\">// true</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（2） —— 栈（Stack）","url":"http://hysunny.me/2018/01/01/JavaScript-DataStructures-and-Algorithms/Stack/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/791af5e3a74a\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/791af5e3a74a</a></p>\n</blockquote>\n<h3 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h3><blockquote>\n<p>一种遵循<strong>后进先出</strong>(LIFO，last-in-first-out)的有序列表。仅允许在表的一端进行插入和删除操作，这一端称为<code>栈顶</code>，把另一端称为<code>栈底</code>。</p>\n<p>向一个栈中插入新元素叫作<code>入栈</code>，它将新元素放在栈顶。从一个栈中删除一个元素叫作<code>出栈</code>，它是把栈顶元素删除掉，使其相邻的元素称为新的栈顶元素。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-f38cb48a029b79eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"栈的模型\"></p>\n<p>应用：进制转换、实现回文、递归演示等</p>\n<p>实现：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 入栈</span></div><div class=\"line\">  push(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.push(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 出栈</span></div><div class=\"line\">  pop() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.pop()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回栈顶元素</span></div><div class=\"line\">  peek() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">get</span> length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 清空栈内元素</span></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>示例1：进制转换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mulBase</span>(<span class=\"params\">num, base</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> Stack()</div><div class=\"line\">  <span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    s.push(num % base)</div><div class=\"line\">    num = <span class=\"built_in\">Math</span>.floor(num /= base)</div><div class=\"line\">  &#125; <span class=\"keyword\">while</span> (num &gt; <span class=\"number\">0</span>)</div><div class=\"line\">  <span class=\"keyword\">let</span> converted = <span class=\"string\">''</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(s.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      converted += s.pop()</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> converted</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> num1 = mulBase(<span class=\"number\">32</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(num1)\t\t\t<span class=\"comment\">// 100000</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> num2 = mulBase(<span class=\"number\">125</span>, <span class=\"number\">8</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(num2)\t\t\t<span class=\"comment\">// 175</span></div></pre></td></tr></table></figure>\n<p>示例2：判断回文</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPalindrome</span>(<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> s = <span class=\"keyword\">new</span> Stack()</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; word.length; i++) &#123;</div><div class=\"line\">    s.push(word[i])</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">let</span> rWord = <span class=\"string\">''</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(s.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    rWord += s.pop()</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (word === rWord) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> str1 = isPalindrome(<span class=\"string\">'hello'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str1)\t\t<span class=\"comment\">// false</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> str2 = isPalindrome(<span class=\"string\">'racecar'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2)\t\t<span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>示例3： 递归演示 —— 阶乘函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// test</span></div><div class=\"line\"><span class=\"keyword\">const</span> num = factorial(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(num)\t\t<span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"数据结构与算法JavaScript描述（1） —— 列表（List ）","url":"http://hysunny.me/2017/12/30/JavaScript-DataStructures-and-Algorithms/List/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/e7d1ec7b2999\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/e7d1ec7b2999</a></p>\n</blockquote>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><blockquote>\n<p>一组有序的数据集合，集合中的每个数据项叫做元素，可对这些数据项进行增删改查操作。 </p>\n</blockquote>\n<p>应用：存储数据，进行数据的简单查找和排序</p>\n<p>实现：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">List</span> </span>&#123;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">    <span class=\"keyword\">this</span>.pos = <span class=\"number\">0</span>\t\t\t<span class=\"comment\">// 列表的当前位置</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回列表中元素的个数</span></div><div class=\"line\">  get length() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.length</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 清空列表中的所有元素</span></div><div class=\"line\">  clear() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在列表中查找某一元素</span></div><div class=\"line\">  find(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.indexOf(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回列表的字符串形式</span></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements.toString()</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 在现有元素后插入新元素</span></div><div class=\"line\">  insert(after, ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.find(after) &gt; <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">const</span> index = <span class=\"keyword\">this</span>.find(after) + <span class=\"number\">1</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.elements.splice(index, <span class=\"number\">0</span>, ele)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 给列表添加元素</span></div><div class=\"line\">  append(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.elements.push(ele)</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 从列表中删除元素</span></div><div class=\"line\">  remove(ele) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.find(ele) &gt; <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.elements.splice(<span class=\"keyword\">this</span>.find(ele), <span class=\"number\">1</span>)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回列表的当前位置</span></div><div class=\"line\">  currPos() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.pos</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 返回当前位置的元素</span></div><div class=\"line\">  getElement() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.pos]</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将列表的当前位置设移动到第一个元素</span></div><div class=\"line\">  front() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.pos = <span class=\"number\">0</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将列表的当前位置移动到最后一个元素</span></div><div class=\"line\">  end() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.pos = <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将当前位置前移一位</span></div><div class=\"line\">  prev() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.pos &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.pos--</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getElement()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将当前位置后移一位</span></div><div class=\"line\">  next() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.pos &lt; <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.pos++</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getElement()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将当前位置移动到指定位置</span></div><div class=\"line\">  moveTo(pos) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pos &gt;= <span class=\"number\">0</span> &amp;&amp; pos &lt; <span class=\"keyword\">this</span>.length) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.pos = pos</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getElement()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 实现一个迭代器（Iterator），可以使用for...of...循环</span></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">   * next(): 返回 &#123; value: all_type, done: Boolean &#125;</span></div><div class=\"line\"><span class=\"comment\">   * value: 列表中的某个值</span></div><div class=\"line\"><span class=\"comment\">   * done: 标明迭代是否结束</span></div><div class=\"line\"><span class=\"comment\">   */</span></div><div class=\"line\">  [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.pos = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      next: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.pos++</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.pos &gt; <span class=\"keyword\">this</span>.length) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            value: <span class=\"literal\">null</span>,</div><div class=\"line\">            done: <span class=\"literal\">true</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            value: <span class=\"keyword\">this</span>.elements[<span class=\"keyword\">this</span>.pos - <span class=\"number\">1</span>],</div><div class=\"line\">            done: <span class=\"literal\">false</span></div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// test </span></div><div class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"keyword\">new</span> List()</div><div class=\"line\">names.append(<span class=\"string\">'Clayton'</span>)</div><div class=\"line\">names.append(<span class=\"string\">'Raymond'</span>)</div><div class=\"line\">names.append(<span class=\"string\">'Cynthia'</span>)</div><div class=\"line\">names.append(<span class=\"string\">'Jennifer'</span>)</div><div class=\"line\">names.append(<span class=\"string\">'Bryan'</span>)</div><div class=\"line\">names.append(<span class=\"string\">'Danny'</span>)</div><div class=\"line\">names.insert(<span class=\"string\">'Cynthia'</span>, <span class=\"string\">'Hysunny'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.toString())\t\t\t<span class=\"comment\">// Clayton,Raymond,Cynthia,Hysunny,Jennifer,Bryan,Danny</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.currPos())\t\t\t<span class=\"comment\">// 0</span></div><div class=\"line\">names.front()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.getElement()) \t<span class=\"comment\">// Clayton</span></div><div class=\"line\">names.next()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.getElement()) \t<span class=\"comment\">// Raymond</span></div><div class=\"line\">names.moveTo(<span class=\"number\">4</span>)\t\t\t\t\t\t\t\t\t\t</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.getElement())\t\t<span class=\"comment\">// Bryan</span></div><div class=\"line\">&nbsp</div><div class=\"line\">names.remove(<span class=\"string\">'Bryan'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.toString())\t\t\t<span class=\"comment\">// Clayton,Raymond,Cynthia,Hysunny,Jennifer,Danny</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 使用迭代器</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> name <span class=\"keyword\">of</span> names) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(name)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Clayton,Raymond,Cynthia,Hysunny,Jennifer,Danny</span></div><div class=\"line\">&nbsp</div><div class=\"line\">names.clear()</div><div class=\"line\"><span class=\"built_in\">console</span>.log(names.length)\t\t\t\t\t<span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["Algorithm"]},{"title":"Vue实现StickyTop效果","url":"http://hysunny.me/2017/12/10/Vue/vue-stickyTop-effects/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/07330174e51d\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/07330174e51d</a></p>\n</blockquote>\n<p>最近的wap项目开发中有这么一个需求：</p>\n<h4 id=\"1-初始情况下页面布局如下图所示：\"><a href=\"#1-初始情况下页面布局如下图所示：\" class=\"headerlink\" title=\"1. 初始情况下页面布局如下图所示：\"></a>1. 初始情况下页面布局如下图所示：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-7d16c7762376b24e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"2-当页面滚动距离大于header时，switch-bar将固定在顶部\"><a href=\"#2-当页面滚动距离大于header时，switch-bar将固定在顶部\" class=\"headerlink\" title=\"2. 当页面滚动距离大于header时，switch-bar将固定在顶部\"></a>2. 当页面滚动距离大于<code>header</code>时，<code>switch-bar</code>将固定在顶部</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-4f3cf6930482c742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h4 id=\"3-3个列表可以来回切换\"><a href=\"#3-3个列表可以来回切换\" class=\"headerlink\" title=\"3. 3个列表可以来回切换\"></a>3. 3个列表可以来回切换</h4><h4 id=\"4-切换列表时保持switch-bar状态，即当switch-bar固定在顶部时，切换列表后switch-bar仍然固定在顶部，当switch-bar不固定在顶部时，切换列表后页面回跳到顶部。\"><a href=\"#4-切换列表时保持switch-bar状态，即当switch-bar固定在顶部时，切换列表后switch-bar仍然固定在顶部，当switch-bar不固定在顶部时，切换列表后页面回跳到顶部。\" class=\"headerlink\" title=\"4. 切换列表时保持switch-bar状态，即当switch-bar固定在顶部时，切换列表后switch-bar仍然固定在顶部，当switch-bar不固定在顶部时，切换列表后页面回跳到顶部。\"></a>4. 切换列表时保持<code>switch-bar</code>状态，即当<code>switch-bar</code>固定在顶部时，切换列表后<code>switch-bar</code>仍然固定在顶部，当<code>switch-bar</code>不固定在顶部时，切换列表后页面回跳到顶部。</h4><h4 id=\"5-3个列表数据均为异步获取\"><a href=\"#5-3个列表数据均为异步获取\" class=\"headerlink\" title=\"5. 3个列表数据均为异步获取\"></a>5. 3个列表数据均为异步获取</h4><p>最后的实现效果（简单示例）如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-8f8afb6b3d63b613.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>下面我们来看下如果实现这个<code>stickyTop</code>效果。</p>\n<p>首先说一下这个示例使用的技术栈：<code>Vue</code> + <code>Vue-router</code> + <code>lodash</code> + <code>axios</code></p>\n<p>   (1) 使用<code>Vue-router</code>: 实现嵌套路由<br>   (2) 使用<code>lodash</code>的<code>throttle</code>: 节流监听滚动事件，降低性能消耗<br>   (3) 使用<code>axios</code>: 发起异步请求</p>\n<p>实现思路：</p>\n<h4 id=\"1-页面使用流式布局，整个页面可分为4个组件（Home-Products-Orders-Docs\"><a href=\"#1-页面使用流式布局，整个页面可分为4个组件（Home-Products-Orders-Docs\" class=\"headerlink\" title=\"1. 页面使用流式布局，整个页面可分为4个组件（Home, Products, Orders, Docs\"></a>1. 页面使用流式布局，整个页面可分为4个组件（Home, Products, Orders, Docs</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Home = &#123;</div><div class=\"line\">  template: <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">    &lt;div class=\"home\"&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;header class=\"header\"&gt;header&lt;/header&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;div class=\"switch-bar\"&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;router-link to=\"/products\"&gt;产品&lt;/router-link&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;router-link to=\"/orders\"&gt;订单&lt;/router-link&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;router-link to=\"/docs\"&gt;文档&lt;/router-link&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;div class=\"content\"&gt;</span></div><div class=\"line\"><span class=\"string\">        &lt;router-view&gt;&lt;/router-view&gt;</span></div><div class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;/div&gt;`</span></div><div class=\"line\">&#125;  </div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> Products = &#123;</div><div class=\"line\">  template: </div><div class=\"line\">  <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">  &lt;ul class=\"list products\"&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;li v-for=\"item in list\" :key=\"item.id\"&gt;</span></div><div class=\"line\"><span class=\"string\">      &#123;&#123; item.name &#125;&#125;</span></div><div class=\"line\"><span class=\"string\">    &lt;/li&gt;</span></div><div class=\"line\"><span class=\"string\">  &lt;/ul&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> Orders = &#123;</div><div class=\"line\">  template: </div><div class=\"line\">  <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">  &lt;ul class=\"list products\"&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;li v-for=\"item in list\" :key=\"item.id\"&gt;</span></div><div class=\"line\"><span class=\"string\">      &#123;&#123; item.name &#125;&#125;</span></div><div class=\"line\"><span class=\"string\">    &lt;/li&gt;</span></div><div class=\"line\"><span class=\"string\">  &lt;/ul&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">const</span> Docs = &#123;</div><div class=\"line\">  template: </div><div class=\"line\">  <span class=\"string\">`</span></div><div class=\"line\"><span class=\"string\">  &lt;ul class=\"list products\"&gt;</span></div><div class=\"line\"><span class=\"string\">    &lt;li v-for=\"item in list\" :key=\"item.id\"&gt;</span></div><div class=\"line\"><span class=\"string\">      &#123;&#123; item.name &#125;&#125;</span></div><div class=\"line\"><span class=\"string\">    &lt;/li&gt;</span></div><div class=\"line\"><span class=\"string\">  &lt;/ul&gt;</span></div><div class=\"line\"><span class=\"string\">  `</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-使用嵌套路由\"><a href=\"#2-使用嵌套路由\" class=\"headerlink\" title=\"2. 使用嵌套路由\"></a>2. 使用嵌套路由</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> routes = [&#123;</div><div class=\"line\">  path: <span class=\"string\">'/'</span>,</div><div class=\"line\">  component: Home,</div><div class=\"line\">  children: [&#123;</div><div class=\"line\">    path: <span class=\"string\">''</span>,</div><div class=\"line\">    component: Products</div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    path: <span class=\"string\">'products'</span>,</div><div class=\"line\">    component: Products</div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    path: <span class=\"string\">'orders'</span>,</div><div class=\"line\">    component: Orders</div><div class=\"line\">  &#125;, &#123;</div><div class=\"line\">    path: <span class=\"string\">'docs'</span>,</div><div class=\"line\">    component: Docs</div><div class=\"line\">  &#125;]</div><div class=\"line\">&#125;]</div></pre></td></tr></table></figure>\n<h4 id=\"3-节流监听window滚动事件，当页面滚动高度-gt-header高度时，设置switch-bar的position属性为fixd，反之取消-实际通过一个变量isFix来控制样式-。\"><a href=\"#3-节流监听window滚动事件，当页面滚动高度-gt-header高度时，设置switch-bar的position属性为fixd，反之取消-实际通过一个变量isFix来控制样式-。\" class=\"headerlink\" title=\"3. 节流监听window滚动事件，当页面滚动高度 &gt;= header高度时，设置switch-bar的position属性为fixd，反之取消(实际通过一个变量isFix来控制样式)。\"></a>3. 节流监听<code>window</code>滚动事件，当<strong>页面滚动高度 &gt;= header</strong>高度时，设置<code>switch-bar</code>的<code>position</code>属性为<code>fixd</code>，反之取消(实际通过一个变量<code>isFix</code>来控制样式)。</h4><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"css\"><span class=\"selector-class\">.home</span><span class=\"selector-class\">.fix</span> <span class=\"selector-class\">.switch-bar</span> &#123;</span></div><div class=\"line\"><span class=\"undefined\">  position: fixed;</span></div><div class=\"line\"><span class=\"undefined\">  left: 0;</span></div><div class=\"line\"><span class=\"undefined\">  top: 0;</span></div><div class=\"line\"><span class=\"undefined\">  z-index: 10;</span></div><div class=\"line\"><span class=\"undefined\">&#125;</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"home\"</span> <span class=\"attr\">:class</span>=<span class=\"string\">\"&#123;'fix': isFix&#125;\"</span>&gt;</span></div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"switch-bar\"</span>&gt;</span></div><div class=\"line\">    ...</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  ...</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"actionscript\"><span class=\"comment\">// 判断是否吸顶效果</span></span></div><div class=\"line\"><span class=\"actionscript\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.scrollTop &gt;= <span class=\"keyword\">this</span>.headerHeight) &#123;</span></div><div class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">this</span>.isFix = <span class=\"literal\">true</span></span></div><div class=\"line\"><span class=\"actionscript\">&#125; <span class=\"keyword\">else</span> &#123;</span></div><div class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">this</span>.isFix = <span class=\"literal\">false</span></span></div><div class=\"line\"><span class=\"undefined\">&#125;</span></div><div class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>做完以上3点其实大部分工作就完成了，这时的运行效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3779867-00679a723225e979.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>有两个问题：</p>\n<ol>\n<li>切换列表时并没有保持<code>switch-bar</code>状态，因为示例中<code>Products</code>列表数比较少，导致<strong>页面的高度 &lt;= 屏幕的高度</strong>，没有滚动条，所以当<code>switch-bar</code>固定在顶部并且从订单或文档切换过来时，由于<strong>document.body.scrollTop = 0</strong>，页面将跳到顶部</li>\n<li>当<code>switch-bar</code>固定在顶部时，切换列表，列表数据第一条并没有显示到正确的位置。</li>\n</ol>\n<p>为了解决第一个问题，给<code>content</code>加了两个计算属性：<code>contentMinHeight</code>和<code>contentMarginTop</code>，动态计算<code>content</code>的<code>height</code>和<code>margin-top</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;</span></span></div><div class=\"line\"><span class=\"tag\"><span class=\"string\">  'minHeight': contentMinHeight + 'px',</span></span></div><div class=\"line\"><span class=\"tag\"><span class=\"string\">  'marginTop': contentMarginTop + 'px'</span></span></div><div class=\"line\"><span class=\"tag\"><span class=\"string\">  &#125;\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">router-view</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\">computed: &#123;</div><div class=\"line\">  contentMinHeight() &#123;</div><div class=\"line\">    const windowHeight = document.documentElement.clientHeight</div><div class=\"line\">    return this.isFix ? windowHeight - this.switchBarHeight : windowHeight - this.headerHeight - this.switchBarHeight</div><div class=\"line\">  &#125;,</div><div class=\"line\">  contentMarginTop() &#123;</div><div class=\"line\">    return this.isFix ? this.switchBarHeight : 0</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了解决第二个问题，watch <code>$route</code>的变化，手动将滚动条滚动至正确的位置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">  <span class=\"string\">'$route'</span>(to, <span class=\"keyword\">from</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isFix) &#123;</div><div class=\"line\">          <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)  <span class=\"comment\">// 兼容chrome</span></div><div class=\"line\">          <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.headerHeight)</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里，整个示例就完成啦~</p>\n<p>想要查看完整代码可前往：<a href=\"https://github.com/hysunny/Vue-dev-note/blob/master/vue-stickyTop/index.html\" target=\"_blank\" rel=\"external\">https://github.com/hysunny/Vue-dev-note/blob/master/vue-stickyTop/index.html</a></p>\n<p>或查看在线示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/yvzyp4kk/2/embed/\"></script>\n\n\n\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"document.execCommand('copy' / 'cut') 异步调用一二事","url":"http://hysunny.me/2017/12/04/document-execCommand-copy/","content":"<p>最近的wap项目开发中有这样一个需求：</p>\n<p><strong>点击“分享”按钮会生成分享链接，然后自动将该链接复制到剪贴板</strong></p>\n<p>一开始以为很好做：</p>\n<p>点击按钮时调用生成分享链接的接口，然后在回调中执行<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\" target=\"_blank\" rel=\"external\">document.execCommand(‘copy’)</a> 就好啦</p>\n<p>简单示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-box\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-link\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"分享链接\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-btn\"</span>&gt;</span>分享<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.share-btn'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  $.ajax(&#123;</div><div class=\"line\">  \turl: <span class=\"string\">'/echo/json/'</span>,</div><div class=\"line\">  \tmethod: <span class=\"string\">'post'</span></div><div class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">rs</span> =&gt;</span> &#123;</div><div class=\"line\">  \t$(<span class=\"string\">'.share-link'</span>).val(<span class=\"string\">'https://xxx.xxx.com/share/xxx'</span>).select()</div><div class=\"line\">   \t<span class=\"built_in\">document</span>.execCommand(<span class=\"string\">'copy'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，现实总会狠狠打脸</p>\n<p>回调中的<code>document.execCommand(&#39;copy&#39;)</code>并没有执行</p>\n<p>效果查看：</p>\n<script async src=\"//jsfiddle.net/hysunny/939upv6n/embed/\"></script>\n\n<p>查看<a href=\"https://www.w3.org/TR/clipboard-apis/#clipboard-event-copy\" target=\"_blank\" rel=\"external\">规范</a>后得知：</p>\n<blockquote>\n<p>These are the steps to follow when triggering copy, cut or paste actions through a scripting API:</p>\n<ol>\n<li>Execute the corresponding action synchronously.</li>\n<li>Use the action’s return value as the return value for the API call.</li>\n</ol>\n<p>Note: Copy and cut commands triggered through a scripting API will only affect the contents of the real clipboard if the event is dispatched from an event that is trusted and triggered by the user, or if the implementation is configured to allow this. Paste commands triggered through a scripting API will only fire paste events and give access to clipboard contents if the implementation is configured to allow this. How implementations can be configured to allow read or write access to the clipboard is outside the scope of this specification.</p>\n</blockquote>\n<p>也就是说：<code>document.execCommand(&#39;copy&#39;)</code>必须是<strong>由用户触发，并且这个操作是同步地</strong>。</p>\n<p>所以，这个需求并不是我不想做，而是无能为力啊(´_ゝ`)</p>\n<p>最后，改成了<strong>点击“分享”生成链接后再弹出个弹窗，然后再点击“复制链接”按钮后复制链接</strong>，简单示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-box\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-link\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"分享链接\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"share-btn\"</span>&gt;</span>分享<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"copy-link\"</span>&gt;</span>复制链接<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'.share-btn'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  $.ajax(&#123;</div><div class=\"line\">    url: <span class=\"string\">'/echo/json/'</span>,</div><div class=\"line\">    method: <span class=\"string\">'post'</span></div><div class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"params\">rs</span> =&gt;</span> &#123;</div><div class=\"line\">  \t $(<span class=\"string\">'.share-link'</span>).val(<span class=\"string\">'https://xxx.xxx.com/share/xxx'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">&nbsp</div><div class=\"line\">$(<span class=\"string\">'.copy-link'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  $(<span class=\"string\">'.share-link'</span>).select()</div><div class=\"line\">  <span class=\"built_in\">document</span>.execCommand(<span class=\"string\">'copy'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>效果可查看： </p>\n<script async src=\"//jsfiddle.net/hysunny/vzh37p9y/embed/\"></script>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"JavaScript 实现 —— 将一个数组插入另一个数组中","url":"http://hysunny.me/2017/11/25/insert-array-to-array/","content":"<p><code>JavaScript</code>将一个数组插入到另一个数组中</p>\n<p>方法一：<code>unshift</code> + <code>splice</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];   </div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>];   </div><div class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"number\">2</span>;   </div><div class=\"line\">arr2.unshift(index, <span class=\"number\">0</span>);  </div><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.splice.apply(arr1, arr2);   </div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr1);     <span class=\"comment\">// [\"a\", \"b\", \"1\", \"2\", \"3\", \"c\"]</span></div></pre></td></tr></table></figure>\n<p>方法二：<code>splice</code> + <code>concat</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];   </div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>];   </div><div class=\"line\"><span class=\"keyword\">var</span> index = <span class=\"number\">2</span>;   </div><div class=\"line\">arr1.splice.apply(arr1, [index, <span class=\"number\">0</span>].concat(arr2));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr1);     <span class=\"comment\">// [\"a\", \"b\", \"1\", \"2\", \"3\", \"c\"]</span></div></pre></td></tr></table></figure>\n<p>方法三: <code>splice</code> + <code>ES6 rest</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];   </div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>]; </div><div class=\"line\">arr1.splice(<span class=\"number\">2</span>, <span class=\"number\">0</span>, ...arr2)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(arr1) \t<span class=\"comment\">//  [\"a\", \"b\", \"1\", \"2\", \"3\", \"c\"]</span></div></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["JavaScript","Array"]},{"title":"Event target 与 currentTarget 的区别","url":"http://hysunny.me/2017/10/29/the-difference-between-target-and-currentTarget/","content":"<ol>\n<li><p><code>target</code>: 触发事件的某个具体对象，只会出现在事件流的<strong>目标阶段</strong>，谁触发谁命中;</p>\n</li>\n<li><p><code>currentTarget</code>: 绑定事件的对象，可能出现在事件流的<strong>任意一个阶段</strong>（捕获、目标及冒泡）中;</p>\n</li>\n<li><p>只有当事件流处于目标阶段时，<code>target</code>和<code>currentTarget</code>才是一致的。</p>\n</li>\n</ol>\n<p>举例：</p>\n<script async src=\"//jsfiddle.net/hysunny/c1kyvLw9/embed/\"></script>\n\n<p>运行代码可以看到：</p>\n<p><img src=\"/images/event-demo.png\" alt=\"示例\"></p>\n<p>说明：上面代码中，<code>div</code>标签嵌套了<code>p</code>标签，并且在父元素中绑定了点击事件，当单击“click me”时，根据<a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\" target=\"_blank\" rel=\"external\">W3C</a>规定，该示例的整个事件流流程如下图：</p>\n<p><img src=\"/images/event-flow.png\" alt=\"event-flow\"></p>\n<p>通过上图，我们应该可以很容易区分<code>target</code>和<code>currentTarget</code>了。</p>\n","categories":["JavaScript"],"tags":["JavaScript","event"]},{"title":"《WebGL 编程指南》笔记 —— 第九章 层次模型","url":"http://hysunny.me/2017/10/09/WebGL-Guide/9/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/7e24180b9669**\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/7e24180b9669**</a></p>\n</blockquote>\n<h3 id=\"1-着色器对象与程序对象\"><a href=\"#1-着色器对象与程序对象\" class=\"headerlink\" title=\"1. 着色器对象与程序对象\"></a>1. 着色器对象与程序对象</h3><p>  <code>着色器对象</code>：着色器对象管理一个顶点着色器或一个片元着色器。每一个着色器都有一个着色器对象。<br>  <code>程序对象</code>：程序对象是管理着色器对象的容器。<code>WebGL</code>中，一个程序对象必须包含一个顶点着色器和一个片元着色器。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ef8cf8ac7cd3eb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"2-initShaders-函数解密\"><a href=\"#2-initShaders-函数解密\" class=\"headerlink\" title=\"2. initShaders() 函数解密\"></a>2. <code>initShaders()</code> 函数解密</h3><p>  <strong>作用</strong>： </p>\n<p>  编译<code>GLSL ES</code>代码，创建和初始化着色器供<code>WebGL</code>使用。</p>\n<p>  <strong>步骤</strong>：</p>\n<p>  （1）创建着色器对象（<code>gl.createShader()</code>）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c5e89655ada75604.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  同理，删除着色器使用<code>gl.deleteShader()</code><br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-6f403bf2949887b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  注意：如果着色器还在使用时执行<code>gl.deleteShader()</code>，并不会立即删除着色器，而是要等到程序对象不再使用该着色器后，才将其删除。</p>\n<p>  （2）向着色器对象中填充着色器程序的源代码（<code>gl.shaderSource()</code>）<br>  在<code>JavaScript</code>中，源代码以字符串形式储存。<br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-2a8109d01e8adbc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （3）编译着色器（<code>gl.compileShader()</code>）<br>  将着色器编译成二进制的可执行格式。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ddceb6630c502873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  编译过程中，调用<code>gl.getShaderParameter()</code>函数来检查着色器的状态。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b064ff608329da82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  如果源代码中存在错误，那么就会出现编译错误，<code>gl.getShaderParameter()</code>就会返回<code>false</code>，同时将编译错误的具体内容写入着色器的信息日志（<code>information log</code>），可以通过<code>gl.getShaderInfoLog()</code>来获取。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-917f13f97a9ddf43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （4）创建程序对象（<code>gl.createProgram()</code>）<br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-fcc85c0fd7f9f019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  同理，使用<code>gl.deleteProgram()</code>来删除程序对象</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5c165cd97d9773a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （5）为程序对象分配着色器（<code>gl.attachShader()</code>）<br>  一旦程序对象被创建之后，需要向程序附上两个着色器（顶点着色器和片元着色器），可以是空的着色器。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-eec2af797272afc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  同理，可以使用<code>gl.detachShader()</code>函数来解除分配给程序对象的着色器。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-597ca045d143cb6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （6）连接程序对象（<code>gl.linkProgram()</code>）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b1d951a8beae3b19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  程序对象进行着色器连接操作的目的是：<br>  a. 保证着色器和片元着色器的varying变量同名同类型，且一一对应；<br>  b. 保证顶点着色器对每个<code>varying</code>变量赋了值；<br>  c. 保证顶点着色器和片元着色器中的同名<code>uniform</code>变量也是同类型的（无需一一对应，即某些uniform变量可以出现在一个着色器中而不出现在另一个中）；<br>  d. 保证着色器中的<code>attribute</code>变量、<code>uniform</code>变量和<code>varying</code>变量的个数没有超过着色器的上限。</p>\n<p>  着色器连接后，调用<code>gl.getProgramPara-meter()</code>来检查连接是否成功</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-2fed3163467ebc57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  调用<code>gl.getProgramInfoLog</code>从信息日志中获取连接出错的信息</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-cfaf24b31cfade8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （7）使用程序对象（<code>gl.userProgram()</code>）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5af1054d3a482ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  <strong>总结</strong>：<code>initShaders()</code>流程：首先调用<code>createProgram()</code>函数创建一个连接好的程序对象，然后告诉<code>WebGL</code>系统来使用这个程序对象，最后将程序对象设为<code>gl</code>对象的<code>program</code>属性。</p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第八章 光照","url":"http://hysunny.me/2017/10/09/WebGL-Guide/8/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/062aa6855f87\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/062aa6855f87</a></p>\n</blockquote>\n<h3 id=\"1-当光线照射到物体上时，发生了两个重要现象：\"><a href=\"#1-当光线照射到物体上时，发生了两个重要现象：\" class=\"headerlink\" title=\"1. 当光线照射到物体上时，发生了两个重要现象：\"></a>1. 当光线照射到物体上时，发生了两个重要现象：</h3><p>  （1）根据光源和光线方向，物体不同表面的<strong>明暗程度</strong>变得不一致。<br>  （2）根据光源和光线方向，物体向地面投下了<strong>影子</strong>。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-a1674decb53c0631.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"2-着色和阴影\"><a href=\"#2-着色和阴影\" class=\"headerlink\" title=\"2.  着色和阴影\"></a>2.  着色和阴影</h3><p>  <code>着色</code>（shading）：根据光照条件重建“物体各表面<strong>明暗不一</strong>的效果”的过程。<br>  <code>阴影</code>（shadowing）：物体向地面投下<strong>影子</strong>的现象。</p>\n<h3 id=\"3-真实世界中的光的类型：\"><a href=\"#3-真实世界中的光的类型：\" class=\"headerlink\" title=\"3. 真实世界中的光的类型：\"></a>3. 真实世界中的光的类型：</h3><p>  （1）<code>平行光</code>（directional light），类似于自然中的太阳光。平行光线相互平行，具有方向，可以用<strong>一个方向和一个颜色</strong>来定义。<br>  （2）<code>点光源光</code>（point light），类似于人造灯泡的光。点光源光是从一个点向周围的所有方向发出的光，需要<strong>指定点光源的位置和颜色</strong>。光线的方向将根据点光源的位置和被照射之处的位置计算出来。<br>  （3）<code>环境光</code>（ambient light），模拟<strong>非直射光</strong>，也就是由光源发出后经过墙壁或其他物体反射后的光。环境光（间接光）是指那些经光源（点光源或平行光源）发出后，被墙壁等物体多次反射，然后照到物体表面上的光。环境光从各个角度照射物体，其强度都是一致的。环境光<strong>不用指定位置和方向，只需指定颜色</strong>即可。<br>  （4）<code>聚光灯光</code>（spot light），模拟电筒、车前灯等。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-fbf3f9a239530ad5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"4-反射光的颜色，取决于：入射光（方向、颜色）和物体表面的类型。\"><a href=\"#4-反射光的颜色，取决于：入射光（方向、颜色）和物体表面的类型。\" class=\"headerlink\" title=\"4. 反射光的颜色，取决于：入射光（方向、颜色）和物体表面的类型。\"></a>4. 反射光的颜色，取决于：入射光（方向、颜色）和物体表面的类型。</h3><h3 id=\"5-物体表面反射光线的方式：\"><a href=\"#5-物体表面反射光线的方式：\" class=\"headerlink\" title=\"5. 物体表面反射光线的方式：\"></a>5. 物体表面反射光线的方式：</h3><p>  （1）漫反射（diffuse relection）<br>  针对平行光或点光源，漫反射的反射光在各个方向上是均匀的。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-12dfbb9fcff088ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  <code>漫反射光颜色</code> = <code>入射光颜色</code> × <code>表面基底色</code> × <code>cosa</code><br>  <code>cosa</code> = <code>光线方向</code> · <code>法线方向</code><br>   <code>漫反射光颜色</code> = <code>入射光颜色</code> × <code>表面基底色</code> × (<code>光线方向</code> · <code>法线方向</code>)</p>\n<p>  （2）环境反射（enviroment/ambient reflection）<br>  针对环境光，环境反射的反射光的方向可以认为是入射光的反方向。在各个方向均匀。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b78775beb62f08ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  <code>环境反射光颜色</code> = <code>入射光颜色</code> × <code>表面基底色</code></p>\n<p>  注：表面基底色是物体本来的颜色，也就是物体在白光下的颜色<br>  当漫反射和环境反射同时存在时，将两者加起来，就会得到物体最终被观察到的颜色</p>\n<p>  <code>表面的反射光颜色</code> = <code>漫反射光颜色</code> + <code>环境反射光颜色</code></p>\n<h3 id=\"6-归一化（normalization）：将一个矢量的长度调整为1，同时保持方向不变的过程。\"><a href=\"#6-归一化（normalization）：将一个矢量的长度调整为1，同时保持方向不变的过程。\" class=\"headerlink\" title=\"6. 归一化（normalization）：将一个矢量的长度调整为1，同时保持方向不变的过程。\"></a>6. <code>归一化</code>（normalization）：将一个矢量的长度调整为1，同时保持方向不变的过程。</h3><h3 id=\"7-平面的法向量唯一，即平面上的任意一点都具有相同的法向量。\"><a href=\"#7-平面的法向量唯一，即平面上的任意一点都具有相同的法向量。\" class=\"headerlink\" title=\"7. 平面的法向量唯一，即平面上的任意一点都具有相同的法向量。\"></a>7. 平面的法向量唯一，即平面上的任意一点都具有相同的法向量。</h3><h3 id=\"8-逆转置矩阵（inverse-transpose-matrx）\"><a href=\"#8-逆转置矩阵（inverse-transpose-matrx）\" class=\"headerlink\" title=\"8. 逆转置矩阵（inverse transpose matrx）\"></a>8. 逆转置矩阵（inverse transpose matrx）</h3><p>  <code>变换后的法向量</code> = <code>法向量</code> × <code>模型矩阵的逆转置矩阵</code></p>\n<p>  求逆转置矩阵的两个步骤：<br>  （1）求原矩阵的<strong>逆矩阵</strong> <code>Matrix4.setInverseOf(m)</code><br>  （2）将上一部求得的逆矩阵进行<strong>转置</strong> <code>Matrix4.transpose()</code></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"Vue 2.0 patch 原理分析","url":"http://hysunny.me/2017/10/02/Vue/vue-patch/","content":"<blockquote>\n<p>本文基于<a href=\"https://github.com/vuejs/vue/tree/v2.4.4\" target=\"_blank\" rel=\"external\">vue-2.4.4</a>源码进行分析</p>\n</blockquote>\n<p>Vue 2.0开始，引入<code>VirtualDOM</code>。</p>\n<p>使用<code>VirtualDOM</code>而不使用真实<code>DOM</code>是出于性能优化的考虑。</p>\n<p>真实<code>DOM</code>使用<code>document.createElement</code>创建DOM元素，但是这个方法会带来性能上的损失。</p>\n<p>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> count = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> div) &#123;</div><div class=\"line\">  count++</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(count)\t<span class=\"comment\">// 231</span></div></pre></td></tr></table></figure>\n<p>执行上面的代码，我们可以看到该方法创建的<code>DOM</code>元素的属性多达231个，但是我们真正需要的可能只有不到10%。</p>\n<p>为了解决这个问题，<code>VirtualDOM</code>应运而生。它和真实<code>DOM</code>保持映射关系，每个<code>VNode</code>节点都存储了对应真实<code>DOM</code>节点的一些重要参数，当数据发生改变时，在改变真实<code>DOM</code>节点之前，会先比较相应的VNode的的数据，如果需要改变，才更新真实<code>DOM</code>。这样就可以通过操作<code>VirtualDOM</code>来提高直接操作<code>DOM</code>的效率和性能。</p>\n<p>比较<code>VNode</code>数据这个操作就是我们今天要讨论的<code>patch</code>，在讨论之前，我们先简单说下<code>VNode</code>。</p>\n<h3 id=\"VNode\"><a href=\"#VNode\" class=\"headerlink\" title=\"VNode\"></a>VNode</h3><p>在上篇<a href=\"http://www.jianshu.com/p/761bca5b34a0\" target=\"_blank\" rel=\"external\">Vue 2.0 模板编译源码分析</a>中我们得出模板编译的结果是<code>render function</code>。</p>\n<p><code>render function</code>的运行结果就是<code>VNode</code>， 参考<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/instance/render.js\" target=\"_blank\" rel=\"external\">src/core/instance/render.js</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vue.prototype._render = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>): <span class=\"title\">VNode</span> </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">const</span> &#123;</div><div class=\"line\">\trender,</div><div class=\"line\">\tstaticRenderFns,</div><div class=\"line\">\t_parentVnode</div><div class=\"line\">  &#125; = vm.$options</div><div class=\"line\">  ... </div><div class=\"line\">  vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Vue 2.0中的<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"external\">VNode</a>(src/core/vdom/vnode.js)定义如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VNode</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span> (</div><div class=\"line\">        tag?: string,</div><div class=\"line\">        data?: VNodeData,</div><div class=\"line\">        children?: ?Array&lt;VNode&gt;,</div><div class=\"line\">        text?: string,</div><div class=\"line\">        elm?: Node,</div><div class=\"line\">        context?: Component,</div><div class=\"line\">        componentOptions?: VNodeComponentOptions,</div><div class=\"line\">        asyncFactory?: Function</div><div class=\"line\">      ) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.tag = tag    <span class=\"comment\">// 元素标签</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.data = data    <span class=\"comment\">// 属性</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.children = children    <span class=\"comment\">// 子元素列表</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.text = text</div><div class=\"line\">        <span class=\"keyword\">this</span>.elm = elm    <span class=\"comment\">//  对应的真实 DOM 元素</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.ns = <span class=\"literal\">undefined</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.context = context</div><div class=\"line\">        <span class=\"keyword\">this</span>.functionalContext = <span class=\"literal\">undefined</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.key = data &amp;&amp; data.key</div><div class=\"line\">        <span class=\"keyword\">this</span>.componentOptions = componentOptions</div><div class=\"line\">        <span class=\"keyword\">this</span>.componentInstance = <span class=\"literal\">undefined</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.parent = <span class=\"literal\">undefined</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.raw = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isStatic = <span class=\"literal\">false</span>     <span class=\"comment\">// 是否被标记为静态节点</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isRootInsert = <span class=\"literal\">true</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isComment = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isCloned = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isOnce = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.asyncFactory = asyncFactory</div><div class=\"line\">        <span class=\"keyword\">this</span>.asyncMeta = <span class=\"literal\">undefined</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.isAsyncPlaceholder = <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>它是真实<code>DOM</code>的简化版，与真实<code>DOM</code>一一对映。通过<code>new</code>实例化的<code>VNode</code>可以分为：<code>EmptyVNode</code>（注释节点）、<code>TextVNode</code>（文本节点）、<code>ElementVNode</code>（元素节点）、<code>ComponentVNode</code>（组件节点）、<code>CloneVNode</code>（克隆节点）等。</p>\n<h3 id=\"patch原理\"><a href=\"#patch原理\" class=\"headerlink\" title=\"patch原理\"></a>patch原理</h3><p>再拉通一下整个思路，目前我们晓得</p>\n<p><code>render function</code> 生成 <code>VNode</code>，是在 <code>vm._render</code> 里完成的。</p>\n<p>那么<code>vm._render</code>方法又是在什么时候调用的呢？</p>\n<p><code>debugger</code>一下代码，可以看到流程如下：</p>\n<p><img src=\"/images/vue-render.png\" alt=\"\"></p>\n<p>初始化时，通过<code>render function</code> 生成 <code>VNode</code>的同时进行<code>Watcher</code>的绑定。当数据发生会变化时，会执行<code>_update</code>方法，生成一个<strong>新的</strong><code>VNode</code>对象，然后调用<code>__patch__</code>方法，比较新生成的<code>VNode</code>和旧的<code>VNode</code>，最后将差异（变化的节点）更新到真实的<code>DOM</code>树上。</p>\n<p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/core/vdom/patch.js\" target=\"_blank\" rel=\"external\">patch</a>(src/core/vdom/patch.js)所用的diff算法来源于<a href=\"https://github.com/snabbdom/snabbdom\" target=\"_blank\" rel=\"external\">snabbdom</a>，只会在同层级进行比较，不会跨层级比较。图示如下：</p>\n<p><img src=\"/images/vue-diff.png\" alt=\"diff algorithm (by Christopher Chedeau)\"></p>\n<p>下面结合源码进行原理分析：</p>\n<h4 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h4><p>patch方法接收6个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">patch</span> (<span class=\"params\">oldVnode, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>oldVnode</code>: 旧的<code>VNode</code>或旧的真实<code>DOM</code>节点</li>\n<li><code>vnode</code>: 新的<code>VNode</code></li>\n<li><code>hydrating</code>: 是否要和真实<code>DOM</code>混合</li>\n<li><code>removeOnly</code>: 特殊的flag，用于<code>&lt;transition-group&gt;</code></li>\n<li><code>parentElm</code>: 父节点</li>\n<li><code>refElm</code>: 新节点将插入到<code>refElm</code>之前</li>\n</ul>\n<h4 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h4><ol>\n<li><p>如果<code>vnode</code>不存在，但是<code>oldVnode</code>存在，说明是需要销毁旧节点，则调用<code>invokeDestroyHook(oldVnode)</code>来销毁<code>oldVnode</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (isUndef(vnode)) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</div><div class=\"line\">  <span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>如果<code>vnode</code>存在，但是<code>oldVnode</code>不存在，说明是需要创建新节点，则调用<code>createElm</code>来创建新节点。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (isUndef(oldVnode)) &#123;</div><div class=\"line\">    isInitialPatch = <span class=\"literal\">true</span>\t<span class=\"comment\">// 用于做延迟插值处理</span></div><div class=\"line\">    createElm(vnode, insertedVnodeQueue, parentElm, refElm)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>当<code>vnode</code>和<code>oldVnode</code>都存在时</p>\n<ul>\n<li>3.1 如果oldVnode不是真实节点，并且<code>vnode</code>和<code>oldVnode</code>是同一节点时，说明是需要比较新旧节点，则调用<code>patchVnode</code>进行<code>patch</code>。</li>\n<li>3.2 如果<code>oldVnode</code>是真实节点时<ul>\n<li>3.2.1 如果oldVnode是元素节点，且含有<code>data-server-rendered</code>属性时，移除该属性，并设置<code>hydrating</code>为<code>true</code>。</li>\n<li>3.2.2 如果<code>hydrating</code>为<code>true</code>时，调用<code>hydrate</code>方法，将<code>Virtural DOM</code>与真实<code>DOM</code>进行映射，然后将<code>oldVnode</code>设置为对应的<code>Virtual DOM</code>。</li>\n</ul>\n</li>\n<li><p>3.3 如果<code>oldVnode</code>是真实节点时或<code>vnode</code>和<code>oldVnode</code>不是同一节点时，找到<code>oldVnode.elm</code>的父节点，根据<code>vnode</code>创建一个真实的<code>DOM</code>节点，并插入到该父节点中的<code>oldVnode.elm</code>位置。如果组件根节点被替换，遍历更新父节点<code>element</code>。然后移除旧节点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// 3. 当vnode和oldVnode都存在时</span></div><div class=\"line\">\t<span class=\"keyword\">const</span> isRealElement = isDef(oldVnode.nodeType)</div><div class=\"line\">     <span class=\"keyword\">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</div><div class=\"line\">     \t <span class=\"comment\">// 3.1 如果oldVnode不是真实节点，并且vnode和oldVnode是同一节点时</span></div><div class=\"line\">       <span class=\"comment\">// patch existing root node</span></div><div class=\"line\">       patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (isRealElement) &#123;</div><div class=\"line\">       \t<span class=\"comment\">// 3.2 如果oldVnode是真实节点时</span></div><div class=\"line\">         <span class=\"comment\">// mounting to a real element</span></div><div class=\"line\">         <span class=\"comment\">// check if this is server-rendered content and if we can perform</span></div><div class=\"line\">         <span class=\"comment\">// a successful hydration.</span></div><div class=\"line\">         <span class=\"keyword\">if</span> (oldVnode.nodeType === <span class=\"number\">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</div><div class=\"line\">           <span class=\"comment\">// 3.2.1 如果oldVnode是元素节点，且含有`data-server-rendered`属性时</span></div><div class=\"line\">           oldVnode.removeAttribute(SSR_ATTR)</div><div class=\"line\">           hydrating = <span class=\"literal\">true</span></div><div class=\"line\">         &#125;</div><div class=\"line\">         <span class=\"keyword\">if</span> (isTrue(hydrating)) &#123;</div><div class=\"line\">           <span class=\"comment\">// 3.2.2 如果hydrating为true时</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</div><div class=\"line\">             invokeInsertHook(vnode, insertedVnodeQueue, <span class=\"literal\">true</span>)</div><div class=\"line\">             <span class=\"keyword\">return</span> oldVnode</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</div><div class=\"line\">             warn(</div><div class=\"line\">               <span class=\"string\">'The client-side rendered virtual DOM tree is not matching '</span> +</div><div class=\"line\">               <span class=\"string\">'server-rendered content. This is likely caused by incorrect '</span> +</div><div class=\"line\">               <span class=\"string\">'HTML markup, for example nesting block-level elements inside '</span> +</div><div class=\"line\">               <span class=\"string\">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</div><div class=\"line\">               <span class=\"string\">'full client-side render.'</span></div><div class=\"line\">             )</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">         <span class=\"comment\">// either not server-rendered, or hydration failed.</span></div><div class=\"line\">         <span class=\"comment\">// create an empty node and replace it</span></div><div class=\"line\">         oldVnode = emptyNodeAt(oldVnode)</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// 3.3 </span></div><div class=\"line\">       <span class=\"comment\">// replacing existing element</span></div><div class=\"line\">       <span class=\"keyword\">const</span> oldElm = oldVnode.elm</div><div class=\"line\">       <span class=\"keyword\">const</span> parentElm = nodeOps.parentNode(oldElm)</div><div class=\"line\">       createElm(</div><div class=\"line\">         vnode,</div><div class=\"line\">         insertedVnodeQueue,</div><div class=\"line\">         oldElm._leaveCb ? <span class=\"literal\">null</span> : parentElm,</div><div class=\"line\">         nodeOps.nextSibling(oldElm)</div><div class=\"line\">       )</div><div class=\"line\">&nbsp</div><div class=\"line\">       <span class=\"keyword\">if</span> (isDef(vnode.parent)) &#123;</div><div class=\"line\">         <span class=\"comment\">// component root element replaced.</span></div><div class=\"line\">         <span class=\"comment\">// update parent placeholder node element, recursively</span></div><div class=\"line\">         <span class=\"keyword\">let</span> ancestor = vnode.parent</div><div class=\"line\">         <span class=\"keyword\">const</span> patchable = isPatchable(vnode)</div><div class=\"line\">         <span class=\"keyword\">while</span> (ancestor) &#123;</div><div class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</div><div class=\"line\">             cbs.destroy[i](ancestor)</div><div class=\"line\">           &#125;</div><div class=\"line\">           ancestor.elm = vnode.elm</div><div class=\"line\">           <span class=\"keyword\">if</span> (patchable) &#123;</div><div class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cbs.create.length; ++i) &#123;</div><div class=\"line\">               cbs.create[i](emptyNode, ancestor)</div><div class=\"line\">             &#125;</div><div class=\"line\">             <span class=\"keyword\">const</span> insert = ancestor.data.hook.insert</div><div class=\"line\">             <span class=\"keyword\">if</span> (insert.merged) &#123;</div><div class=\"line\">               <span class=\"comment\">// start at index 1 to avoid re-invoking component mounted hook</span></div><div class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; insert.fns.length; i++) &#123;</div><div class=\"line\">                 insert.fns[i]()</div><div class=\"line\">               &#125;</div><div class=\"line\">             &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           ancestor = ancestor.parent</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">       <span class=\"keyword\">if</span> (isDef(parentElm)) &#123;</div><div class=\"line\">       \t<span class=\"comment\">// 移除老节点</span></div><div class=\"line\">         removeVnodes(parentElm, [oldVnode], <span class=\"number\">0</span>, <span class=\"number\">0</span>)</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isDef(oldVnode.tag)) &#123;</div><div class=\"line\">         invokeDestroyHook(oldVnode)</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>最后返回 <code>vnode.elm</code>。</p>\n</li>\n</ol>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>由上面的流程我们知道了当<code>vnode</code>和<code>oldVnode</code>都存在、<code>oldVnode</code>不是真实节点，并且<code>vnode</code>和<code>oldVnode</code>是同一节点时，才会调用<code>patchVnode</code>进行<code>patch</code>。</p>\n<p>下面根据<code>patchVnode</code>源码分析patch的原理：</p>\n<ol>\n<li>如果<code>oldVnode</code>和<code>vnode</code>完全一致，则可认为没有变化，<code>return</code>；</li>\n<li>如果<code>oldVnode</code>的<code>isAsyncPlaceholder</code>属性为<code>true</code>时，跳过检查异步组件，<code>return</code>；</li>\n<li>如果<code>oldVnode</code>跟<code>vnode</code>都是静态节点，且具有相同的<code>key</code>，并且当<code>vnode</code>是克隆节点或是<code>v-once</code>指令控制的节点时，只需要把<code>oldVnode.elm</code>和<code>oldVnode.child</code>都复制到<code>vnode</code>上，也不用再有其他操作，<code>return</code>；</li>\n<li><p>否则，如果vnode不是文本节点时</p>\n<ul>\n<li><p>4.1 如果<code>vnode</code>和<code>oldVnode</code>都有子节点并且两者的子节点不一致时，就调用<code>updateChildren</code>更新子节点。<code>updateChildren</code>方法详细的解析可参考<a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"external\">解析vue2.0的diff算法</a>，图示说明，很形象。</p>\n</li>\n<li><p>4.2 如果只有<code>vnode</code>有子节点，则调用<code>addVnodes</code>创建子节点；</p>\n</li>\n<li>4.3 如果只有<code>oldVnode</code>有子节点，则调用<code>removeVnodes</code>把这些节点都删除；     </li>\n<li>4.4 如果<code>oldVnode</code>和<code>vnode</code>都没有子节点，但是<code>oldVnode</code>是文本节点时，则把<code>vnode.elm</code>的文本设置为空字符串；</li>\n</ul>\n</li>\n<li><p>如果<code>vnode</code>是文本节点但是<code>vnode.text != oldVnode.text</code>时只需要更新<code>vnode.elm</code>的文本内容就可以。</p>\n</li>\n</ol>\n<p>原理流程图如下：</p>\n<p><img src=\"/images/vue-patch-flow.png\" alt=\"\"></p>\n<p>自此，<code>Vue</code>的<strong>patch</strong>原理就分析完了。</p>\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"《WebGL 编程指南》笔记 —— 第七章 进入三维世界","url":"http://hysunny.me/2017/10/01/WebGL-Guide/7/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/753d4e225880\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/753d4e225880</a></p>\n</blockquote>\n<h3 id=\"1-视点（eye-point）：观察者所处的（三维空间中的）位置。（eyeX-eyeY-eyeZ）\"><a href=\"#1-视点（eye-point）：观察者所处的（三维空间中的）位置。（eyeX-eyeY-eyeZ）\" class=\"headerlink\" title=\"1. 视点（eye point）：观察者所处的（三维空间中的）位置。（eyeX, eyeY, eyeZ）\"></a>1. 视点（eye point）：观察者所处的（三维空间中的）位置。（eyeX, eyeY, eyeZ）</h3><h3 id=\"2-视线（viewing-direction）：从视点出发沿着观察方向的射线称作视线。\"><a href=\"#2-视线（viewing-direction）：从视点出发沿着观察方向的射线称作视线。\" class=\"headerlink\" title=\"2. 视线（viewing direction）：从视点出发沿着观察方向的射线称作视线。\"></a>2. 视线（viewing direction）：从视点出发沿着观察方向的射线称作视线。</h3><h3 id=\"3-观察目标点（look-at-point）：被观察目标所在的点。视线从视点出发，穿过观察目标点并继续延伸。-atX-atY-atZ\"><a href=\"#3-观察目标点（look-at-point）：被观察目标所在的点。视线从视点出发，穿过观察目标点并继续延伸。-atX-atY-atZ\" class=\"headerlink\" title=\"3. 观察目标点（look-at point）：被观察目标所在的点。视线从视点出发，穿过观察目标点并继续延伸。(atX, atY, atZ)\"></a>3. 观察目标点（look-at point）：被观察目标所在的点。视线从视点出发，穿过观察目标点并继续延伸。(atX, atY, atZ)</h3><h3 id=\"4-上方向（up-direction）：最终绘制在屏幕上的影像中的向上的方向。-upX-upY-upZ\"><a href=\"#4-上方向（up-direction）：最终绘制在屏幕上的影像中的向上的方向。-upX-upY-upZ\" class=\"headerlink\" title=\"4. 上方向（up direction）：最终绘制在屏幕上的影像中的向上的方向。(upX, upY, upZ)\"></a>4. 上方向（up direction）：最终绘制在屏幕上的影像中的向上的方向。(upX, upY, upZ)</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-82529e06ab40c877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"5-视点、观察目标点和上方向可以构成一个视图矩阵（view-matrix）\"><a href=\"#5-视点、观察目标点和上方向可以构成一个视图矩阵（view-matrix）\" class=\"headerlink\" title=\"5. 视点、观察目标点和上方向可以构成一个视图矩阵（view matrix）\"></a>5. 视点、观察目标点和上方向可以构成一个视图矩阵（view matrix）</h3><h3 id=\"6-等式：\"><a href=\"#6-等式：\" class=\"headerlink\" title=\"6.  等式：\"></a>6.  等式：</h3><p>  <code>旋转后顶点坐标</code> = <code>旋转矩阵</code> × <code>原始顶点坐标</code><br>  <code>&quot;从视点看上去&quot;的旋转后顶点坐标</code> = <code>视图矩阵</code> × 旋转后顶点坐标<br>  <code>&quot;从视点看上去&quot;的变换后顶点坐标</code> = <code>视图矩阵</code> × <code>模型矩阵</code> × <code>原始顶点坐标</code></p>\n<h3 id=\"7-可视范围（visible-range）-观察得到的区域边界。\"><a href=\"#7-可视范围（visible-range）-观察得到的区域边界。\" class=\"headerlink\" title=\"7. 可视范围（visible range）: 观察得到的区域边界。\"></a>7. <code>可视范围</code>（visible range）: 观察得到的区域边界。</h3><p>  <code>WebGL</code>只绘制可视范围内的对象，降低程序开销。</p>\n<h3 id=\"8-可视空间：由水平视角、垂直失焦和可视深度（能够看多远）定义\"><a href=\"#8-可视空间：由水平视角、垂直失焦和可视深度（能够看多远）定义\" class=\"headerlink\" title=\"8.可视空间：由水平视角、垂直失焦和可视深度（能够看多远）定义\"></a>8.<code>可视空间</code>：由水平视角、垂直失焦和可视深度（能够看多远）定义</h3><p>  可是空间常分为两类：<br>  （1）长方体可视空间，也称盒状空间，由正射投影（orthographic projection）产生。</p>\n<p>  由前后两个矩形表面确定，分别称<code>近裁剪面</code>（near clipping plane）和<code>远裁剪面</code>（far clipping plane）。</p>\n<p>  近裁剪面的四个顶点为(right, top, -near), (-left, top, -near), (-left, -bottom, -near), (right, -bottom, -near)。</p>\n<p>  近裁剪面与远裁剪面之间的盒形空间就是可视空间，只有在此空间内的物体会被显示出来。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-a6b3262c92547c30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  远裁剪面的四个顶点为(right, top, far), (-left, top, far), (-left, -bottom, far), (right, -bottom, far)</p>\n<p>  （2）四棱锥 / 金字塔可视空间，由<code>透视投影</code>（perspective projection）产生。</p>\n<p>  透视投影矩阵（perspective projection matrix）定义了透视投影可视空间的矩阵。</p>\n<p>  <code>fov</code>: 垂直失焦，即可视空间顶面和底面间的夹角，必须大于0<br>  <code>aspect</code>: 近裁剪面的宽高比（宽度 / 高度）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f1dc94e82da948f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"9-等式\"><a href=\"#9-等式\" class=\"headerlink\" title=\"9. 等式\"></a>9. 等式</h3><p>  <code>正射投影后的坐标</code> = <code>正射投影矩阵</code> × <code>视图矩阵</code> × <code>顶点坐标</code><br>  <code>&quot;从视点看上去&quot;的投影后变换后顶点坐标</code> = <code>投影矩阵</code> ×  <code>视图矩阵</code> × <code>模型矩阵</code> × <code>原始顶点坐标</code></p>\n<h3 id=\"10-隐藏面消除（hidden-surface-removal）：消除那些被遮挡的表面（隐藏面）\"><a href=\"#10-隐藏面消除（hidden-surface-removal）：消除那些被遮挡的表面（隐藏面）\" class=\"headerlink\" title=\"10. 隐藏面消除（hidden surface removal）：消除那些被遮挡的表面（隐藏面）\"></a>10. <code>隐藏面消除</code>（hidden surface removal）：消除那些被遮挡的表面（隐藏面）</h3><p>  开启隐藏面消除功能<br>  前提：必须设置可视空间（正射投影空间或透视投影空间）<br>  步骤：<br>  （1）开启隐藏面消除功能： <code>gl.enable(gl.DEPTH_TEST);</code><br>  <code>gl.enable()</code>规范：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-110aa8938e5300dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （2）在绘制之前，清除深度缓冲区（depth buffer）：<code>gl.clear(gl.DEPTH_BUFFER_BIT);</code><br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b1ad79d617dbe970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  与gl.enable()函数对应的还有gl.disable()函数。禁用某个功能:</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-1adf584a4435e3a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"11-深度冲突（Z-fighting）：当几何图形或物体的两个表面极为接近时，深度缓冲区有限的精度已经不能区分哪个在前，哪个在后了，就会使得表面看上去斑斑驳驳的。\"><a href=\"#11-深度冲突（Z-fighting）：当几何图形或物体的两个表面极为接近时，深度缓冲区有限的精度已经不能区分哪个在前，哪个在后了，就会使得表面看上去斑斑驳驳的。\" class=\"headerlink\" title=\"11. 深度冲突（Z fighting）：当几何图形或物体的两个表面极为接近时，深度缓冲区有限的精度已经不能区分哪个在前，哪个在后了，就会使得表面看上去斑斑驳驳的。\"></a>11. <code>深度冲突</code>（Z fighting）：当几何图形或物体的两个表面极为接近时，深度缓冲区有限的精度已经不能区分哪个在前，哪个在后了，就会使得表面看上去斑斑驳驳的。</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f158e7479bfbf42a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  解决方案： <code>多边形偏移</code>（polygon offset），该机制将直接在Z值上<strong>加上一个偏移量</strong>，偏移量的值由物体表面相对于观察者视线的角度来确定。<br>  启动该机制步骤：<br>  （1）启用多边形偏移：<code>gl.enable(gl.POLYGON_OFFSET_FILL);</code><br>  （2）在绘制之前指定用来计算偏移量的参数： <code>gl.polygonOffset(1.0, 1.0);</code></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-d54e09205f39c760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"12-画立方体\"><a href=\"#12-画立方体\" class=\"headerlink\" title=\"12. 画立方体\"></a>12. 画立方体</h3><p>  <code>gl.drawElements()</code><br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-8bf804517b49443d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第六章 OpenGL ES着色器语言","url":"http://hysunny.me/2017/10/01/WebGL-Guide/6/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/52caa3874f2b\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/52caa3874f2b</a></p>\n</blockquote>\n<p>本章主要内容：<br>（1）数据、变量和变量类型。<br>（2）矢量、矩阵、结构体、数组、采样器（纹理）<br>（3）运算、程序流、函数<br>（4）attribute、uniform和varying变量<br>（5）精度限定词<br>（6）预处理和指令</p>\n<h3 id=\"1-WebGL并不支持GLSL-ES-1-00的所有特性。实际上，它支持的是1-00版本的一个子集，其中只包括WebGL需要的那些核心特性。\"><a href=\"#1-WebGL并不支持GLSL-ES-1-00的所有特性。实际上，它支持的是1-00版本的一个子集，其中只包括WebGL需要的那些核心特性。\" class=\"headerlink\" title=\"1. WebGL并不支持GLSL ES 1.00的所有特性。实际上，它支持的是1.00版本的一个子集，其中只包括WebGL需要的那些核心特性。\"></a>1. WebGL并不支持<code>GLSL ES 1.00</code>的所有特性。实际上，它支持的是1.00版本的一个子集，其中只包括WebGL需要的那些核心特性。</h3><h3 id=\"2-GLEL-ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分后形成的，降低了硬件消耗，减少了性能开销。\"><a href=\"#2-GLEL-ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分后形成的，降低了硬件消耗，减少了性能开销。\" class=\"headerlink\" title=\"2. GLEL ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分后形成的，降低了硬件消耗，减少了性能开销。\"></a>2. GLEL ES编程语言是在OpenGL着色器语言（GLSL）的基础上，删除和简化一部分后形成的，降低了硬件消耗，减少了性能开销。</h3><h3 id=\"3-基础：\"><a href=\"#3-基础：\" class=\"headerlink\" title=\"3. 基础：\"></a>3. 基础：</h3><p>  （1）程序式<strong>大小写敏感</strong>的<br>  （2）每一个语句都应该以一个英文分号结束</p>\n<h3 id=\"4-执行次序\"><a href=\"#4-执行次序\" class=\"headerlink\" title=\"4. 执行次序\"></a>4. 执行次序</h3><p>  从main函数开始执行。<br>  着色器程序<strong>有且仅有</strong>一个main()函数，而且该函数不能接受任何参数。<br>  main函数前的void关键字表示这个函数不返回任何值。</p>\n<h3 id=\"5-注释\"><a href=\"#5-注释\" class=\"headerlink\" title=\"5. 注释\"></a>5. 注释</h3><p>  单行注释：   // int kp = 496;<br>  多行注释： /<em>  haha </em>/</p>\n<h3 id=\"6-数据值类型（数值和布尔值）\"><a href=\"#6-数据值类型（数值和布尔值）\" class=\"headerlink\" title=\"6. 数据值类型（数值和布尔值）\"></a>6. 数据值类型（数值和布尔值）</h3><p>  GLSL支持两种数据值类型<br>  （1）数值类型：整数（没有小数点）和浮点数（有小数点）<br>  （2）布尔值类型：true 和 false<br>  不支持字符串类型</p>\n<h3 id=\"7-变量\"><a href=\"#7-变量\" class=\"headerlink\" title=\"7. 变量\"></a>7. 变量</h3><p>  规则：<br>  （1）只包括a-z，A-Z，0-9和下划线<em><br>  （2）变量名的首字母不能是数字<br>  （3）不能是关键字和保留字，但是变量名的一部分可以是它们<br>  （4）不能以`gl</em><code>，</code>webgl_<code>，或</code><em>webgl</em>`开头，这些前缀已经被OpenGL ES保留了</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-54b4fe0273328ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"GLSL ES关键字\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-9747feac9ab962f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"GLSL ES保留字\"></p>\n<h3 id=\"8-GLSL-ES是强类型语言\"><a href=\"#8-GLSL-ES是强类型语言\" class=\"headerlink\" title=\"8. GLSL ES是强类型语言\"></a>8. GLSL ES是强类型语言</h3><p>  （1）GLSL ES要求具体指明变量的数据类型： &lt;类型&gt; &lt;变量名&gt;<br>  如： <code>vec4 a_Position</code><br>  （2）定义函数时，必须指定函数的返回值<br>  （3）在进行赋值操作（=）的时候，等号左右两侧的数据类型也必须一样，否则就会出错</p>\n<h3 id=\"9-基本类型\"><a href=\"#9-基本类型\" class=\"headerlink\" title=\"9. 基本类型\"></a>9. 基本类型</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-551ecf820518e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"GLSL的基本类型\"></p>\n<p>  为变量指定类型有利于WebGL系统检查代码错误，提高程序的运行效率。<br>  如： float klimt  // 浮点数变量</p>\n<h3 id=\"10-赋值和类型转换\"><a href=\"#10-赋值和类型转换\" class=\"headerlink\" title=\"10. 赋值和类型转换\"></a>10. 赋值和类型转换</h3><p>  <code>=</code> 用于赋值，赋值时要保证左侧变量的类型和右侧的值类型一致<br>  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">float</span> f2 = <span class=\"number\">8.0</span>;</div></pre></td></tr></table></figure></p>\n<p>  可以使用内置函数进行类型转换，如：<br>  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">float</span> f3 = <span class=\"type\">float</span>(<span class=\"number\">8</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-25fb916d84a79b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"类型转换内置函数\"></p>\n<h3 id=\"11-运算符\"><a href=\"#11-运算符\" class=\"headerlink\" title=\"11. 运算符\"></a>11. 运算符</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-6387718e713d635a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"基本类型的运算符\"></p>\n<p>  说明：</p>\n<p>  [1] 在进行逻辑与(&amp;&amp;)运算时，只有第一个表达式的计算值为true时才会计算第二个表达式。同样，在进行逻辑或(||)运算时，只有第一个表达式的值为false时才会计算第二个表达式。</p>\n<p>  [2] 逻辑异或(^^)运算的含义是：只有当左右两个表达式中有且仅有一个为true时，运算结果才是true，否则为false。</p>\n<h3 id=\"12-矢量和矩阵\"><a href=\"#12-矢量和矩阵\" class=\"headerlink\" title=\"12. 矢量和矩阵\"></a>12. 矢量和矩阵</h3><p>  （1）矢量和矩阵类型的变量都包含多个元素，每个元素是一个数值（整型数、浮点数和布尔值）<br>  矢量将这些元素排成一列，可以用来表示顶点坐标或颜色值等，而矩阵将元素划分成行和列，可以用来表示变换矩阵。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-def85d1c3fad1846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6-6.png\"></p>\n<p>  （2）赋值和构造<br>  （a） <code>=</code> 等号用于赋值，如：<code>vec4 position = vec4(1.0, 2.0, 3.0, 4.0);</code><br>  （b）构造函数：专门创建指定类型的变量的函数，构造函数的名称和其创建的变量类型名称总是一致的。</p>\n<p>  （3）矩阵构造函数<br>  （a）想矩阵构造函数中传入矩阵的每一个元素的数值来构造矩阵，注意传入值的顺序必须是列主序的</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3694495af926980f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （b）向矩阵构造函数中传入一个或多个矢量，按照列主序使用矢量里的元素值来构造矩阵。<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用两个vec2对象来创建mat2对象</span></div><div class=\"line\"><span class=\"type\">vec2</span> v2_1 = <span class=\"type\">vec2</span>(<span class=\"number\">1.0</span>, <span class=\"number\">3.0</span>);</div><div class=\"line\"><span class=\"type\">vec2</span> v2_2 = <span class=\"type\">vec2</span>(<span class=\"number\">2.0</span>, <span class=\"number\">2.0</span>);</div><div class=\"line\"><span class=\"type\">mat2</span> m2_1 = <span class=\"type\">mat2</span>(v2_1, v2_2);   <span class=\"comment\">// 1.0  2.0</span></div><div class=\"line\">                                <span class=\"comment\">//  3.0  4.0</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 使用一个vec4对象来创建mat2对象</span></div><div class=\"line\"><span class=\"type\">vec4</span> v4 = <span class=\"type\">vec4</span>(<span class=\"number\">1.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">4.0</span>);</div><div class=\"line\"><span class=\"type\">mat2</span> m2_2 = <span class=\"type\">mat2</span>(v4);     <span class=\"comment\">// 1.0  2.0</span></div><div class=\"line\">                          <span class=\"comment\">//  3.0  4.0</span></div></pre></td></tr></table></figure></p>\n<p>  （c）向矩阵构造函数中出阿奴矢量和数值，按照<strong>列主序</strong>使用矢量里的元素值和直接传入的数值来构造矩阵<br>  <figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用两个浮点数和一个vec2对象来创建mat2对象</span></div><div class=\"line\">mat<span class=\"number\">2</span> <span class=\"name\">m2</span> = mat<span class=\"number\">2</span><span class=\"comment\">(1.0, 3.0, v2_2)</span>;      <span class=\"comment\">// 1.0  2.0</span></div><div class=\"line\">                                     <span class=\"comment\">//  3.0  4.0</span></div></pre></td></tr></table></figure></p>\n<p>  （d）向矩阵构造函数中传入单个数值，这样将生成一个对角线上元素都是该数值，其他元素为0.0的矩阵<br>  <figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><div class=\"line\">mat<span class=\"number\">4</span> <span class=\"name\">m4</span> = mat<span class=\"number\">4</span><span class=\"comment\">(1.0)</span>;    <span class=\"comment\">// 1.0  0.0  0.0  0.0</span></div><div class=\"line\">                        <span class=\"comment\">// 0.0  1.0  0.0  0.0</span></div><div class=\"line\">                        <span class=\"comment\">// 0.0  0.0  1.0  0.0</span></div><div class=\"line\">                        <span class=\"comment\">// 0.0  0.0  0.0  1.0</span></div></pre></td></tr></table></figure></p>\n<p>  与矢量构造函数类似，如果传入的数值的数量大于1，有没有达到矩阵元素的数量，就会出错<br>  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">mat4 m4 = mat4(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>);    <span class=\"comment\">// 错误。mat4对象需要16个元素</span></div></pre></td></tr></table></figure></p>\n<p>  （3）访问元素<br>  为了访问矢量或矩阵中的元素，可以使用<code>.</code>或<code>[]</code>运算符<br>  （a）<code>.</code>运算符</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-7b0105c989e0cedd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分量名\"></p>\n<p>  任何适量的x,r或s分量都会返回第一个分量，y,g,t分量都会返回第二个分量。<br>  如：<br>  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">vec3 v3 = vec3(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>);    <span class=\"comment\">// 将v3设为(1.0, 2.0, 3.0)</span></div><div class=\"line\"><span class=\"type\">float</span> f;</div><div class=\"line\">&nbsp</div><div class=\"line\">f = v3.x;  <span class=\"comment\">// 设f为 1.0</span></div><div class=\"line\">f = v3.y;  <span class=\"comment\">// 设f为 2.0</span></div><div class=\"line\">f = v3.z;  <span class=\"comment\">// 设f为 3.0</span></div><div class=\"line\">&nbsp</div><div class=\"line\">f = v3.r;  <span class=\"comment\">// 设f为 1.0</span></div><div class=\"line\">f = v3.s;  <span class=\"comment\">// 设f为 1.0</span></div></pre></td></tr></table></figure></p>\n<p>  将（同一个集合的）多个分量名共同置于点运算符后，就可以从矢量中同时抽取出多个分量。这个过程乘坐混合（swizzling）<br>  如： v2 = v3.xz<br>  此时的多个分量必须属于同一个集合，比如说，你不能使用v3.was</p>\n<p>  （b）<code>[]</code>运算符<br>  矩阵中的元素从<strong>下标0</strong>开始按照<strong>列主序</strong>读取。<br>  限制：<code>[]</code>中只能出现的索引值必须是<strong>常量索引值</strong></p>\n<p>  <code>常量索引值</code>定义如下：<br>  （a）整型字面量（0或1）<br>  （b）用 <code>const</code> 修饰的全局变量或局部变量。不包括函数参数。<br>  （c）循环索引<br>  （d）由前述三条中的项组成的表达式</p>\n  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">int</span> <span class=\"keyword\">index</span> = <span class=\"number\">0</span>  <span class=\"comment\">// const 关键字表示变量是只读的</span></div><div class=\"line\"><span class=\"type\">vec4</span> v4a = m4[<span class=\"keyword\">index</span>]  <span class=\"comment\">// 同m4[0]相同</span></div></pre></td></tr></table></figure>\n<p>  注意，你不能使用未经<code>const</code>修饰的变量作为索引值，因为它不是一个常量索引值（除非它是循环索引）。</p>\n  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">int</span> index1 = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"type\">vec4</span> v4c = m4[index2]    <span class=\"comment\">// 错误：index不是常量索引</span></div></pre></td></tr></table></figure>\n<p>  （4）运算符<br>  对于矢量和矩阵，只可以使用比较运算符中的<code>==</code> 和 <code>!=</code>，不可以使用<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>和<code>&lt;=</code>。<br>  如果想要比较矢量和矩阵的大小，应该是用内置函数，比如<code>lessThan()</code>。<br>  如果你想逐分量比较，可以使用内置的函数<code>equal()</code>或<code>notEqual()</code></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-e8184f32462e298b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"矢量和矩阵可用的运算符\"></p>\n<h3 id=\"13-矢量和浮点数的运算\"><a href=\"#13-矢量和浮点数的运算\" class=\"headerlink\" title=\"13. 矢量和浮点数的运算\"></a>13. 矢量和浮点数的运算</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f6711963fd38c900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （1） 矢量运算</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c1225958a2972953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （2） 矩阵和浮点数的运算</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5763d85f7934fb4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （3）矩阵右乘矢量</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-00cc4a1c7884c4b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （4） 矩阵左乘矢量</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-beb3fe2d11ddaafb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （5）矩阵与矩阵相乘</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-a1a7b82bb5c6a84e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"14-结构体\"><a href=\"#14-结构体\" class=\"headerlink\" title=\"14.  结构体\"></a>14.  结构体</h3><p>  （1）结构体：用户自定义的类型，使用关键字 struct，将已存在的类型聚合到一起，就可以定义为结构体。如：<br>  <figure class=\"highlight thrift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">light</span> </span>&#123;    <span class=\"comment\">//  定义结构体light</span></div><div class=\"line\">  vec4 color;    <span class=\"comment\">// 光的颜色</span></div><div class=\"line\">  vec4 position;    <span class=\"comment\">// 广元位置</span></div><div class=\"line\">&#125; </div><div class=\"line\">light <span class=\"number\">11</span>, <span class=\"number\">12</span>;    <span class=\"comment\">// 声明了light类型的变量11和12</span></div></pre></td></tr></table></figure></p>\n<p>  也可以在定义结构体的同时声明该结构体类型类型的变量，如：</p>\n  <figure class=\"highlight thrift\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">light</span> </span>&#123;    <span class=\"comment\">//  定义结构体和定义变量同时进行</span></div><div class=\"line\">  vec4 color;    <span class=\"comment\">// 光的颜色</span></div><div class=\"line\">  vec4 position;    <span class=\"comment\">// 广元位置</span></div><div class=\"line\">&#125; <span class=\"number\">11</span>;    <span class=\"comment\">// 该结构体类型的变量11</span></div></pre></td></tr></table></figure>\n<p>  （2）赋值和构造<br>  结构体有标准的构造函数，其名称与结构体名一致。构造函数的参数的顺序必须与结构体定义中的成员顺序一致。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-448082658255aceb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结构体构造函数的使用方法\"></p>\n<p>  （3）访问成员<br>  在结构体变量名后跟点运算符（.），然后再加上成员名，就可以访问变量的成员。如：<br>  <figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><div class=\"line\">vec4 <span class=\"built_in\">color</span> = <span class=\"number\">11.</span><span class=\"built_in\">color</span>;</div><div class=\"line\">vec3 <span class=\"built_in\">position</span> = <span class=\"number\">11.</span><span class=\"built_in\">position</span>;</div></pre></td></tr></table></figure></p>\n<h3 id=\"15-数组\"><a href=\"#15-数组\" class=\"headerlink\" title=\"15. 数组\"></a>15. 数组</h3><p>  （1）<br>  ELSL ES 只支持一维数组，而且数组对象不支持pop()和push()等操作，创建数组时也不需要使用new运算符。<br>  声明数组，只需要在变量名后加上中括号和数组长度，如：<br>  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">float</span> floatArray[<span class=\"number\">4</span>];    <span class=\"comment\">// 声明含有4个浮点数元素的数组</span></div><div class=\"line\">vec4 vec4Array[<span class=\"number\">2</span>];    <span class=\"comment\">//  声明含有两个vec4对象的数组</span></div></pre></td></tr></table></figure></p>\n<p>  数组的长度必须是大于0的整型常量表达式，定义如下：<br>  （a）整型字面量（如0或1）<br>  （b）用const限定字修饰的全局变量或局部变量，不包括函数参数<br>  （c）由前述两条中的项组成的表达式</p>\n<p>  举例：<br>  <figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">int</span> <span class=\"built_in\">size</span> = <span class=\"number\">4</span>;</div><div class=\"line\">vec4 vec4Array[<span class=\"built_in\">size</span>];    // 错误。如果第一行为const <span class=\"built_in\">int</span> <span class=\"built_in\">size</span> = <span class=\"number\">4</span>;则不会报错</div></pre></td></tr></table></figure></p>\n<p>  注意，你不可以用const限定字来修饰数组本身。</p>\n<p>  只有整型常量表达式和uniform变量可以被用作数组的索引值。<br>  数组不能在声明时被一次性地初始化，而必须显式地对每个元素进行初始化。如：</p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">vec4Array[<span class=\"number\">0</span>] = vec4(<span class=\"number\">4.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">6.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">vec4Array[<span class=\"number\">1</span>] = vec4(<span class=\"number\">3.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div></pre></td></tr></table></figure>\n<p>  数组本身只支持[]运算符，但数组的元素能够参与其自身类型支持的任意运算。如：</p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将floatArray的第二个参数乘以3.14</span></div><div class=\"line\"><span class=\"type\">float</span> f = floatArray[<span class=\"number\">1</span>] * <span class=\"number\">3.14</span>;</div><div class=\"line\"><span class=\"comment\">// 将vec4Array的第一个参数乘以vec4(1.0, 2.0, 3.0 ,4.0)</span></div><div class=\"line\">vec4 v4 = vec4Array[<span class=\"number\">0</span>] * vec4(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span> ,<span class=\"number\">4.0</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"16-取样器（纹理）\"><a href=\"#16-取样器（纹理）\" class=\"headerlink\" title=\"16. 取样器（纹理）\"></a>16. 取样器（纹理）</h3><p>  必须通过<code>取样器</code>（sampler）类型变量访问纹理。<br>  有两种基本类型的取样器类型：<code>sampler2D</code> 和 <code>samplerCube</code><br>  取样器变量只能是uniform变量，或者需要访问纹理的函数，如<code>texture2D()</code>函数的参数，如：<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> u_Sampler;</div></pre></td></tr></table></figure></p>\n<p>  只有纹理单元编号可以给取样器变量，而且必须使用gl.uniformli()来进行赋值。</p>\n<p>  除了<code>=</code>、<code>==</code>和<code>!=</code>，取样器变量不可以作为操作数参与运算。</p>\n<p>  取样器变量受到着色器支持的纹理单元的最大数量限制。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-eec3ce347806ef52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"着色器中取样器类型变量的最小数量\"></p>\n<p>  mediump是一个精度限定字</p>\n<h3 id=\"17-运算符优先级\"><a href=\"#17-运算符优先级\" class=\"headerlink\" title=\"17. 运算符优先级\"></a>17. 运算符优先级</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-1d20f0e87f23a2bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"18-程序流程控制：分支和循环\"><a href=\"#18-程序流程控制：分支和循环\" class=\"headerlink\" title=\"18. 程序流程控制：分支和循环\"></a>18. 程序流程控制：分支和循环</h3><p>  （1）if 和 if-else<br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-870270bebbb99ae1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"if语句格式\"></p>\n<p>  如：</p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (distance &lt; <span class=\"number\">0.5</span>) &#123;</div><div class=\"line\">  gl_fragColor = vec4(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  gl_fragColor = vec4(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  （2）for语句</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-0176a16318e306f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"for语句格式\"></p>\n<p>  如：</p>\n  <figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (int <span class=\"built_in\">i</span> = <span class=\"number\">0</span>; <span class=\"built_in\">i</span> &lt; <span class=\"number\">3</span>; <span class=\"built_in\">i</span>++) &#123;</div><div class=\"line\">  sum += i;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  注意：循环变量<code>i</code>只能在初始化表达中定义，条件表达式可以为空，如果这样做，空的条件表达式返回<code>true</code>。</p>\n<p>  for语句的其他限制：<br>  （a）只允许有一个循环变量，循环变量只能是<code>int</code>或<code>float</code>类型。<br>  （b）循环表达式必须是以下的形式：<code>i++</code>,<code>i--</code>,<code>i+=</code>常量表达式或<code>i-=</code>常量表达式<br>  （c）条件表达式必须是循环变量与整型常量的比较<br>  （d）在循环体内，循环变量不可被赋值<br>  这些限制的存在是为了使编译器就能够对for循环进行内联展开</p>\n<p>  （3）continue、break和discard语句<br>  （a）continue终止包含该语句的最内层循环和执行循环表达式（递增/递减循环变量），然后执行下一次循环<br>  （b）break中止包含该语句的最内层循环，并不在继续执行循环。</p>\n<p>  如：<br>  <figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">continue</span> case</div><div class=\"line\"><span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (i == <span class=\"number\">8</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">continue</span>;    <span class=\"regexp\">//</span> 跳过循环体余下的部分，继续下次循环</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"regexp\">//</span> 当i==<span class=\"number\">8</span>时，不会执行到这里</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">break</span> case</div><div class=\"line\"><span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (i == <span class=\"number\">8</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">break</span>;    <span class=\"regexp\">//</span> 跳出<span class=\"keyword\">for</span>循环</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"regexp\">//</span> 当i&gt;=<span class=\"number\">8</span>时，不会执行这里</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"regexp\">//</span> 当i==<span class=\"number\">8</span>时，执行这里</div></pre></td></tr></table></figure></p>\n<p>  关于discard，它只能在片元着色器中使用，表示放弃当前片元直接处理下一片元。</p>\n<h3 id=\"19-函数\"><a href=\"#19-函数\" class=\"headerlink\" title=\"19. 函数\"></a>19. 函数</h3><p>  （1）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-a287b6d6dc026797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"函数语句格式\"></p>\n<p>  可以没有return语句，但是返回类型必须是void<br>  也可以将自己定义的结构体指定为返回类型，但是结构体的成员中不能有数组。</p>\n<p>  示例：</p>\n  <figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// RGBA颜色值转为亮度值函数</span></div><div class=\"line\"><span class=\"built_in\">float</span> luma(vec4, <span class=\"built_in\">color</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0.2126</span> * <span class=\"built_in\">color</span>.r +  <span class=\"number\">0.7162</span> * <span class=\"built_in\">color</span>.g +  <span class=\"number\">0.0722</span> * <span class=\"built_in\">color</span>.b;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\">attribute vec4 a_Color    <span class=\"comment\">// 传了(r, g, b, a)的值</span></div><div class=\"line\"><span class=\"keyword\">void</span> main() &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"built_in\">float</span> <span class=\"built_in\">brightness</span> = luma(a_Color);</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  注意，如果调用函数时传入的参数类型与生命函数时指定的参数类型不一致，就会出错。<br>  如：</p>\n  <figure class=\"highlight cs\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">square</span>(<span class=\"params\"><span class=\"keyword\">float</span> <span class=\"keyword\">value</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">value</span> * <span class=\"keyword\">value</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"keyword\">float</span> x2 = square(<span class=\"number\">10</span>);   <span class=\"comment\">// 错误。应用10.0</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  因为函数声明时的参数是float类型，而调用时却传入了int类型的值。</p>\n<p>  （2）规范声明<br>  如果函数定义在其调用之后，那么我们必须在进行调用之前先声明该函数的规范。<br>  规范会预先告诉WebGL系统函数的参数、参数类型、返回值等等<br>  如：</p>\n  <figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">float</span> luma(vec4, <span class=\"built_in\">color</span>);   <span class=\"comment\">// 规范声明</span></div><div class=\"line\">main() &#123;</div><div class=\"line\">  ...</div><div class=\"line\">  <span class=\"built_in\">float</span> <span class=\"built_in\">brightness</span> = luma(a_Color);  <span class=\"comment\">// luma在定义之前就被调用了</span></div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">float</span> luma(vec4, <span class=\"built_in\">color</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0.2126</span> * <span class=\"built_in\">color</span>.r +  <span class=\"number\">0.7162</span> * <span class=\"built_in\">color</span>.g +  <span class=\"number\">0.0722</span> * <span class=\"built_in\">color</span>.b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  （3）参数限定词<br>  GLSL ES中，可以为参数指定限定自，以控制参数的行为。<br>  我们可以将函数参数定义成：<br>  （a）传递给函数的<br>  （b）将要在函数中被复制的<br>  （c）既是传递给函数的，也是将要在函数中被赋值的。<br>  其中（b）和（c）都有点类似于C语言中的指针</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-eff9d53e0cd8c427.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （4）内置函数</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-eda0c4c6e5db92d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"20-全局变量和局部变量\"><a href=\"#20-全局变量和局部变量\" class=\"headerlink\" title=\"20. 全局变量和局部变量\"></a>20. 全局变量和局部变量</h3><p>  attribute、varying和uniform变量都必须声明为全局变量</p>\n<p>  （1）存储限定字<br>  在GLSL ES中，我们经常使用<code>attribute</code>、<code>varying</code>和<code>uniform</code>限定字来修饰变量，如下图所示。此外，有时也会使用const限定字，它表示着色器中的某个变量是恒定的常量。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ca96b8fefe7ae8b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （2）const变量<br>  const变量写在类型之前，声明的同时必须对它进行初始化，声明之后就不能再去改变它们的值了。<br>  如：<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">3232</span></div></pre></td></tr></table></figure></p>\n<p>  （3）Attributr变量<br>  只能出现在顶点着色器中，只能被声明为<strong>全局变量</strong>，被用来表示逐顶点的信息。<br>  顶点着色器中能够容纳的attribute变量的最大数目与设备有关，你可以通过访问内置的全局常量来获取最大数目的值。<br>  但是不管设备如何，支持WebGL的环境都支持<strong>至少8个</strong><code>attribute</code>变量。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-077bca44d5e457fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  （4）uniform变量<br>  可以用在顶点着色器和片元着色器中，且必须是<strong>全局变量</strong>。<br>  uniform变量<strong>只读</strong>，可以是除了数组或结构体之外的任意类型。<br>  如果在顶点着色器和片元着色器中声明了同名的uniform变量，那么它就会被两种着色器共享。<br>  uniform变量包含了一致（非逐顶点/逐片元的，各顶点或各片元公用）的数据，JS应该向其传递此类数据。<br>  比如，变换矩阵就不是逐定点的，而是所有顶点共用的，所以它在着色器中是uniform变量。<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_ViewMatrix</div></pre></td></tr></table></figure></p>\n<p>  （5）varying变量<br>  必须是<strong>全局变量</strong><br>  从顶点着色器向片元着色器传输数据。<br>  必须在两种着色器中生命同名、同类型的varying变量<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> v_TexCoord</div><div class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color</div></pre></td></tr></table></figure></p>\n<p>  varying变量只能是以下类型：<code>float</code>、<code>vec2</code>、<code>vec3</code>、<code>vec4</code>、<code>mat2</code>、<code>mat3</code>和<code>mat4</code><br>  顶点着色器中赋给varying变量的值并不是直接传给了片元着色器的varying变量，这其中发生了<strong>光栅化</strong>的过程：根据绘制的图形，对前者（顶点着色器varying变量）进行内插，然后再传递个后者（片元着色器varying变量）<br>  正是因为varying变量需要被内插，所以我们需要限制它的数据类型</p>\n<p>  设备至少支持8个varying变量</p>\n<h3 id=\"21-精度限定字\"><a href=\"#21-精度限定字\" class=\"headerlink\" title=\"21. 精度限定字\"></a>21. 精度限定字</h3><p>  帮助着色器程序提高运行效率，削减内存开支。<br>  可选，不确定精度可以使用适中的默认值：<br>  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_ES</span></div><div class=\"line\">precision mediump <span class=\"keyword\">float</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure></p>\n<p>  WebGL中支持的3种精度</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c9f16c9f8daf325c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  注意：<br>  （1）在某些WebGL环境中，片元着色器可能不支持<code>highp</code>精度<br>  （2）数值范围和精度实际上也是与系统环境相关，可以使用<code>gl.getShaderPrecisionFormet()</code>来检查</p>\n<p>  如：<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">mediump</span> <span class=\"type\">float</span> size;  <span class=\"comment\">//  中精度浮点型变量</span></div><div class=\"line\"><span class=\"keyword\">highp</span> <span class=\"type\">vec4</span> position;  <span class=\"comment\">//  具有高精度浮点型的vec4对象</span></div><div class=\"line\"><span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> color;  <span class=\"comment\">//  具有低精度浮点型的vec4对象</span></div></pre></td></tr></table></figure></p>\n<p>  声明着色器的默认精度，这行代码必须在顶点着色器或片元着色器的顶部：<br>  <code>precision</code> 精度限定自 <strong>类型名称</strong><br>  表示接下来所有不以精度限定自修饰的该类型标量，其精度就是默认精度，如：<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>;</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-d60c7aa6a3f41040.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6-27.png\"></p>\n<p>  只有<code>片元着色器</code>中的float类型<strong>没有</strong>默认精度，我们需要手动指定。</p>\n<h3 id=\"22-预处理指令\"><a href=\"#22-预处理指令\" class=\"headerlink\" title=\"22. 预处理指令\"></a>22. 预处理指令</h3><p>  用来在真正编译之前对代码进行预处理，<code>#</code>开始</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-48688f7612c553af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"6-28.png\"></p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_ES</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> GL_FRAGMENT_PRECISION_HIGH</span></div><div class=\"line\">precision highp <span class=\"keyword\">float</span>;  <span class=\"comment\">//  支持高精度，限定浮点型为高精度</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></div><div class=\"line\">precision mediump <span class=\"keyword\">float</span>;  <span class=\"comment\">//  不支持高精度，限定浮点型为中精度</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></div></pre></td></tr></table></figure>\n<p>  可以只是用<code>#version number</code>来指定着色器使用的GLSL ES版本</p>\n<p>  可以接受的版本包括100（GLSL ES 1.00）和101（GLSL ES 1.01）。如果不使用<code>#version</code>命令，默认版本为<code>100</code>。</p>\n<p>  指定版本代码：</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">version 101</span></div></pre></td></tr></table></figure>\n<p>  <code>#version</code> 指令必须在着色器顶部，在它之前只能有注释和空白。</p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第五章 颜色与纹理","url":"http://hysunny.me/2017/10/01/WebGL-Guide/5/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/6c1092db1655\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/6c1092db1655</a></p>\n</blockquote>\n<p>本章主要内容：<br>（1） 将顶点的其他（非坐标）数据 —— 如颜色等 —— 传入顶点着色器<br>（2）发生在顶点着色器和片元着色器之间的从图形到片元的转化，又称图元光栅化（rasterzation process）<br>（3）将图形（或称纹理）映射到图形或三维对象的表面上。</p>\n<h3 id=\"1-将顶点坐标传入着色器，步骤：\"><a href=\"#1-将顶点坐标传入着色器，步骤：\" class=\"headerlink\" title=\"1.  将顶点坐标传入着色器，步骤：\"></a>1.  将顶点坐标传入着色器，步骤：</h3><p>  （1）创建缓冲区对象。<br>  （2）将缓冲区对象绑定到<code>tartget</code>上。<br>  （3）将顶点坐标数据写入缓冲区对象。<br>  （4）将缓冲区对象分配给对应的 <code>attribute</code> 变量。<br>  （5）开启 <code>attribute</code> 变量。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-a39298b99c26bfec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"使用两个缓冲区对象向顶点着色器传输数据\"></p>\n<h3 id=\"2-交错组织（interleaving）：将顶点坐标和尺寸数据打包到同一缓冲区对象中。\"><a href=\"#2-交错组织（interleaving）：将顶点坐标和尺寸数据打包到同一缓冲区对象中。\" class=\"headerlink\" title=\"2. 交错组织（interleaving）：将顶点坐标和尺寸数据打包到同一缓冲区对象中。\"></a>2. <code>交错组织</code>（interleaving）：将<strong>顶点坐标</strong>和<strong>尺寸数据</strong>打包到同一缓冲区对象中。</h3><h3 id=\"3-gl-vertexAttribPointer\"><a href=\"#3-gl-vertexAttribPointer\" class=\"headerlink\" title=\"3. gl.vertexAttribPointer()\"></a>3. <code>gl.vertexAttribPointer()</code></h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-dc8438fd3a7649e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.vertexAttribPointer()\"></p>\n<h3 id=\"4-varying-变量：-从顶点着色器向片元着色器中传入数据。\"><a href=\"#4-varying-变量：-从顶点着色器向片元着色器中传入数据。\" class=\"headerlink\" title=\"4. varying 变量： 从顶点着色器向片元着色器中传入数据。\"></a>4. <code>varying 变量</code>： 从顶点着色器向片元着色器中传入数据。</h3><p>  varying 变量只能是<strong>float</strong>（以及相关的<strong>vec2，vec3，vec4，mat2，mat3，mat4</strong>）。</p>\n<h3 id=\"5-在顶点着色器和片元着色器之间，有两个步骤：\"><a href=\"#5-在顶点着色器和片元着色器之间，有两个步骤：\" class=\"headerlink\" title=\"5. 在顶点着色器和片元着色器之间，有两个步骤：\"></a>5. 在顶点着色器和片元着色器之间，有两个步骤：</h3><p>  [1] <code>图形装配过程：将孤立的顶点坐标装配成几何图形。几何图形的类别由</code>gl.drawArray() `函数的第一个参数决定。<br>  输入数据：gl_Position<br>  [2]  光栅化过程：将装配好的几何图形转为片元。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-e7f9aab3cb51ac7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"顶点着色器和片元着色器之间的图形装配和光栅化\"></p>\n<p>  步骤：<br>  （1）根据 <code>gl.drawArrays()</code>的参数n，将执行顶点着色器<strong>n</strong>次（执行顶点着色器结果：将坐标传入并存储在装配区）<br>  （2）开始装配图形。使用传入的点坐标，根据 <code>gl.drawArrays()</code>的第一个参数信息（如：gl.TRANGLES）来决定如何装配。<br>  （3）光栅化</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-9eb08f5aefbab295.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"几何图形装配和光栅化过程\"></p>\n<h3 id=\"6-颜色内插（interpolation）\"><a href=\"#6-颜色内插（interpolation）\" class=\"headerlink\" title=\"6. 颜色内插（interpolation）\"></a>6. 颜色内插（interpolation）</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-0a9640c9952ca0d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"颜色值的内插\"></p>\n<h3 id=\"7-纹理映射-和-纹素\"><a href=\"#7-纹理映射-和-纹素\" class=\"headerlink\" title=\"7. 纹理映射 和 纹素\"></a>7. 纹理映射 和 纹素</h3><p>  <code>纹理映射</code>（texture mapping）：根据纹理图像，为之前光栅化后的每个片元涂上合适的颜色。<br>  <code>纹素</code>（texels, texture elements）：组成纹理图像的像素。每一个纹素的颜色都是用<strong>RGB</strong>或<strong>RGBA</strong>格式编码。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f2124855bfdf9ee8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"纹素\"></p>\n<h3 id=\"8-在WebGL中，要进行纹理映射，需遵循以下四步：\"><a href=\"#8-在WebGL中，要进行纹理映射，需遵循以下四步：\" class=\"headerlink\" title=\"8.  在WebGL中，要进行纹理映射，需遵循以下四步：\"></a>8.  在WebGL中，要进行纹理映射，需遵循以下四步：</h3><p>  （1）准备好映射到几何图形上的纹理图像。<br>  （2）为几何图形配置纹理映射方式。<br>  （3）加载纹理图像，对其进行一些配置，以在WebGL中使用它。<br>  （4）在片元着色器中将相应的纹素从纹理中抽取出来，并将纹素的颜色赋给片元。</p>\n<h3 id=\"9-纹理坐标\"><a href=\"#9-纹理坐标\" class=\"headerlink\" title=\"9. 纹理坐标\"></a>9. 纹理坐标</h3><p>  <code>纹理坐标</code>是纹理图像上的坐标，通过纹理坐标可以在纹理图像上获取纹素颜色。<br>  WebGL系统中的纹理坐标系统是<strong>二维</strong>的。<br>  WebGL中使用s和t命名纹理坐标。（st坐标系统）</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-778b7dd0646e602d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WebGL的纹理坐标系统\"></p>\n<h3 id=\"10-将纹理图像粘贴到几何图形上\"><a href=\"#10-将纹理图像粘贴到几何图形上\" class=\"headerlink\" title=\"10. 将纹理图像粘贴到几何图形上\"></a>10. 将纹理图像粘贴到几何图形上</h3><p>  在WebGL中，我们通过纹理图像的纹理坐标与几何图形顶点坐标间的映射关系，来确定怎样将纹理图像贴上去。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f5512a813326f8d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将纹理图像映射到顶点上\"></p>\n<h3 id=\"11-纹理映射过程详解\"><a href=\"#11-纹理映射过程详解\" class=\"headerlink\" title=\"11. 纹理映射过程详解\"></a>11. 纹理映射过程详解</h3><p>  步骤：<br>  （1）顶点着色器中接收定点的纹理坐标，光栅化后传递给片元着色器。<br>  （2）片元着色器根据片元的纹理坐标，从纹理图像中抽取出纹素颜色，赋给当前片元。<br>  （3）设置顶点的纹理坐标（<code>initVertexBuffers()</code>）</p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">var verticesTexCoords = new Float32Array([</div><div class=\"line\">  <span class=\"number\">-0.5</span>,  <span class=\"number\">0.5</span>,   <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">  <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>,   <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>,</div><div class=\"line\">   <span class=\"number\">0.5</span>,  <span class=\"number\">0.5</span>,   <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>,</div><div class=\"line\">   <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>,   <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>,    </div><div class=\"line\">])</div></pre></td></tr></table></figure>\n<p>  将顶点坐标和纹理坐标写入缓冲区对象，将其中的顶点坐标分配给a_Position变量并开启之。<br>  <figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a_Position = <span class=\"keyword\">gl</span>.getAttribLocation(<span class=\"keyword\">gl</span>.<span class=\"keyword\">program</span>, 'a_Position');</div><div class=\"line\"><span class=\"keyword\">gl</span>.vertexAttribPointer(a_Position, 2, <span class=\"keyword\">gl</span>.FLOAT, false, FSIZE * 4, 0);</div><div class=\"line\"><span class=\"keyword\">gl</span>.enableVertexAttribArray(a_Position);</div></pre></td></tr></table></figure></p>\n<p>  获取<code>a_TexCoord</code>变量的存储位置，将缓冲区中的纹理坐标分配给该变量更开启。<br>  <figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a_TexCoord = <span class=\"keyword\">gl</span>.getAttribLocation(<span class=\"keyword\">gl</span>.<span class=\"keyword\">program</span>, 'a_TexCoord');</div><div class=\"line\"><span class=\"keyword\">gl</span>.vertexAttribPointer(a_TexCoord, 2, <span class=\"keyword\">gl</span>.FLOAT, false, FSIZE * 4, FSIZE * 2);</div><div class=\"line\"><span class=\"keyword\">gl</span>.enableVertexAttribArray(a_TexCoord);</div></pre></td></tr></table></figure></p>\n<p>  （4）准备待加载的纹理图像，令浏览器读取它（initTextures()）<br>  initTextures() =&gt; 配置和加载问题<br>  调用<code>gl.createTexture()</code>创建纹理对象<br>  <figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var texture</span> = gl.createTexture();</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-af1f8d5148206e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.createTexture()\"></p>\n<p>  同样，也可以使用gl.deleteTeture()来删除一个纹理对象。如果试图删除一个已经被删除的纹理对象，不会报错也不会产生任何影响。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-57ada6a0587ca611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.deleteTeture()\"></p>\n<p>  调用<code>gl.getUniformLocation()</code>从片元着色器中获取<code>uniform</code>变量<code>u_Sampler</code>（取样器）的存储位置，该变量用来接收纹理图像<br>  <figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> u_Sampler = <span class=\"keyword\">gl</span>.getUniformLocation(<span class=\"keyword\">gl</span>.<span class=\"keyword\">program</span>, 'u_Sampler');</div></pre></td></tr></table></figure></p>\n<p>  创建image对象<br>  <figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> image = <span class=\"keyword\">new</span> <span class=\"type\">Image</span>();</div></pre></td></tr></table></figure></p>\n<p>  注册图像加载事件的响应函数<br>  <figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><div class=\"line\">image.onload = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span>&#123; <span class=\"title\">loadTexture</span><span class=\"params\">(gl, n, texture, u_Sampler, image)</span>; &#125;;</span></div></pre></td></tr></table></figure></p>\n<p>  浏览器开始加载图像<br>  <figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">image</span>.src = <span class=\"string\">'../resources/sky.jpg'</span>;</div></pre></td></tr></table></figure></p>\n<p>  （5）监听纹理图像的加载事件，一旦加载完成，就在WebGL系统中使用纹理（loadTexture()）。</p>\n<p>  <code>loadTexture()</code> =&gt; 配置纹理供WebGL使用</p>\n<p>  对纹理图像进行y轴翻转（WebGL纹理坐标中的t轴的方向和PNG、BMP、JPG等格式图片的坐标系统的Y轴方向是相反的。）<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.pixelStorei</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.UNPACK_FLIP_Y_WEBGL</span>, 1);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-aaf68f0b5af2cc44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图像坐标系统和WebGL纹理坐标系统\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-d74e7a9224baf5e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.pixelStorei()\"></p>\n<p>  <strong>开启0号纹理单元</strong><br>  WebGL通过纹理单元的机制来同时使用多个纹理。<br>  每个纹理单元有一个单元编号来管理一张纹理图像。<br>  系统支持的纹理单元格数取决于硬件和浏览器的WebGL实现，但是在默认情况下，WebGL<strong>至少支持8个</strong>纹理单元。<br>  在使用纹理单元之前，还需要调用<code>gl.aactiveTexture()</code>来激活它。<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.activeTexture</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TEXTURE0</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3a54c73076ba0119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.activeTexture()\"></p>\n<p>  绑定纹理对象（设置纹理的类型）<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.bindTexture</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TEXTURE_2D</span>, <span class=\"selector-tag\">texture</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-51ede760a583ce43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"纹理类型\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c34fd0d3b5f036bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.bindTexture()\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-1f99486f5ac83601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将纹理坐标绑定到目标上\"></p>\n<p>  配置纹理对象的参数 =&gt; 设置纹理图像映射到图形上的具体方式<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.texParameteri</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TEXTURE_2D</span>, <span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TEXTURE_MIN_FILTER</span>, <span class=\"selector-tag\">gl</span><span class=\"selector-class\">.LINEAR</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b45cceab15ce2884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.texParameteri()\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-fe933a5a9680050d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"param 参数值\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f3eeb18a4ee053fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"四种纹理参数及它们锁产生的效果\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c5a63c60ce3db700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"纹理参数及它们的默认值\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-bdc5e188f14a5903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  配置纹理图像 =&gt; 将纹理图像分配给纹理对象，同时允许你告诉WebGL系统关于该图像的一些特性。<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.texImage2D</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TEXTURE_2D</span>, 0, <span class=\"selector-tag\">gl</span><span class=\"selector-class\">.RGB</span>, <span class=\"selector-tag\">gl</span><span class=\"selector-class\">.RGB</span>, <span class=\"selector-tag\">gl</span><span class=\"selector-class\">.UNSIGNED_BYTE</span>, <span class=\"selector-tag\">image</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b17ce54099c9fc3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.texImage2D()\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-2c1ad85fe34a3c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"纹素数据的数据格式\"></p>\n<p>  format标示纹理数据的格式，必须根据纹理图像的格式来选择这个参数<br>  JPG =&gt; gl.RGB<br>  PNG =&gt; gl.RGBA<br>  BMP =&gt; gl.RGB<br>  <code>gl.LUMUNANCE</code> 和 <code>gl.LUMINANCE_ALPHA</code> 通常用在灰度图像上等等<br>  <code>流明</code>（luminance）标示我们感知到的物体表面的<strong>亮度</strong>。通常使用物体表面红、蓝颜色分量指的加权平均来计算流明。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3a78ad9da23f76f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"纹理数据的数据格式\"></p>\n<p>  <code>type</code>参数制定了纹理数据类型。通常使用<code>gl.UNSIGNED_BYTE</code>数据类型。</p>\n<p>  分配后的WebGL系统：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-354cae955d612a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将图像分配给纹理对象\"></p>\n<p>  将0号纹理传递给着色器中的<code>取样器变量</code><br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">gl.uniform1i(u_Sampler, <span class=\"number\">0</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> u_Sampler;</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-27b918ecb33d7e00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"专用于纹理的数据类型\"></p>\n<p>  分配给<code>unform</code>变量后的WebGL系统：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-72e6a1727e56104b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将纹理单元分配给uniform变量\"></p>\n<p>  绘制矩形<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.drawArrays</span>(<span class=\"selector-tag\">gl</span><span class=\"selector-class\">.TRIANGLE_STRIP</span>, 0, <span class=\"selector-tag\">n</span>);</div></pre></td></tr></table></figure></p>\n<p>  从顶点着色器向片元着色器传输纹理坐标<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> VSHADER_SOURCE =</div><div class=\"line\">  <span class=\"string\">'attribute vec4 a_Position;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'attribute vec2 a_TexCoord;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'varying vec2 v_TexCoord;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'void main() &#123;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'  gl_Position = a_Position;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'  v_TexCoord = a_TexCoord;\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'&#125;\\n'</span>;</div></pre></td></tr></table></figure></p>\n<p>  在片元着色器中获取纹理像素颜色（texture2D()）<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">gl_FragColor</span> = <span class=\"built_in\">texture2D</span>(u_Sampler, v_TexCoord);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5de556e5771c8500.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"texture2D()\"></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第四章 高级变换与动画基础","url":"http://hysunny.me/2017/10/01/WebGL-Guide/4/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/82d4e909fca8\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/82d4e909fca8</a></p>\n</blockquote>\n<h3 id=\"1-模型变换（model-transformation）-or-建模变换-（modeling-transformation）：一个模型可能过了多次变换，将这些变换全部复合成一个等效的变换。\"><a href=\"#1-模型变换（model-transformation）-or-建模变换-（modeling-transformation）：一个模型可能过了多次变换，将这些变换全部复合成一个等效的变换。\" class=\"headerlink\" title=\"1. 模型变换（model transformation） or 建模变换 （modeling transformation）：一个模型可能过了多次变换，将这些变换全部复合成一个等效的变换。\"></a>1. <code>模型变换</code>（model transformation） or <code>建模变换</code> （modeling transformation）：一个模型可能过了多次变换，将这些变换全部复合成一个等效的变换。</h3><p>相应地，模型变换的矩阵称为<code>模型矩阵</code>。</p>\n<p> <strong>复杂变换的矩阵可以通过一系列基本变换的矩阵相乘得到<br>通过反复变换和重绘图形可以生成动画效果。</strong></p>\n<h3 id=\"2-变换等式\"><a href=\"#2-变换等式\" class=\"headerlink\" title=\"2.  变换等式\"></a>2.  变换等式</h3><p>  <strong>等式一：</strong> <code>&quot;平移&quot;后的坐标</code> = <code>平移矩阵</code>  ×  <code>原始坐标</code></p>\n<p>  <strong>等式二：</strong> <code>&quot;平移后旋转&quot;后的坐标</code> = <code>旋转矩阵</code> × <code>平移后的坐标</code></p>\n<p>  等式一代入等式二，</p>\n<p>  <strong>等式三：</strong><code>&quot;平移后旋转&quot;后的坐标</code> = <code>旋转矩阵</code> × (<code>平移矩阵</code> × <code>原始坐标</code>)</p>\n<h3 id=\"3-WebGL中，设置好的背景色在重设之前一直有效\"><a href=\"#3-WebGL中，设置好的背景色在重设之前一直有效\" class=\"headerlink\" title=\"3. WebGL中，设置好的背景色在重设之前一直有效\"></a>3. WebGL中，设置好的背景色在重设之前一直有效</h3><p>  如设置<code>gl.clearColor(0.0, 0.0, 0.0, 1.0)</code>后，再再次重设前，背景色将一直为黑色。</p>\n<h3 id=\"4-requestAnimationFrame-【HTML5】\"><a href=\"#4-requestAnimationFrame-【HTML5】\" class=\"headerlink\" title=\"4. requestAnimationFrame() 【HTML5】\"></a>4. <code>requestAnimationFrame()</code> 【HTML5】</h3><p>  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p>\n<p>  作用：对浏览器发出一个请求，请求在未来某个适当的时机调用tick()函数方法。</p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第三章 绘制和变换三角形","url":"http://hysunny.me/2017/10/01/WebGL-Guide/3/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/927532b30137\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/927532b30137</a></p>\n</blockquote>\n<h3 id=\"1-缓冲区对象（buffer-object）-可以一次性地向着色器传入多个顶点的数据。\"><a href=\"#1-缓冲区对象（buffer-object）-可以一次性地向着色器传入多个顶点的数据。\" class=\"headerlink\" title=\"1. 缓冲区对象（buffer object）: 可以一次性地向着色器传入多个顶点的数据。\"></a>1. <code>缓冲区对象</code>（buffer object）: 可以一次性地向着色器传入<strong>多个顶点</strong>的数据。</h3><p>  缓冲区对象是WebGL系统中的一块内存区域，我们可以一次性地向缓冲区对象中填充大量的顶点数据，然后将这些数据保存在其中，供顶点着色器使用。</p>\n<h3 id=\"2-使用缓冲区对象向顶点着色器传入多个顶点\"><a href=\"#2-使用缓冲区对象向顶点着色器传入多个顶点\" class=\"headerlink\" title=\"2. 使用缓冲区对象向顶点着色器传入多个顶点\"></a>2. 使用缓冲区对象向顶点着色器传入多个顶点</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3af4fcbff8811006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"使用缓冲区对象向顶点着色器传入多个顶点\"></p>\n<p>  使用缓冲区对象向顶点着色器传入多个顶点的数据步骤：</p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">var vertices = new Float32Array([</div><div class=\"line\">  <span class=\"number\">0.0</span>, <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">-0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">-0.5</span></div><div class=\"line\">])</div></pre></td></tr></table></figure>\n<p>  （1） 创建缓冲区对象   （<code>var vertexBuffer = gl.createBuffer()</code>）</p>\n<p>  创建缓冲区对象前后： WebGL系统中多了一个缓冲区对象。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-4fad47896f9a495a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建缓冲区对象\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-fd822d31dc55f849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.createBuffer()\"></p>\n<p>  （2） 绑定缓冲区对象   （<code>gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)</code>）</p>\n<p>  将缓冲区对象绑定到了 <code>gl.ARRAY_BUFFER</code> 目标上，缓冲区对象中存储着<strong>顶点</strong>的坐标数据。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-595fa8e0ae8c63c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.bindBuffer()\"></p>\n<p>  绑定完成后，WebGL系统中：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-e617d7b95c2529bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将缓冲区对象绑定到目标上\"></p>\n<p>  （3） 将数据写入缓冲区对象  （<code>gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)</code>）</p>\n<p>  将顶点数据写入绑定到<code>gl.ARRAY_BUFFER</code>上的缓冲区对象。<br>  我们不能直接向缓冲区写数据，而只能向<code>“目标”</code>写入数据。<br>  所以，要向缓冲区写数据，<strong>必须先绑定</strong>。</p>\n<p>  该方法执行后，WebGL系统的内部状态如下：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5ad6465ca1f22682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分配空间并向缓冲区对象中写入数据\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-cfad717a42e91f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.bufferData()\"></p>\n<p>  （4） 将缓冲区对象分配给一个 <code>attribute</code> 变量<br>  （<code>gl.vertexAttribPointer(a_Position, 2, gl_FLOAT, false, 0, 0)</code>）</p>\n<p>  <code>gl.vertexAttrib[1 2 3 4]f</code>系列函数一次只能向 <code>attribute</code> 变量分配（传输）<strong>一个值</strong>。<br>  所以，使用<code>gl.vertexAttribPointer()</code>一次性将整个缓冲区对象（实际上是缓冲区对象的引用或指针 =&gt; <strong>多个顶点数据</strong>）分配给一个 <code>attribute</code> 值。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-64e933bcac052382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.vertexAttribPointer()\"></p>\n<p>  执行完第四步后，WbeGL系统内部如下：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-59edb3873d2f1612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"将缓冲区对象分配给attribute变量\"></p>\n<p>  （5） 开启 <code>attribute</code> 变量 （<code>gl.enableVertexAttribArray(a_Position)</code>）</p>\n<p>  传入一个已经分配好缓冲区的 <code>attribute</code> 变量， 我们就开启了该变量。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-15e40b7ba6e85054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.enableVertexAttribArray()\"></p>\n<p>  也可以使用 <code>gl.disableVertexAttribArray()</code> 来关闭分配</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-379fa477f7283cfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.disableVertexAttribArray()\"></p>\n<p>  总结：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-dab7f8e57f31ea13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"使用缓冲区对象向顶点着色器传输多个顶点数据的5个步骤\"></p>\n<h3 id=\"3-类型化数组\"><a href=\"#3-类型化数组\" class=\"headerlink\" title=\"3. 类型化数组\"></a>3. 类型化数组</h3><p>  为了绘制三维图形，WebGL通常需要同时处理大量相同类型的数据，例如顶点的坐标和颜色数据。<br>  为了优化性能，WebGL为每种基本数据类型引入了一种特殊的数组（类型化数组）。<br>  浏览器事先知道数组中的数据类型，所以处理起来也更有效率。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-7d1f55a4ad513b28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WebGL使用的各种类型化数组\"></p>\n<p>  与普通的Array数组不同，类型化数组不支持<code>push()</code> 和 <code>pup()</code>方法。</p>\n<h3 id=\"4-gl-drawArrays\"><a href=\"#4-gl-drawArrays\" class=\"headerlink\" title=\"4. gl.drawArrays()\"></a>4. <code>gl.drawArrays()</code></h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-6705d642c749b01f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.drawArrays()\"></p>\n<p>  该方法的<code>mode</code>参数选择：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3231d683b0110fe3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-34542e0bad9e203a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ea1679ac1142e447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WebGL可以绘制的基本图形\"></p>\n<h3 id=\"5-gl-PositionSize-10-0-只有在绘制单个点（gl-POINTS）的时候才起作用。\"><a href=\"#5-gl-PositionSize-10-0-只有在绘制单个点（gl-POINTS）的时候才起作用。\" class=\"headerlink\" title=\"5. gl_PositionSize = 10.0 只有在绘制单个点（gl.POINTS）的时候才起作用。\"></a>5. <code>gl_PositionSize = 10.0</code> 只有在绘制<strong>单个点</strong>（<code>gl.POINTS</code>）的时候才起作用。</h3><h3 id=\"6-平移-translate\"><a href=\"#6-平移-translate\" class=\"headerlink\" title=\"6. 平移 translate\"></a>6. 平移 <code>translate</code></h3><p>  步骤：<br>  （1）将顶点坐标传给a_Position       <code>attribute vec4 a_Position</code>;<br>  （2）向 a_Position 加上 u_Translation    <code>a_Position + u_Translation</code>;<br>  （3）结果赋值给 gl_Position         <code>gl_Position = a_Position + u_Translation</code>;</p>\n<h3 id=\"7-旋转\"><a href=\"#7-旋转\" class=\"headerlink\" title=\"7. 旋转\"></a>7. 旋转</h3><p>  为了描述一个旋转，必须指明：<br>  （1）旋转轴（图形将围绕旋转轴旋转）<br>  （2）旋转方向（方向：顺时针或逆时针）<br>  （3）旋转角度（图形旋转经过的角度）</p>\n<p>  正旋转（右手法则旋转）：</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f672ba5d2857aa33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3-18.png\"></p>\n<h3 id=\"8-gl-uniformMatrix4fv-location-transpose-array\"><a href=\"#8-gl-uniformMatrix4fv-location-transpose-array\" class=\"headerlink\" title=\"8. gl.uniformMatrix4fv(location, transpose, array)\"></a>8. <code>gl.uniformMatrix4fv(location, transpose, array)</code></h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ee466066215d71d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.uniformMatrix4fv()\"></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第二章 WebGL入门","url":"http://hysunny.me/2017/09/30/WebGL-Guide/2/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/df2bb80e50fa\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/df2bb80e50fa</a></p>\n</blockquote>\n<h3 id=\"1-默认情况下，canvas是透明的。\"><a href=\"#1-默认情况下，canvas是透明的。\" class=\"headerlink\" title=\"1. 默认情况下，canvas是透明的。\"></a>1. 默认情况下，canvas是透明的。</h3><h3 id=\"2-canvas可以灵活地支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫上下文（context）的机制来进行绘图。\"><a href=\"#2-canvas可以灵活地支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫上下文（context）的机制来进行绘图。\" class=\"headerlink\" title=\"2. canvas可以灵活地支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫上下文（context）的机制来进行绘图。\"></a>2. canvas可以灵活地支持二维图形和三维图形，它不直接提供绘图方法，而是提供一种叫<code>上下文</code>（context）的机制来进行绘图。</h3><h3 id=\"3-WebGL-中的颜色取值rgba继承OpenGL，-取值为0-0-—-1-0\"><a href=\"#3-WebGL-中的颜色取值rgba继承OpenGL，-取值为0-0-—-1-0\" class=\"headerlink\" title=\"3. WebGL 中的颜色取值rgba继承OpenGL， 取值为0.0 — 1.0\"></a>3. WebGL 中的颜色取值<code>rgba</code>继承<code>OpenGL</code>， 取值为<code>0.0 — 1.0</code></h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5987090106215cea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.clearColor()\"></p>\n<p>  如果没有指定背景色，默认值如下:</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-5dde8704d34f5025.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"default-bg-color\"></p>\n<h3 id=\"4-gl-clear-gl-COLOR-BUFFER-BIT-清空绘图区域，实际上是在清空颜色缓冲区（color-buffer）。\"><a href=\"#4-gl-clear-gl-COLOR-BUFFER-BIT-清空绘图区域，实际上是在清空颜色缓冲区（color-buffer）。\" class=\"headerlink\" title=\"4. gl.clear(gl.COLOR_BUFFER_BIT)清空绘图区域，实际上是在清空颜色缓冲区（color buffer）。\"></a>4. <code>gl.clear(gl.COLOR_BUFFER_BIT)</code>清空绘图区域，实际上是在清空<strong>颜色缓冲区</strong>（color buffer）。</h3><p>  WebGL中除了颜色缓冲区，还有比如<code>深度缓冲区</code>（DEPTH_BUFFER_BIT）、<code>模板缓冲区</code>（STENCIL_BUFFER_BIT）等。</p>\n<h3 id=\"5-gl-clearColor-指定了背景色以后，背景色会驻存在WebGL系统中，在下一次调用gl-clearColr-方法前不会改变。即，如果后面你想用同一种颜色再清空一次绘图区，没必要再指定一次背景色。\"><a href=\"#5-gl-clearColor-指定了背景色以后，背景色会驻存在WebGL系统中，在下一次调用gl-clearColr-方法前不会改变。即，如果后面你想用同一种颜色再清空一次绘图区，没必要再指定一次背景色。\" class=\"headerlink\" title=\"5. gl.clearColor() 指定了背景色以后，背景色会驻存在WebGL系统中，在下一次调用gl.clearColr()方法前不会改变。即，如果后面你想用同一种颜色再清空一次绘图区，没必要再指定一次背景色。\"></a>5. <code>gl.clearColor()</code> 指定了背景色以后，背景色会驻存在WebGL系统中，在下一次调用<code>gl.clearColr()</code>方法前不会改变。即，如果后面你想用同一种颜色再清空一次绘图区，没必要再指定一次背景色。</h3><h3 id=\"6-WebGL依赖一种新的称为着色器（shader）的绘图机制。\"><a href=\"#6-WebGL依赖一种新的称为着色器（shader）的绘图机制。\" class=\"headerlink\" title=\"6. WebGL依赖一种新的称为着色器（shader）的绘图机制。\"></a>6. WebGL依赖一种新的称为<code>着色器</code>（shader）的绘图机制。</h3><h3 id=\"7-WebGL需要两种着色器：\"><a href=\"#7-WebGL需要两种着色器：\" class=\"headerlink\" title=\"7. WebGL需要两种着色器：\"></a>7. WebGL需要两种着色器：</h3><p>  （1）<code>顶点着色器</code>（Vertex shader）：用来描述<strong>顶点</strong>的特性（如位置、颜色等）。<br>  （2）<code>片元着色器</code>（Fragment shader） ： 进行<strong>逐片处理</strong>过程（如光照等），片元也可以理解为像素（图像的单元）。</p>\n<h3 id=\"8-WebGL程序执行流程\"><a href=\"#8-WebGL程序执行流程\" class=\"headerlink\" title=\"8. WebGL程序执行流程\"></a>8. WebGL程序执行流程</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-8ccf62fed6e57c27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"webgl-flow\"></p>\n<p>  最右边的是颜色缓冲区不是浏览器，因为颜色缓冲区的内容会自动显示在浏览器中。</p>\n<h3 id=\"9-初始化着色器initShaders-的行为\"><a href=\"#9-初始化着色器initShaders-的行为\" class=\"headerlink\" title=\"9. 初始化着色器initShaders()的行为\"></a>9. 初始化着色器<code>initShaders()</code>的行为</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-48763c6f39a02f17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"initShades()\"></p>\n<p>  在初始化着色器之前，顶点着色器和片元着色器都是空白的，我们需要将字符串形式的<strong>着色器代码从JavaScript传给WebGL系统</strong>，并建立着色器，这就是<code>initShaders()</code>所做的事情。</p>\n<p>  <strong>注意：</strong></p>\n<pre><code>着色器代码运行在WebGL系统中，而不是JavaScript程序中。\n顶点着色器先执行，片元着色器后执行。\n</code></pre><h3 id=\"10-WebGL程序包括运行在浏览器中的JavaScript和运行在WebGL-系统中的着色器这两部分。\"><a href=\"#10-WebGL程序包括运行在浏览器中的JavaScript和运行在WebGL-系统中的着色器这两部分。\" class=\"headerlink\" title=\"10. WebGL程序包括运行在浏览器中的JavaScript和运行在WebGL 系统中的着色器这两部分。\"></a>10. WebGL程序包括<strong>运行在浏览器中的JavaScript</strong>和<strong>运行在WebGL 系统中的着色器</strong>这两部分。</h3><h3 id=\"11-顶点着色器\"><a href=\"#11-顶点着色器\" class=\"headerlink\" title=\"11. 顶点着色器\"></a>11. 顶点着色器</h3>  <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> VSHADER_SOURCE = </div><div class=\"line\"> <span class=\"string\">'void main() &#123;\\n'</span> +</div><div class=\"line\"> <span class=\"string\">' gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n'</span> + <span class=\"comment\">// Set the vertex coordinates of the point</span></div><div class=\"line\"> <span class=\"string\">' gl_PointSize = 10.0;\\n'</span> + <span class=\"comment\">// Set the point size</span></div><div class=\"line\"> <span class=\"string\">'&#125;\\n'</span>;</div></pre></td></tr></table></figure>\n<p>  （1）void  → 没有返回值<br>  （2）不能为main函数指定参数<br>  （3）<code>gl_Position</code> 表示位置，是内置变量，必须被赋值，否则着色器无法工作<br>  （4）<code>gl_PointSize</code>  表示尺寸，也是内置变量，默认值为1.0</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c86f94eaff3227f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vshader\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-72a8bf46872593e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"GLSE_data_type\"></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-586972216e5456e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vec4\"></p>\n  <figure class=\"highlight lsl\"><table><tr><td class=\"code\"><pre><div class=\"line\">gl_Position = vec4(<span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>)</div></pre></td></tr></table></figure>\n<p>  前三个分量分别为X, Y, Z，最后一个分量为 <strong>齐次坐标</strong></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-303bb1e23a521644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"齐次坐标\"></p>\n<h3 id=\"12-片元着色器\"><a href=\"#12-片元着色器\" class=\"headerlink\" title=\"12. 片元着色器\"></a>12. 片元着色器</h3>  <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Fragment shader program</span></div><div class=\"line\"><span class=\"keyword\">var</span> FSHADER_SOURCE =</div><div class=\"line\"> <span class=\"string\">'void main() &#123;\\n'</span> +</div><div class=\"line\"> <span class=\"string\">' gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n'</span> + <span class=\"comment\">// Set the point color</span></div><div class=\"line\"> <span class=\"string\">'&#125;\\n'</span>;</div></pre></td></tr></table></figure>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-24f4ea4c930aa29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fshader\"></p>\n<h3 id=\"13-绘制操作\"><a href=\"#13-绘制操作\" class=\"headerlink\" title=\"13. 绘制操作\"></a>13. 绘制操作</h3><p>  步骤：<br>  （1）清空绘制区<br>  （2）gl.drawArrays(mode, first, count)</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b70168c5c658767a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.drawArrays()\"></p>\n<p>  <code>gl.drawArrays(mode, first, count)</code> 将会执行 <strong>count</strong> 次</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-6f96ce225724b3ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"shader-flow\"></p>\n<h3 id=\"14-WebGL-坐标系统\"><a href=\"#14-WebGL-坐标系统\" class=\"headerlink\" title=\"14. WebGL 坐标系统\"></a>14. WebGL 坐标系统</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b39af47b6f42fc72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"webgl-coord\"></p>\n<h3 id=\"15-attribute-变量-和-uniorm-变量\"><a href=\"#15-attribute-变量-和-uniorm-变量\" class=\"headerlink\" title=\"15. attribute 变量 和 uniorm 变量\"></a>15. attribute 变量 和 uniorm 变量</h3><p>  <code>attribute 变量</code> ： GLSL ES变量，传输的是那些与<strong>顶点相关</strong>的数据（外部向顶点着色器传输，只有顶点着色器能使用）。<br>  <code>uniform 变量</code>： 传输的是那些与所有顶点都相同（或与<strong>顶点无关</strong>）的数据 （数据传输的目标是片元着色器，而非顶点着色器）。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-93151f67825c2f15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"data-transfer\"></p>\n<p>  为了使用 attribute 变量：示例程序需要包含以下步骤：</p>\n<p>  （1）在顶点着色器中，声明 attribute 变量；<br>    <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Position;</div></pre></td></tr></table></figure></p>\n<p>  attribute 被称为<code>存储限定符</code>（storage qualifier），它表示接下来的变量，attribute变量必须声明为<strong>全局变量</strong>。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-ef6d7dc11ea683be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"storage-qualifier\"></p>\n<p>  （2）将 <code>attribute</code> 变量赋值给 <code>gl_Position</code> 变量；</p>\n<pre><code>先获取 attribute变量的存储位置:\n</code></pre>  <figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a_Position = <span class=\"keyword\">gl</span>.getAttribLocation(<span class=\"keyword\">gl</span>.<span class=\"keyword\">program</span>, 'a_Position');</div></pre></td></tr></table></figure>\n<p>  <code>gl.program</code> =&gt; 程序对象，包含了<code>顶点着色器</code>和<code>片元着色器</code></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-f355d66980b0a09b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"gl.getAttribLotation()\"></p>\n<p>  （3）向 <code>attribute</code> 变量传输数据；<br>          将顶点位置传输给 <code>attribute</code> 变量：<br>  <figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">gl</span><span class=\"selector-class\">.vertexAttrib3f</span>(<span class=\"selector-tag\">a_Position</span>, 0<span class=\"selector-class\">.0</span>, 0<span class=\"selector-class\">.0</span>, 0<span class=\"selector-class\">.0</span>);</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-efa354d5663ca89a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vertexAttrib3f\"></p>\n<p>  <code>gl.vertexAttrib3f()</code>的同族函数:</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-d7182e74492937ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vertexAttribnf\"></p>\n<p>  WebGL 相关函数命名规范：<br>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-b37d23488acd2141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"webgl-function-standard\"></p>\n<p>  使用 uniform 变量步骤：<br>  （1）在片元着色器中准备 uniform 变量；<br>  <figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec4</span> u_FragColor;</div></pre></td></tr></table></figure></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-8551ad4151bc55c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"uniform-declaration\"></p>\n<p>  <code>precision mediump float;</code>  精度限定词（precision qualifier） ,指定变量的<strong>范围</strong>（最大值与最小值）和<strong>精度</strong>。</p>\n<p>  （2）用这个 <code>uniform</code> 变量向 <code>gl_FragColor</code> 赋值；<br>  获取 <code>uniform</code> 变量的存储地址。</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-13d31393ad2e6d16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"getUniformLocation.png\"></p>\n<p>  （3）将颜色数据从JavaScript传给该 <code>uniform</code> 变量。<br>  向 <code>uniform</code> 变量赋值 <code>gl.uniform4f(location, v0, v1, v2, v3)</code></p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-3e505deeea3a06ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"uniform4f\"></p>\n<p>  <code>gl.uniform4f()</code>的同族函数</p>\n<p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-c7a7cb2b4ed3076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"uniformnf\"></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"《WebGL 编程指南》笔记 —— 第一章 WebGL概述","url":"http://hysunny.me/2017/09/30/WebGL-Guide/1/","content":"<blockquote>\n<p>简书地址: <a href=\"https://www.jianshu.com/p/8aa0d6d09de9\" target=\"_blank\" rel=\"external\">https://www.jianshu.com/p/8aa0d6d09de9</a></p>\n</blockquote>\n<h3 id=\"1-WebGL是一项用来在网页上绘制和渲染三维图形（3D图形），并允许用户与之进行交互的技术。\"><a href=\"#1-WebGL是一项用来在网页上绘制和渲染三维图形（3D图形），并允许用户与之进行交互的技术。\" class=\"headerlink\" title=\"1. WebGL是一项用来在网页上绘制和渲染三维图形（3D图形），并允许用户与之进行交互的技术。\"></a>1. WebGL是一项用来在网页上绘制和渲染<code>三维图形</code>（3D图形），并允许用户与之进行交互的技术。</h3><h3 id=\"2-个人计算机上使用最广泛的两种三维图形渲染技术是Direct3D和OpenGL（1992-SGI-Silicon-Graphics-Inc开发）。\"><a href=\"#2-个人计算机上使用最广泛的两种三维图形渲染技术是Direct3D和OpenGL（1992-SGI-Silicon-Graphics-Inc开发）。\" class=\"headerlink\" title=\"2. 个人计算机上使用最广泛的两种三维图形渲染技术是Direct3D和OpenGL（1992 SGI Silicon Graphics Inc开发）。\"></a>2. 个人计算机上使用最广泛的两种三维图形渲染技术是<code>Direct3D</code>和<code>OpenGL</code>（1992 SGI Silicon Graphics Inc开发）。</h3><h3 id=\"3-WebGL从OpenGL-ES（2003-2004提出，2007ES2-0，2012ES3-0）派生出来，基于ES2-0。\"><a href=\"#3-WebGL从OpenGL-ES（2003-2004提出，2007ES2-0，2012ES3-0）派生出来，基于ES2-0。\" class=\"headerlink\" title=\"3. WebGL从OpenGL ES（2003-2004提出，2007ES2.0，2012ES3.0）派生出来，基于ES2.0。\"></a>3. WebGL从<code>OpenGL ES</code>（2003-2004提出，2007ES2.0，2012ES3.0）派生出来，基于<code>ES2.0</code>。</h3><h3 id=\"4-OpenGL-2-0-起支持-可编程着色器，OpenGL-ES2-0继承了该特性，成为了WebGL1-0-的核心部分。\"><a href=\"#4-OpenGL-2-0-起支持-可编程着色器，OpenGL-ES2-0继承了该特性，成为了WebGL1-0-的核心部分。\" class=\"headerlink\" title=\"4. OpenGL 2.0 起支持 可编程着色器，OpenGL ES2.0继承了该特性，成为了WebGL1.0 的核心部分。\"></a>4. OpenGL 2.0 起支持 <code>可编程着色器</code>，OpenGL ES2.0继承了该特性，成为了WebGL1.0 的核心部分。</h3><h3 id=\"5-着色器语言（shading-language）\"><a href=\"#5-着色器语言（shading-language）\" class=\"headerlink\" title=\"5. 着色器语言（shading language）\"></a>5. 着色器语言（shading language）</h3><pre><code>OpenGL着色器语言（GLSL）\nOpenGL ES着色器语言（GLSL ES）\n</code></pre><h3 id=\"6-2011年-WebGL-发布第一个版本。\"><a href=\"#6-2011年-WebGL-发布第一个版本。\" class=\"headerlink\" title=\"6. 2011年 WebGL 发布第一个版本。\"></a>6. 2011年 WebGL 发布第一个版本。</h3><h3 id=\"7-WebGL页面包含了三种语言：-HTML5（超文本标记语言）、JavaScript-和-GLSL-ES。\"><a href=\"#7-WebGL页面包含了三种语言：-HTML5（超文本标记语言）、JavaScript-和-GLSL-ES。\" class=\"headerlink\" title=\"7. WebGL页面包含了三种语言： HTML5（超文本标记语言）、JavaScript 和 GLSL ES。\"></a>7. WebGL页面包含了三种语言： <code>HTML5</code>（超文本标记语言）、<code>JavaScript</code> 和 <code>GLSL ES</code>。</h3><p>  <img src=\"http://upload-images.jianshu.io/upload_images/3779867-48330da09accdcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"WebGL.png\"></p>\n","categories":["WebGL"],"tags":["WebGL"]},{"title":"Vue.js 2.0 模板编译源码分析","url":"http://hysunny.me/2017/09/28/Vue/vue-render/","content":"<blockquote>\n<p>本文基于<a href=\"https://github.com/vuejs/vue/tree/v2.4.4\" target=\"_blank\" rel=\"external\">vue-2.4.4</a>源码进行分析</p>\n</blockquote>\n<p>模板编译是Vue 2.0中很重要的一个环节，它将<code>template</code>编译成<code>render</code> 函数，最后生成<code>Virtual DOM</code>渲染在页面。</p>\n<p>本篇文章将结合源码对<strong>模板编译</strong>流程进行分析：</p>\n<p>从源码角度看，模板编译主要经历如下流程：</p>\n<p><img src=\"/images/vue-compile.png\" alt=\"vue-compile.png\"></p>\n<p>即：</p>\n<p>首先，在项目初始化时<code>挂载DOM节点</code>并<code>获取template</code></p>\n<p>然后将 <code>template</code> 编译成 <code>render 函数</code>。这个编译过程包含：</p>\n<ol>\n<li><code>check 缓存</code>，如果有缓存数据就读取缓存数据</li>\n<li>获取并合并<code>options</code></li>\n<li><code>parse</code>: 将template解析成AST</li>\n<li><code>optimize</code>: 标记静态节点</li>\n<li><code>generate</code>: 拼接 render function 字符串</li>\n<li>通过 new function 生成<strong>渲染函数</strong></li>\n<li>缓存</li>\n</ol>\n<p>其中，3、4、5是整个模板编译的核心。</p>\n<p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/index.js\" target=\"_blank\" rel=\"external\">baseCompile</a>函数（src/compiler/index.js）依次执行<code>parse</code>，<code>optimize</code>，和<code>generate</code>，最后返回一个包含<code>ast</code>、<code>render</code>和<code>staticRenderFns</code>的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createCompiler = createCompilerCreator(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseCompile</span> (<span class=\"params\"></span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  template: string,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CompiledResult</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 3. parse: 将template解析成AST</span></div><div class=\"line\">  <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</div><div class=\"line\">  <span class=\"comment\">// 4. optimize: 标记静态节点</span></div><div class=\"line\">  optimize(ast, options)</div><div class=\"line\">  <span class=\"comment\">// 5. generate: 拼接 render function 字符串</span></div><div class=\"line\">  <span class=\"keyword\">const</span> code = generate(ast, options)</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    ast,</div><div class=\"line\">    render: code.render,</div><div class=\"line\">    staticRenderFns: code.staticRenderFns</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"parse-将template解析成AST\"><a href=\"#parse-将template解析成AST\" class=\"headerlink\" title=\"parse: 将template解析成AST\"></a>parse: 将template解析成AST</h3><p>这里，先简单介绍下AST。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9\" target=\"_blank\" rel=\"external\">AST</a>全称是：Abstract Syntax Tree (抽象语法树)，是源代码语法所对应的树状结构。Vue 2.0中ASTNode有三种形式：<code>ASTElement</code>、<code>ASTText</code>、<code>ASTExpression</code>。</p>\n<p>Vue 2.0中的<a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/parser/index.js\" target=\"_blank\" rel=\"external\">parse</a>函数（src/compiler/parser/index.js）采用了jQuery作者<a href=\"https://zh.wikipedia.org/wiki/%E7%B4%84%E7%BF%B0%C2%B7%E9%9B%B7%E8%A5%BF%E6%A0%BC\" target=\"_blank\" rel=\"external\">John Resig</a>的<a href=\"https://johnresig.com/files/htmlparser.js\" target=\"_blank\" rel=\"external\">HTML Parser</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseHTML(template, &#123;</div><div class=\"line\">  start (tag, attrs, unary) &#123;</div><div class=\"line\">  \t<span class=\"comment\">// 解析到新的节点时调用，包括节点tagName, attributes等信息</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  end () &#123;</div><div class=\"line\">  \t<span class=\"comment\">// 节点解析结束时调用，包括节点tagName等信息</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  chars (text: string) &#123;</div><div class=\"line\">  \t<span class=\"comment\">// 文本解析完成时调用，包括文本本身</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如：<code>&lt;div id=&#39;app&#39;&gt;&lt;/div&gt;</code></p>\n<p><code>parseHTML</code>后的结果是：</p>\n<p><img src=\"/images/ast.png\" alt=\"ast.png\"></p>\n<h3 id=\"optimize-标记静态节点\"><a href=\"#optimize-标记静态节点\" class=\"headerlink\" title=\"optimize: 标记静态节点\"></a>optimize: 标记静态节点</h3><p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/optimizer.js\" target=\"_blank\" rel=\"external\">optimize</a>函数（src/compiler/optimizer.js）会对静态节点打标，提取最大的静态树，在后面patch时，被标记为static的节点将直接跳过diff。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">optimize</span> (<span class=\"params\">root: ?ASTElement, options: CompilerOptions</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span></div><div class=\"line\">  isStaticKey = genStaticKeysCached(options.staticKeys || <span class=\"string\">''</span>)</div><div class=\"line\">  isPlatformReservedTag = options.isReservedTag || no</div><div class=\"line\">  <span class=\"comment\">// first pass: mark all non-static nodes.</span></div><div class=\"line\">  markStatic(root)</div><div class=\"line\">  <span class=\"comment\">// second pass: mark static roots.</span></div><div class=\"line\">  markStaticRoots(root, <span class=\"literal\">false</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"generate-拼接-render-function-字符串\"><a href=\"#generate-拼接-render-function-字符串\" class=\"headerlink\" title=\"generate: 拼接 render function 字符串\"></a>generate: 拼接 render function 字符串</h3><p><a href=\"https://github.com/vuejs/vue/blob/v2.4.4/src/compiler/codegen/index.js\" target=\"_blank\" rel=\"external\">generate</a>函数（src/compiler/codegen/index.js）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">generate</span> (<span class=\"params\"></span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  ast: ASTElement | void,</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\">  options: CompilerOptions</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"params\"></span>): <span class=\"title\">CodegenResult</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> state = <span class=\"keyword\">new</span> CodegenState(options)</div><div class=\"line\">  <span class=\"keyword\">const</span> code = ast ? genElement(ast, state) : <span class=\"string\">'_c(\"div\")'</span></div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    render: <span class=\"string\">`with(this)&#123;return <span class=\"subst\">$&#123;code&#125;</span>&#125;`</span>,</div><div class=\"line\">    staticRenderFns: state.staticRenderFns</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>模板编译的核心：<code>template</code>  →  <code>AST</code> →  <code>render function</code></p>\n<p><img src=\"/images/vue-compile-flow.png\" alt=\"vue-comile-flow.png\"></p>\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"JavaScript深入理解 —— 原型、原型链和继承","url":"http://hysunny.me/2017/09/17/javascript-prototype/","content":"<h2 id=\"普通对象和函数对象\"><a href=\"#普通对象和函数对象\" class=\"headerlink\" title=\"普通对象和函数对象\"></a>普通对象和函数对象</h2><p>函数对象：使用<code>函数声明</code>、<code>函数表达式</code>、<code>Function构造函数</code>创建的对象</p>\n<blockquote>\n<p>函数实际上是对象，每个函数都是<code>Function</code>类型的实例，而且都与其他引用类型一样具有属性和方法。</p>\n</blockquote>\n<p>普通对象：除了<code>函数对象</code>以外的对象，都是普通对象。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义函数的三个方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125;;\t\t<span class=\"comment\">// 函数声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;\t\t\t<span class=\"comment\">// 函数表达式</span></div><div class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"num1\"</span>, <span class=\"string\">\"num2\"</span>, <span class=\"string\">\"return num1 + num2\"</span>);\t\t<span class=\"comment\">// Function构造函数</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 创建对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> o1 = &#123;&#125;; \t\t<span class=\"comment\">// 对象字面量</span></div><div class=\"line\"><span class=\"keyword\">var</span> o2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();\t\t<span class=\"comment\">// Object构造函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> o3 = <span class=\"keyword\">new</span> f1();\t\t<span class=\"comment\">// f1构造函数</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 检测类型</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Function</span>);  <span class=\"comment\">//function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">//function</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> f1);  <span class=\"comment\">//function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> f2);  <span class=\"comment\">//function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> f3);  <span class=\"comment\">//function</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> o1);  <span class=\"comment\">//object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> o2);  <span class=\"comment\">//object</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> o3);  <span class=\"comment\">//object</span></div></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>构造函数： 通过<code>new</code>关键字方式调用的函数。</p>\n<p>在构造函数内部（也就是被调用的函数内）：</p>\n<ol>\n<li><code>this</code> 指向实例对象 <code>Object</code>；</li>\n<li>这个实例对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code>；</li>\n<li>这个实例对象的<code>constructor</code>属性指向<code>构造函数</code>；</li>\n<li>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 —— 也就是实例对象。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1 <span class=\"keyword\">instanceof</span> Person);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.constructor === person2.constructor);\t\t<span class=\"comment\">// true</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 实例的__proto__属性指向构造函数的prototype</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === Person.prototype);\t\t<span class=\"comment\">// true</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 实例的constructor指向构造函数</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.constructor === Person);\t\t<span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h2 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h2><p>在 JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中就包含<code>prototype</code>属性，这个属性指向函数的<code>原型对象</code>。</p>\n<ol>\n<li>原型对象是一个<code>普通对象</code>(除<code>Function.prototype</code>之外)，存储所有实例对象共享的方法和属性；</li>\n<li>构造函数原型对象是<code>构造函数</code>的一个实例。</li>\n<li>原型对象的<code>constructor</code>属性指向<code>prototype</code>属性所在的函数；</li>\n<li>每个对象都有 <code>__proto__</code> 属性，但只有函数对象才有 <code>prototype</code> 属性，这两个属性指向函数的<strong>原型对象</strong>。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">Person.prototype. sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 构造函数、原型对象和实例之间有这样的联系</span></div><div class=\"line\">Person.prototype.constructor === Person;</div><div class=\"line\">person1.__proto__ === Person.prototype;</div><div class=\"line\">person1.constructor === Person;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.constructor === Person);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === Person);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor === person1.constructor);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// =&gt; 原型对象是构造函数的一个实例</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.constructor == Person);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// =&gt; 原型对象的constructor属性指向prototype属性所在的函数</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === Person.prototype);\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// =&gt; __proto__属性指向函数的原型对象</span></div></pre></td></tr></table></figure>\n<p><strong>注：</strong> <code>Function.prototype</code>虽为函数对象，但是是个空函数，没有<code>prototype</code>属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Function</span>.prototype) <span class=\"comment\">// function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">Function</span>.prototype.prototype) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>从上面的分析我们可以知道：JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个<code>__proto__</code>内置属性，用于指向创建它的函数对象的原型对象<code>prototype</code>。</p>\n<p>以上面的例子为例：</p>\n<ol>\n<li><code>person1</code>具有<code>__proto__</code>属性，指向<code>Person.prototype</code></li>\n<li><code>Person.prototype</code>具有<code>__proto__</code>属性，指向<code>Object.prototype</code></li>\n<li><code>Object.prototype</code>具有<code>__proto__</code>属性，指向<code>null</code></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.__proto__ === Person.prototype) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Person.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.__proto__) <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>这些<code>__proto__</code>串起来，就构成了原型链，原型链的顶端为<code>null</code>。绘出原型链图如下：</p>\n<p><img src=\"/images/prototype-chain.png\" alt=\"原型链\"></p>\n<p>简化如下：<br><img src=\"/images/prototype.png\" alt=\"原型链\"></p>\n<p>疑点解释：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype \t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// Object是函数对象，是通过new Function()创建，所以Object.__proto__指向Function.prototype。</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">Function</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype\t\t<span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"comment\">// Function本身也是一个构造函数，所以`Function.prototype.__proto__`指向`Object.prototype`</span></div></pre></td></tr></table></figure>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><blockquote>\n<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: <code>接口继承</code> 和 <code>实现继承</code> 。接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 <code>实现继承</code> 主要是依靠原型链来实现的.</p>\n</blockquote>\n<p>为什么要实现继承呢？</p>\n<p>最重要的原因之一就是为了<code>抽象（复用代码）</code></p>\n<p>将公共的代码封装成一个基类，其他子类继承基类，并发展自己特有的属性和样式。</p>\n<p>关于实现<code>继承</code>的方式，我们将在下一篇文章中进行讨论。</p>\n<hr>\n<p>参考资料：</p>\n<p>《JavaScript 高级程序设计》 第三版</p>\n<p><a href=\"http://www.jianshu.com/p/e241568f8d3f\" target=\"_blank\" rel=\"external\">js原型与原型链终极详解</a></p>\n","categories":["JavaScript"],"tags":["JavaScript","prototype"]},{"title":"JavaScript深入理解 —— 创建对象","url":"http://hysunny.me/2017/09/16/javascript-create-object/","content":"<p>JavaScript中创建对象的方式有很多种，下面对这些方法进行分析和优缺点对比。</p>\n<h2 id=\"Object构造函数\"><a href=\"#Object构造函数\" class=\"headerlink\" title=\"Object构造函数\"></a>Object构造函数</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">person.name = <span class=\"string\">\"Hysunny\"</span>;</div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong> </p>\n<p>使用同一个接口创建很多对象，会产生大量的重复代码。</p>\n<h2 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person = &#123;</div><div class=\"line\">  name: <span class=\"string\">\"Hysunny\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong> </p>\n<p>同Object构造函数。使用同一个接口创建很多对象，会产生大量的重复代码。</p>\n<h3 id=\"Object-create-方式\"><a href=\"#Object-create-方式\" class=\"headerlink\" title=\"Object.create 方式\"></a>Object.create 方式</h3><blockquote>\n<p>Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = &#123;</div><div class=\"line\">  name: <span class=\"string\">\"Hysunny\"</span>,</div><div class=\"line\">  sayName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"built_in\">Object</span>.create(Person);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"built_in\">Object</span>.create(Person);</div><div class=\"line\">&nbsp</div><div class=\"line\">person1.sayName();\t<span class=\"comment\">// \"Hysunny\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);    <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>单例继承，语法简单。</p>\n<p><strong>缺点：</strong></p>\n<p>封装性不好，多实例需要重复初始化过程。</p>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">\"Max\"</span>);</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>实现函数封装，无数次调用，都返回一个对象。</p>\n<p><strong>缺点：</strong></p>\n<p>无法识别对象，因为所有实例的<code>constructor</code>都指向<code>Object</code>。</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><blockquote>\n<p>构造函数：通过<code>new</code>关键字方式调用的函数。</p>\n<p>在构造函数内部（也就是被调用的函数内）：<br><code>this</code> 指向新创建的实例对象 <code>Object</code>；<br>这个新创建的实例对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code>；<br>这个新创建的实例对象的<code>constructor</code>属性指向<code>构造函数</code>；<br>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 —— 也就是实例对象。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName)  <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>通过<code>constructor</code>或者<code>instanceof</code>可以识别对象实例的类别。</p>\n<p><strong>缺点：</strong></p>\n<p>浪费内存。每个方法都要在每个实例上重新创建一遍。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><blockquote>\n<p>原型（prototype）：每个<strong>函数对象</strong>都有一个 <code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。原型对象（Person.prototype）是 构造函数（Person）的一个实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">Person.prototype.name = <span class=\"string\">\"Hysunny\"</span>;</div><div class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">person1.sayName();    <span class=\"comment\">// Hysunny</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">person2.sayName();\t\t<span class=\"comment\">// Hysunny</span></div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName)   <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<ol>\n<li>通过<code>prototype</code>添加的属性和方法所有实例共享</li>\n<li>可以动态的添加原型对象的属性和方法，并直接反映到实例上</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>实例无法重写原型中的值</li>\n<li>访问实例的某个属性时，会先搜索<code>对象实例</code>本身，如果对象实例中具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的<code>原型对象</code>，如果在原型对象中找到该属性，则返回该属性的值。</li>\n</ol>\n<h3 id=\"构造函数和原型的组合模式\"><a href=\"#构造函数和原型的组合模式\" class=\"headerlink\" title=\"构造函数和原型的组合模式\"></a>构造函数和原型的组合模式</h3><blockquote>\n<p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"keyword\">this</span>.friends = [<span class=\"string\">\"Jasper\"</span>, <span class=\"string\">\"Cindy\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">Person.prototype = &#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>: Person,  // 手动将<span class=\"keyword\">constructor</span>指向Person，否则<span class=\"keyword\">constructor</span>将指向Object</div><div class=\"line\">  sayName: function() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Max\"</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\">person1.friends.push(<span class=\"string\">\"Ann\"</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends);  <span class=\"comment\">// [\"Jasper\", \"Cindy\", \"Ann\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person2.friends);   <span class=\"comment\">// [\"Jasper\", \"Cindy\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.friends === person2.friends);   <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(person1.sayName === person2.sayName);   <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>是使用最广泛、认同度最高的一种创建自定义类型的方法。</p>\n<ol>\n<li>每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法引用，最大限度地节省了内存；</li>\n<li>支持向构造函数传递参数。</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<p>缺乏更好的封装性。</p>\n<h3 id=\"动态原型模式\"><a href=\"#动态原型模式\" class=\"headerlink\" title=\"动态原型模式\"></a>动态原型模式</h3><blockquote>\n<p>动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 属性</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  <span class=\"comment\">// 方法</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.sayName !== <span class=\"string\">\"function\"</span>) &#123;</div><div class=\"line\">    Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<ol>\n<li>仅在需要的时候初始化原型，节省内存；</li>\n<li>对原型所做的修改，都能够立即在所有的实例中得到反映。</li>\n</ol>\n<p><strong>缺点：</strong> — —</p>\n<p><strong>注意：</strong></p>\n<p>使用动态原型模式时，不能使用<code>对象字面量</code>重写原型。因为，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</p>\n<h3 id=\"寄生构造模式\"><a href=\"#寄生构造模式\" class=\"headerlink\" title=\"寄生构造模式\"></a>寄生构造模式</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">  o.name = name;</div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();  <span class=\"comment\">// \"Hysunny\"</span></div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>在上面的几种模式都不适用的时候，可以使用该方法。比如：创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，可以使用这个模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SpecialArray</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建数组</span></div><div class=\"line\">  <span class=\"keyword\">var</span> array = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 添加值</span></div><div class=\"line\">  array.push.apply(array, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 添加方法</span></div><div class=\"line\">  array.toPipedString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.join(<span class=\"string\">\" | \"</span>);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 返回数组</span></div><div class=\"line\">  <span class=\"keyword\">return</span> array;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> colors = <span class=\"keyword\">new</span> SpecialArray(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(colors.toPipedString());  <span class=\"comment\">// \"red | blue | green\"</span></div></pre></td></tr></table></figure>\n<p><strong>缺点：</strong></p>\n<p>无法使用<code>instanceof</code>来识别对象所属类型</p>\n<h3 id=\"稳妥构造函数模式\"><a href=\"#稳妥构造函数模式\" class=\"headerlink\" title=\"稳妥构造函数模式\"></a>稳妥构造函数模式</h3><blockquote>\n<p>稳妥对象(durable objects):</p>\n<ol>\n<li>没有公共属性，而且其方法也不引用<code>this</code>的的对象；</li>\n<li>最适合在一些安全的环境中（这些环境中会禁止使用<code>this</code>和<code>new</code>），或者在防止数据被其他应用程序改动时使用。</li>\n</ol>\n<p>稳妥构造函数和寄生构造函数的区别：</p>\n<ol>\n<li>新创建对象的实例方法不引用<code>this</code>；</li>\n<li>不适用<code>new</code>操作符调用构造函数。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建要返回的对象</span></div><div class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 可以在这里定义私有变量和函数</span></div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 添加方法</span></div><div class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(name)</div><div class=\"line\">  &#125;;</div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">// 返回对象</span></div><div class=\"line\">  <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Hysunny\"</span>);</div><div class=\"line\">person.sayName();</div></pre></td></tr></table></figure>\n<p><strong>优点：</strong></p>\n<p>非常适合在某些安全执行环境下使用。</p>\n<p><strong>缺点：</strong></p>\n<p>无法使用<code>instanceof</code>来识别对象所属类型</p>\n<hr>\n<p>参考：</p>\n<p>《JavaScript 高级程序设计》 第三版</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"external\">Object.create()</a></p>\n","categories":["JavaScript"],"tags":["JavaScript","Object"]},{"title":"HTML块级元素、行内元素、可变元素以及空元素总结","url":"http://hysunny.me/2017/09/10/block-inline-element/","content":"<p>在HTML中元素可分为两大基本类型，<code>块级</code>元素(block element)和<code>行内</code>元素(inline element)。</p>\n<h2 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h2><ol>\n<li><p>元素前后带<code>有换行符</code>，此元素总是单独占据一行；</p>\n</li>\n<li><p>宽度缺省是它的容器的100%；</p>\n</li>\n<li><p><code>可以</code>设置width，height属性;(注意：块级元素即使设置了宽度，仍然是独占一行的)；</p>\n</li>\n<li><p>可以设置margin和padding；</p>\n</li>\n<li><p>块级元素<strong>只能</strong>出现在<code>body</code>元素内；</p>\n</li>\n<li><p>一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p>\n</li>\n</ol>\n<h2 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h2><ol>\n<li><p>元素前后<code>没有换行符</code>，和其他元素都在一行上；</p>\n</li>\n<li><p>设置width，height无效。（可以使用css将元素变为块级元素，设置宽高）；</p>\n</li>\n<li><p>宽度就是元素内文字或图片的宽度；</p>\n</li>\n<li><p>行内元素的水平方向的padding-left,padding-right,margin-left,margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果（水平方向有效，竖直方向无效）；</p>\n</li>\n<li><p>行内元素<strong>只能</strong>包含文本或者其他行内元素。</p>\n</li>\n</ol>\n<h2 id=\"可变元素\"><a href=\"#可变元素\" class=\"headerlink\" title=\"可变元素\"></a>可变元素</h2><p>可变元素是根据上下文语境决定该元素为块级元素或者行内元素。</p>\n<h2 id=\"空元素\"><a href=\"#空元素\" class=\"headerlink\" title=\"空元素\"></a>空元素</h2><p>不存在子节点的元素。</p>\n<h2 id=\"附：\"><a href=\"#附：\" class=\"headerlink\" title=\"附：\"></a>附：</h2><h3 id=\"常见的块级元素\"><a href=\"#常见的块级元素\" class=\"headerlink\" title=\"常见的块级元素\"></a>常见的块级元素</h3><ul>\n<li>address - 地址  </li>\n<li>article - 文章内容 （HTML5）</li>\n<li>aside - 伴随内容（HTML5）</li>\n<li>audio - 音频播放（HTML5） </li>\n<li>blockquote - 块引用   </li>\n<li>canvas - 绘制图形 </li>\n<li>dd - 定义列表中定义条目描述</li>\n<li>div - 常用块级容易，也是css layout的主要标签   </li>\n<li>dl - 定义列表   </li>\n<li>fieldset - form控制组   </li>\n<li>form - 交互表单  </li>\n<li>figcaption - 图文信息组标题（HTML5）</li>\n<li>figure - 图文信息组（HTML5），参照 figcaption</li>\n<li>footer - 区段尾或页尾（HTML5）</li>\n<li>h1 - 大标题   </li>\n<li>h2 - 副标题   </li>\n<li>h3 - 3级标题   </li>\n<li>h4 - 4级标题   </li>\n<li>h5 - 5级标题   </li>\n<li>h6 - 6级标题   </li>\n<li>header - 区段头或页头</li>\n<li>hgroup - 标题组</li>\n<li>hr - 水平分隔线   </li>\n<li>noscript - 可选脚本内容（对于不支持script的浏览器显示此内容）   </li>\n<li>menu - 菜单列表   </li>\n<li>noframes - frames可选内容，（对于不支持frame的浏览器显示此区块内容      </li>\n<li>ol - 有序列表</li>\n<li>output - 表单输出（HTML5）</li>\n<li>p - 段落   </li>\n<li>pre - 格式化文本 </li>\n<li>section - 一个页面片段  </li>\n<li>table - 表格   </li>\n<li>tfoot 表脚注</li>\n<li>ul - 非排序列表 </li>\n<li>video - 视频（HTML5）</li>\n</ul>\n<h3 id=\"常见的行内元素\"><a href=\"#常见的行内元素\" class=\"headerlink\" title=\"常见的行内元素\"></a>常见的行内元素</h3><ul>\n<li>a - 锚点   </li>\n<li>abbr - 缩写   </li>\n<li>acronym - 首字 (HTML5 中不支持 <acronym> 标签。请使用  <abbr>  标签代替。)  </abbr></acronym></li>\n<li>b - 粗体(不推荐) </li>\n<li>br - 换行 </li>\n<li>bdo - bidi override   </li>\n<li>big - 大字体   </li>\n<li>br - 换行   </li>\n<li>cite - 引用   </li>\n<li>code - 计算机代码(在引用源码的时候需要)   </li>\n<li>dfn - 定义字段   </li>\n<li>em - 强调   </li>\n<li>font - 字体设定(不推荐)   </li>\n<li>i - 斜体   </li>\n<li>img - 图片   </li>\n<li>input - 输入框   </li>\n<li>kbd - 定义键盘文本   </li>\n<li>label - 表格标签   </li>\n<li>q - 短引用   </li>\n<li>s - 中划线(不推荐)   </li>\n<li>samp - 定义范例计算机代码   </li>\n<li>select - 项目选择   </li>\n<li>small - 小字体文本   </li>\n<li>span - 常用内联容器，定义文本内区块   </li>\n<li>strike - 中划线   </li>\n<li>strong - 粗体强调   </li>\n<li>sub - 下标   </li>\n<li>sup - 上标   </li>\n<li>textarea - 多行文本输入框   </li>\n<li>tt - 电传文本   </li>\n<li>u - 下划线   </li>\n<li>var - 定义变量   </li>\n</ul>\n<h3 id=\"常见的可变元素\"><a href=\"#常见的可变元素\" class=\"headerlink\" title=\"常见的可变元素\"></a>常见的可变元素</h3><ul>\n<li>applet - java applet   </li>\n<li>button - 按钮   </li>\n<li>del - 删除文本   </li>\n<li>iframe - inline frame   </li>\n<li>ins - 插入的文本   </li>\n<li>map - 图片区块(map)   </li>\n<li>object - object对象   </li>\n<li>script - 客户端脚本  </li>\n</ul>\n<h3 id=\"常见的空元素\"><a href=\"#常见的空元素\" class=\"headerlink\" title=\"常见的空元素\"></a>常见的空元素</h3><ul>\n<li>area - 在图片上定义一个热点区域</li>\n<li>base    - 指定用于一个文档中包含的所有相对URL的基本URL。一份中只能有一个<base>元素。</li>\n<li>br - 换行</li>\n<li>col - 表格中的列</li>\n<li>colgroup when the span is present    // 表格列组</li>\n<li>command - 表示一个用户可以调用的命令</li>\n<li>embed - 用于表示一个外部应用或交互式内容的集合点，换句话说，就是一个插件。</li>\n<li>hr - 分隔线</li>\n<li>img    - 图片</li>\n<li>input - 文本框等</li>\n<li>keygen    - 用于 HTML 表单与其他的所需信息一起构造一个证书请求（已废弃）</li>\n<li>link     - 指定了外部资源与当前文档的关系. 常用语引入css文件</li>\n<li>meta    - 表示那些不能由其它HTML元相关元素表示的任何元数据信息.</li>\n<li>param - 定义了 <object>的参数</object></li>\n<li>source    - 具体说明多媒体资源的类型</li>\n<li>track - 被当作媒体元素—<audio> 和 <video>的子元素来使用。</video></audio></li>\n<li>wbr - 一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。</li>\n</ul>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements\" target=\"_blank\" rel=\"external\">块级元素</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente\" target=\"_blank\" rel=\"external\">行内</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%A9%BA%E5%85%83%E7%B4%A0\" target=\"_blank\" rel=\"external\">空元素</a></p>\n","categories":["JavaScript"],"tags":["CSS"]},{"title":"Vue.js 双向数据绑定原理分析","url":"http://hysunny.me/2017/07/02/Vue/two-way-data-binding-in-vuejs/","content":"<p>在使用Vue.js自定义组件时，很多时候，我们都期望数据是双向绑定的。</p>\n<hr>\n<h2 id=\"Vue-js实现双向数据绑定的两种方式\"><a href=\"#Vue-js实现双向数据绑定的两种方式\" class=\"headerlink\" title=\"Vue.js实现双向数据绑定的两种方式\"></a>Vue.js实现双向数据绑定的两种方式</h2><h3 id=\"1-v-model\"><a href=\"#1-v-model\" class=\"headerlink\" title=\"1. v-model\"></a>1. v-model</h3><p>调用组件时：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div><div class=\"line\">或</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:value</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组件内部，必须：</p>\n<ul>\n<li>接受一个 <code>value</code> 属性</li>\n<li>在有新的 value 时触发 <code>input</code> 事件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, newValue)</div></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;comp v-model=<span class=\"string\">\"something\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span></div><div class=\"line\">&nbsp</div><div class=\"line\">&nbsp</div><div class=\"line\">Vue.component(<span class=\"string\">'comp'</span>, &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">  props: [<span class=\"string\">'value'</span>],</div><div class=\"line\">  computed: &#123;</div><div class=\"line\">    currentValue: &#123;</div><div class=\"line\">      get () &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value</div><div class=\"line\">      &#125;,</div><div class=\"line\">      set (val) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'input'</span>, val)</div><div class=\"line\">      &#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;）</div></pre></td></tr></table></figure>\n<h3 id=\"2-props-sync-修饰符\"><a href=\"#2-props-sync-修饰符\" class=\"headerlink\" title=\"2. props  .sync 修饰符\"></a>2. props  .sync 修饰符</h3><p>调用组件时：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">:foo.sync</span>=<span class=\"string\">\"bar\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在组件内部，</p>\n<ul>\n<li>接受一个 <code>foo</code> 属性</li>\n<li>需要更新 <code>foo</code> 时，它需要显式地触发一个更新事件</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, newValue)</div></pre></td></tr></table></figure>\n<p>如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;comp :foo.sync=<span class=\"string\">\"bar\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></span></div><div class=\"line\">&nbsp</div><div class=\"line\">Vue.component(<span class=\"string\">'comp'</span>, &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">  props: [<span class=\"string\">'foo'</span>],</div><div class=\"line\">  data () &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      currentValue: <span class=\"keyword\">this</span>.foo</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  watch: &#123;</div><div class=\"line\">    currentValue (val, oldVal) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.$emit(<span class=\"string\">'update:foo'</span>, val)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;）</div></pre></td></tr></table></figure>\n<h2 id=\"Vue实现双向数据绑定的原理分析\"><a href=\"#Vue实现双向数据绑定的原理分析\" class=\"headerlink\" title=\"Vue实现双向数据绑定的原理分析\"></a>Vue实现双向数据绑定的原理分析</h2><p><code>v-model</code> 用于双向绑定数据，其本质为语法糖，即</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"something\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">comp</span> <span class=\"attr\">v-bind:value</span>=<span class=\"string\">\"something\"</span> <span class=\"attr\">v-on:input</span>=<span class=\"string\">\"something = $event.target.value\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">comp</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>props  <code>.sync</code> 修饰符 用于双向数据绑定，其本质也为语法糖，即</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"keyword\">comp</span> :foo.<span class=\"keyword\">sync</span>=<span class=\"string\">\"bar\"</span>&gt;&lt;/<span class=\"keyword\">comp</span>&gt;</div></pre></td></tr></table></figure>\n<p>相当于</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;comp <span class=\"symbol\">:foo=<span class=\"string\">\"bar\"</span></span> <span class=\"variable\">@update</span><span class=\"symbol\">:foo=<span class=\"string\">\"val =&gt; bar = val\"</span>&gt;&lt;/comp&gt;</span></div></pre></td></tr></table></figure>\n<p>以上，我们可以很容易的看出，实现一个自定义组件的双向数据绑定，其实就是父组件传递一个属性给子组件，在子组件中该属性的值改变时显式的去触发一个事件（v-model触发input事件，.sync触发update:props事件）。</p>\n<p>那在Vue.js内部究竟是如何实现双向数据绑定的呢？我们下面继续分析下。</p>\n<p>在Vue.js中，采用观察者-订阅者模式来进行双向数据绑定，通过<code>Object.defineProperty()</code>方法来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>既然是观察者-订阅者模式，那观察者-订阅者是如何实现的呢？我们来看源码</p>\n<p>观察者(Observer)关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observer</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span> (data) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.walk(data)</div><div class=\"line\">  &#125;</div><div class=\"line\">  walk (data) &#123;</div><div class=\"line\">    <span class=\"comment\">// 遍历 data 对象属性，调用 defineReactive 方法</span></div><div class=\"line\">    <span class=\"keyword\">let</span> keys = <span class=\"built_in\">Object</span>.keys(data)</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++)&#123;</div><div class=\"line\">      defineReactive(data, keys[i], data[keys[i]])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>订阅者（Watcher）关键代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Watcher</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(vm, expOrFn, cb) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cb = cb</div><div class=\"line\">    <span class=\"keyword\">this</span>.vm = vm</div><div class=\"line\">    <span class=\"keyword\">this</span>.expOrFn = expOrFn</div><div class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">  &#125;</div><div class=\"line\">  update()&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.run()</div><div class=\"line\">  &#125;</div><div class=\"line\">  run()&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span>  value = <span class=\"keyword\">this</span>.get()</div><div class=\"line\">    <span class=\"keyword\">if</span>(value !==<span class=\"keyword\">this</span>.value)&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.value = value</div><div class=\"line\">      <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  get()&#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.vm._data[<span class=\"keyword\">this</span>.expOrFn]</div><div class=\"line\">    <span class=\"keyword\">return</span> value</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>观察者和订阅者都有了，但是它们如何进行通信呢？</p>\n<p>首先，<br>观察者会遍历 data 对象的所有属性，每个属性通过调用 <code>defineReactive</code> 方法，转换为getter/setter</p>\n<p>defineReactive 关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep()</div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">    enumerable: <span class=\"literal\">true</span>,</div><div class=\"line\">    configurable: <span class=\"literal\">true</span>,</div><div class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveGetter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</div><div class=\"line\">        dep.depend()  <span class=\"comment\">// 依赖收集</span></div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> value</div><div class=\"line\">    &#125;,</div><div class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reactiveSetter</span>(<span class=\"params\">newVal</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (value === newVal) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">      &#125; </div><div class=\"line\">      value = newVal</div><div class=\"line\">      <span class=\"comment\">// 对新值进行观测，如果改变则通知订阅者</span></div><div class=\"line\">      dep.notify()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>defineReactive 方法将data的属性转换为访问器属性<br>get时进行依赖收集，<br>set时，如果数据有改变，则进行订阅通知</p>\n<p>通过上面的分析，我们知道了，观察者观测到数据更新时会通知订阅者，但是它是如何通知订阅者（Watcher）的呢？</p>\n<p>当然是通过订阅器了！</p>\n<p>订阅器(Dep)关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dep</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span> (id, subs) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.id = <span class=\"number\">0</span>++</div><div class=\"line\">    <span class=\"keyword\">this</span>.subs = []</div><div class=\"line\">  &#125;</div><div class=\"line\">  addSub () &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</div><div class=\"line\">  &#125;</div><div class=\"line\">  removeSub () &#123;</div><div class=\"line\">    remove(<span class=\"keyword\">this</span>.subs, sub)</div><div class=\"line\">  &#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">  depend () &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Dep.target) &#123;</div><div class=\"line\">      Dep.target.addDep(<span class=\"keyword\">this</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&nbsp</div><div class=\"line\">  notify () &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> subs = <span class=\"keyword\">this</span>.subs.slice()</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = subs.length; i &lt; l; i++) &#123;</div><div class=\"line\">        subs[i].update()</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过订阅器，订阅者接收到数据改变的通知</p>\n<p>由此，<code>Observer</code> 、 <code>Dep</code>、 <code>Watcher</code> 就形成了一个数据响应系统，也就是Vue.js实现双向数据绑定最核心的原理。</p>\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"在Node端使用Mocha + Chai + SuperTest测试Restful API","url":"http://hysunny.me/2016/12/25/tools/mocha-test/","content":"<h1 id=\"在Node端使用Mocha-Chai-SuperTest测试Restful-API\"><a href=\"#在Node端使用Mocha-Chai-SuperTest测试Restful-API\" class=\"headerlink\" title=\"在Node端使用Mocha + Chai + SuperTest测试Restful API\"></a>在Node端使用Mocha + Chai + SuperTest测试Restful API</h1><h2 id=\"1-为什么要进行接口测试？\"><a href=\"#1-为什么要进行接口测试？\" class=\"headerlink\" title=\"1. 为什么要进行接口测试？\"></a>1. 为什么要进行接口测试？</h2><ol>\n<li>前后端<code>分离开发</code>,无法实时确保接口编写无误</li>\n<li>手工测试<code>费时费力</code>，无法确保覆盖率</li>\n<li>接口测试不同于传统开发的单元测试，接口测试是站在<code>用户的角度</code>对系统接口进行全面高效持续的检测</li>\n<li>接口测试是<code>自动化</code>并且<code>持续集成</code>，低成本、高收益</li>\n</ol>\n<h2 id=\"2-接口测试方案的选择\"><a href=\"#2-接口测试方案的选择\" class=\"headerlink\" title=\"2. 接口测试方案的选择\"></a>2. 接口测试方案的选择</h2><p><img src=\"/images/mocha-test/scheme.png\" alt=\"scheme\"></p>\n<p>如上图，接口测试方案一般由 <strong>测试框架 + 断言库 + HTTP请求库</strong> 组成。</p>\n<p>这里，我们选用Mocha + Chai + SuperTest来进行Node端Restful API测试。选用理由如下：</p>\n<p><code>测试框架</code>选用<strong>Mocha</strong>的理由：Mocha 既可以在 node.js 环境中运行，也可以运行在浏览器中。与其它的 javascript 测试框架比较起来，我们发现 Mocha 对于异步测试的处理是我们选择它的关键因素。</p>\n<p><code>断言库</code>选择<strong>Chai</strong>的理由： 尽管 Mocha 可以与任意的断言库一起使用，Chai 也可以被任意的测试库所使用，但是许多 JavaScript 开发者还是选择将两者搭配使用。</p>\n<p><code>HTTP请求库</code>选择<strong>SuperTest</strong>的理由：SuperTest除了可以测试 JSON 对象的内容外，还可以测验终端响应的其它数据，包括头信息类型和响应状态码。SuperTest 还有一个漂亮直观的接口，只需要简单地将接口终端需要的数据发送过去，就可以检验响应。</p>\n<h2 id=\"3-测试方案技术栈简介\"><a href=\"#3-测试方案技术栈简介\" class=\"headerlink\" title=\"3. 测试方案技术栈简介\"></a>3. 测试方案技术栈简介</h2><h3 id=\"1-Mocha\"><a href=\"#1-Mocha\" class=\"headerlink\" title=\"1. Mocha\"></a>1. Mocha</h3><p>诞生于2011年，是现在最流行的JavaScript测试框架之一，在浏览器和Node环境都可以使用。支持BDD、TDD、QUnit、Exports式的测试。</p>\n<p>优点：</p>\n<ul>\n<li>好用、易上手</li>\n<li>与nodejs结合更自然</li>\n<li>可使用多种风格的DSL，比如should/expect等</li>\n<li>良好的支持javascript异步的单元测试</li>\n<li>支持before,after,beforeEach,afterEach钩子</li>\n</ul>\n<p>使用示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 安装</div><div class=\"line\">$ npm install mocha</div><div class=\"line\">&nbsp</div><div class=\"line\">// <span class=\"keyword\">add</span>.<span class=\"bash\">js</span></div><div class=\"line\"><span class=\"bash\"><span class=\"keyword\">function</span> add(x, y) &#123;</span></div><div class=\"line\"><span class=\"bash\">    <span class=\"built_in\">return</span> x + y;</span></div><div class=\"line\"><span class=\"bash\">&#125;</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">module.exports = add;</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">// add.test.js</span></div><div class=\"line\"><span class=\"bash\">var add = require(<span class=\"string\">'./add.js'</span>);</span></div><div class=\"line\"><span class=\"bash\">var assert = require(<span class=\"string\">'chai'</span>).assert;</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">describe(<span class=\"string\">'加法函数测试'</span>, <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span></div><div class=\"line\"><span class=\"bash\">    it(<span class=\"string\">'1 加 1 应该等于 2'</span>), <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span></div><div class=\"line\"><span class=\"bash\">        assert.equal(add(1,1), 2);</span></div><div class=\"line\"><span class=\"bash\">    &#125;</span></div><div class=\"line\"><span class=\"bash\">&#125;)</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">// 执行测试命令</span></div><div class=\"line\"><span class=\"bash\">$ mocha add.test.js</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">  加法函数的测试</span></div><div class=\"line\"><span class=\"bash\">    ✓ 1 加 1 应该等于 2</span></div><div class=\"line\"><span class=\"bash\"></span></div><div class=\"line\"><span class=\"bash\">  1 passing (8ms)</span></div></pre></td></tr></table></figure>\n<p>具体请查看：<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">https://mochajs.org/</a></p>\n<h3 id=\"2-Chai\"><a href=\"#2-Chai\" class=\"headerlink\" title=\"2. Chai\"></a>2. Chai</h3><p>Chai是一个断言库。</p>\n<p>提供两种类型的断言风格：TDD（测试驱动开发）和BDD（行为驱动）。</p>\n<p>expect/should API 对应BDD风格，Assert API 对应TDD风格。</p>\n<p>优点：</p>\n<ul>\n<li>BDD/TDD 双模 ，同时支持 should / expect / assert 三种风格的断言库</li>\n<li>强大插件机制</li>\n<li>chai-webdriver, 可模拟UI界面测试</li>\n<li>Github上的数据3647 star, 335 fork (截止到2016-12-25)</li>\n</ul>\n<p>使用示例：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ npm install chai</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"keyword\">var</span> chai = require(‘chai');</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">assert</span> = chai.<span class=\"keyword\">assert</span>;</div><div class=\"line\"><span class=\"keyword\">assert</span>.lengthOf(foo, 3)</div></pre></td></tr></table></figure>\n<p>具体请查看：<a href=\"http://chaijs.com/api/assert/\" target=\"_blank\" rel=\"external\">http://chaijs.com/api/assert/</a></p>\n<h3 id=\"3-SuperTest\"><a href=\"#3-SuperTest\" class=\"headerlink\" title=\"3. SuperTest\"></a>3. SuperTest</h3><p>基于SuperAgent，是一个轻量级的HTTP Ajax 请求库。</p>\n<p>提供对HTTP测试的高度抽象。</p>\n<p>所谓高度抽象的意思是：能嵌入各类测试框架，提供语义良好的断言。</p>\n<p>使用示例：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 安装</span></div><div class=\"line\">$ npm install supertest --save-dev</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 引入依赖库</span></div><div class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> app = express();</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// HTTP请求代码（被测试）</span></div><div class=\"line\">app.get(<span class=\"string\">'/user'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">  res.status(<span class=\"number\">200</span>).json(&#123; <span class=\"attribute\">name</span>: <span class=\"string\">'tobi'</span> &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// \tHTTP请求测试代码</span></div><div class=\"line\">request(app)</div><div class=\"line\">  .get(<span class=\"string\">'/user'</span>)</div><div class=\"line\">  .expect(<span class=\"string\">'Content-Type'</span>, <span class=\"regexp\">/json/</span>)</div><div class=\"line\">  .expect(<span class=\"string\">'Content-Length'</span>, <span class=\"string\">'15'</span>)</div><div class=\"line\">  .expect(<span class=\"number\">200</span>)</div><div class=\"line\">  .end(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<p>具体请查看：<a href=\"https://www.npmjs.com/package/supertest\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/supertest</a></p>\n<h2 id=\"4-如何进行接口测试\"><a href=\"#4-如何进行接口测试\" class=\"headerlink\" title=\"4. 如何进行接口测试\"></a>4. 如何进行接口测试</h2><h3 id=\"一、-环境安装\"><a href=\"#一、-环境安装\" class=\"headerlink\" title=\"一、 环境安装\"></a>一、 环境安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 使用 npm 安装 Mocha</div><div class=\"line\">$ npm install mocha</div><div class=\"line\">&nbsp</div><div class=\"line\">// 使用npm安装Chai</div><div class=\"line\">$ npm install chai</div><div class=\"line\">&nbsp</div><div class=\"line\">// 使用npm安装SuperTest</div><div class=\"line\">$ npm install supertest</div><div class=\"line\">&nbsp</div><div class=\"line\">// 使用npm安装Express</div><div class=\"line\">$ npm install express</div></pre></td></tr></table></figure>\n<h3 id=\"二、-设置测试目录\"><a href=\"#二、-设置测试目录\" class=\"headerlink\" title=\"二、 设置测试目录\"></a>二、 设置测试目录</h3><p>使用你的终端，进入项目根目录，执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mkdir <span class=\"built_in\">test</span></span></div></pre></td></tr></table></figure>\n<p>新建一个测试目录（注：目录名必须为test）,如下图：</p>\n<p><img src=\"/images/mocha-test/dir.png\" alt=\"\"></p>\n<h3 id=\"三、-创建测试文件\"><a href=\"#三、-创建测试文件\" class=\"headerlink\" title=\"三、 创建测试文件\"></a>三、 创建测试文件</h3><p>如：test.js</p>\n<h3 id=\"四、-引入依赖库\"><a href=\"#四、-引入依赖库\" class=\"headerlink\" title=\"四、 引入依赖库\"></a>四、 引入依赖库</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">var express</span> = require(<span class=\"string\">'express'</span>);</div><div class=\"line\"><span class=\"attribute\">var request</span> = require(<span class=\"string\">'supertest'</span>);</div><div class=\"line\"><span class=\"attribute\">var chai</span> = require(<span class=\"string\">'chai'</span>);</div><div class=\"line\"><span class=\"attribute\">var assert</span> = chai.assert;</div></pre></td></tr></table></figure>\n<h3 id=\"五、编写测试用例\"><a href=\"#五、编写测试用例\" class=\"headerlink\" title=\"五、编写测试用例\"></a>五、编写测试用例</h3><h3 id=\"六、在package-json中添加test-scrpt\"><a href=\"#六、在package-json中添加test-scrpt\" class=\"headerlink\" title=\"六、在package.json中添加test scrpt\"></a>六、在package.json中添加test scrpt</h3><figure class=\"highlight xquery\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"test\"</span>: <span class=\"string\">\"mocha\"</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"七、测试\"><a href=\"#七、测试\" class=\"headerlink\" title=\"七、测试\"></a>七、测试</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> npm <span class=\"built_in\">test</span></span></div></pre></td></tr></table></figure>\n<h2 id=\"5-举例\"><a href=\"#5-举例\" class=\"headerlink\" title=\"5. 举例\"></a>5. 举例</h2><h3 id=\"（1）-GET-简单断言\"><a href=\"#（1）-GET-简单断言\" class=\"headerlink\" title=\"（1） GET + 简单断言\"></a>（1） GET + 简单断言</h3><p>被测代码：</p>\n<p><img src=\"/images/mocha-test/tested-1.png\" alt=\"\"></p>\n<p>测试代码：</p>\n<p><img src=\"/images/mocha-test/test1.png\" alt=\"\"></p>\n<p>测试结果：</p>\n<p><img src=\"/images/mocha-test/test1-result.png\" alt=\"\"></p>\n<h3 id=\"2-POST-简单断言\"><a href=\"#2-POST-简单断言\" class=\"headerlink\" title=\"(2) POST + 简单断言\"></a>(2) POST + 简单断言</h3><p>被测代码：</p>\n<p><img src=\"/images/mocha-test/tested-2.png\" alt=\"\"></p>\n<p>测试代码：</p>\n<p><img src=\"/images/mocha-test/test2.png\" alt=\"\"></p>\n<p>测试结果：</p>\n<p><img src=\"/images/mocha-test/test2-result.png\" alt=\"\"></p>\n<h3 id=\"3-钩子\"><a href=\"#3-钩子\" class=\"headerlink\" title=\"(3) 钩子\"></a>(3) 钩子</h3><p>有时候在集成测试中，你需要先创建一些记录然后再使用这些数据。只需要加入一个 before 方法你就可以很容易地达到这个目的。</p>\n<p>除了 before 这个钩子外，mocha 还提供了 after，afterEach 和 beforeEach 这些钩子。</p>\n<p><img src=\"/images/mocha-test/gouzi.png\" alt=\"\"></p>\n<p>这里以一个delete project的功能为例：</p>\n<p>被测代码：</p>\n<p><img src=\"/images/mocha-test/tested-3.png\" alt=\"\"></p>\n<p>测试代码：</p>\n<p><img src=\"/images/mocha-test/test3.png\" alt=\"\"></p>\n<p>测试结果：</p>\n<p><img src=\"/images/mocha-test/test3-result.png\" alt=\"\"></p>\n<p>经过三个测试小例子，相信你对使用Mocha + Chai + SuperTest进行Node端的Restful API测试一定有所了解了，但是这里只是展示了最基础的HTTP接口测试，像是Mocha还有一些 <strong>Pending Tests （挂起测试</strong>、<strong>Exclusive Tests （排它测试）</strong>、<strong>Inclusive Tests（包含测试）</strong>等测试方法。大家有兴趣的话，可以自己研究下~ ^_^~</p>\n<h2 id=\"6-代码覆盖率\"><a href=\"#6-代码覆盖率\" class=\"headerlink\" title=\"6. 代码覆盖率\"></a>6. 代码覆盖率</h2><p>最后，介绍一个在测试代码质量中一个很重要的指标 —— <strong>代码覆盖率</strong>。</p>\n<ul>\n<li>首先，它是代码质量保障中重要的一环。代码覆盖率的分析能在一定程度上评判代码质量，一般覆盖率高的代码出错的几率会相对低一些;</li>\n<li>其次，代码覆盖率测试可以帮助开发人员定位bug路径;</li>\n<li>然后，高覆盖率的代码让开发人员心里有底，是产品的保护伞;</li>\n<li>最后，通过分析代码覆盖率报告，开发人员可以优化代码质量，比如找到一些dead code，废弃的功能等。</li>\n</ul>\n<p>我们在上面基于Mocha + Chai + SuperTest的测试方案中加入<strong><a href=\"https://github.com/gotwarlost/istanbul\" target=\"_blank\" rel=\"external\">istanbul</a></strong> 来测试代码覆盖率</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 安装</span></div><div class=\"line\"><span class=\"symbol\">$</span> npm install istanbul</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"comment\">// 修改test script</span></div><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">  <span class=\"string\">\"test\"</span>: <span class=\"string\">\"istanbul cover node_modules/mocha/bin/_mocha\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>执行 $ npm test命令后，我们可以看到前面三个测试代码覆盖率，如下图：</p>\n<p><img src=\"/images/mocha-test/covery.png\" alt=\"\"></p>\n<p>图中的四个指标分别代表：</p>\n<ul>\n<li>Statement ( 语句覆盖率 )：是否每个语句都执行了？</li>\n<li>Branch（分支覆盖率）：是否每个if代码块都执行了？</li>\n<li>Function（函数覆盖率）： 是否每个函数都调用了？</li>\n<li>Lines（行覆盖率） ： 是否每一行都执行了？</li>\n</ul>\n<p>通过代码覆盖率测试，我们可以看到上面3个测试例子的覆盖率还是很低的，很多代码逻辑都没有执行到。</p>\n<h2 id=\"7-参考链接\"><a href=\"#7-参考链接\" class=\"headerlink\" title=\"7. 参考链接\"></a>7. 参考链接</h2><ul>\n<li><a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">Mocha官网</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"external\">Mocha简单教程</a></li>\n<li><a href=\"http://chaijs.com/api/assert/\" target=\"_blank\" rel=\"external\">Chai官网</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"external\">前端测试断言库选型</a></li>\n<li><a href=\"http://www.cnblogs.com/ustbwuyi/archive/2012/10/26/2741223.html\" target=\"_blank\" rel=\"external\">TDD和BDD风格区别</a></li>\n<li><a href=\"https://www.npmjs.com/package/supertest\" target=\"_blank\" rel=\"external\">Supertest</a></li>\n<li><a href=\"https://github.com/mhevery/jasmine-node\" target=\"_blank\" rel=\"external\">Jasmine-node</a></li>\n<li><a href=\"https://testerhome.com/topics/5219\" target=\"_blank\" rel=\"external\">动化测试工具 测试开发之路—-代码覆盖率 (EMMA)</a></li>\n</ul>\n<p>到这里，Node端基于Mocha + Chai + SuperTest的测试方案介绍就结束了，希望大家看了能有所收获~</p>\n","categories":["工具"],"tags":["test"]},{"title":"overflow:auto/scroll在ios7及以下失效的解决方法","url":"http://hysunny.me/2015/12/12/the-solution-of-overflow-auto-or-scroll-not-work-under-ios7/","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbodycontainer\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbody\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#mbodycontainer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">  <span class=\"attribute\">overflow</span>: auto;</div><div class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden; </div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-id\">#mbody</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上代码。</p>\n<p>当mbody内容溢出时，在安卓设备及iphone6、iphone6 plus上，浏览器会自动显示滚动条以便查看剩余的内容，<code>overflow:auto;</code>正常起作用。</p>\n<p>而在iphone5S及以下ios设备上（后发现是ios7系统及以下设备上）<code>overflow:auto;</code>失效，滚动条无法滚动，相当于<code>overflow:hidden;</code></p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>给父元素设置 <code>-webkit-overflow-scrolling: touch;</code></p>\n<p>即代码变成如下这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbodycontainer\"</span> &gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mbody\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#mbodycontainer</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">  <span class=\"attribute\">overflow</span>: auto;</div><div class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden; </div><div class=\"line\">  <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-id\">#mbody</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute; </div><div class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>; </div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">min-height</span>: <span class=\"number\">100%</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>问题解决！在iphone5S及以下ios设备上overflow:auto;表现正常，可以滚动！</p>\n<hr>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/8bb161beb05be8383975af4c8fc534a2.html\" target=\"_blank\" rel=\"external\">overflow:auto/scroll在ios7及以下失效的解决方法</a>，现迁移至此。</p>\n","categories":["解决方案"],"tags":["JavaScript"]},{"title":"href=\"#\",javascript:;与javascript:void(0)的区别","url":"http://hysunny.me/2015/12/05/the-difference-between-empty-link-ways/","content":"<p>项目中，我们经常会使用<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>标签来代替<code>&lt;input type=&quot;button&quot; /&gt;</code></p>\n<p>这种情况下,很多时候href并不指定超链接目标的URL，而是使用<code>href=&quot;#&quot;</code>, <code>javascript:;</code>与<code>javascript:void(0)</code>。</p>\n<p>那它们有什么区别呢？</p>\n<p>现在就来总结一下~</p>\n<hr>\n<h2 id=\"1-href-”-”\"><a href=\"#1-href-”-”\" class=\"headerlink\" title=\"1. href=”#”\"></a>1. href=”#”</h2><p>一个#表示锚点，默认为#top，点击之后会自动跳转到页面的顶部。</p>\n<p>缺点：当快速点击此链接时会导致浏览器很慢甚至崩溃。</p>\n<p>使用###（href=”###”）效果和javascript:void(0)一样，不会跳转到页面顶部。</p>\n<h2 id=\"2-javascript\"><a href=\"#2-javascript\" class=\"headerlink\" title=\"2. javascript:;\"></a>2. javascript:;</h2><p>javascript:;”直接返回undefined。</p>\n<h2 id=\"3-javascript-void-0\"><a href=\"#3-javascript-void-0\" class=\"headerlink\" title=\"3. javascript:void(0)\"></a>3. javascript:void(0)</h2><p>void是一个操作符，这个操作符指定要计算一个表达式但是不返回值。如果在void中写入0（void(0)）, 则要去执行一次表达式“0”，然后返回undefined</p>\n<hr>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/e29158a787f793eedbb00929dd77b2be.html\" target=\"_blank\" rel=\"external\">href=”#”,javascript:;与javascript:void(0)的区别</a>，现迁移至此。</p>\n","categories":["HTML"],"tags":["HTML"]},{"title":"DIV + CSS 自适应布局","url":"http://hysunny.me/2015/09/24/div-css-adaptive-layout/","content":"<p>昨天面试时被问到一个布局的问题：<br>   <code>两栏布局，左边定宽200px，右边自适应。如何实现？</code><br>我的第一个反应就是：用flex伸缩盒呀，然后balabala…<br>说完之后，面试官说，还有没有别的方法？flex有些浏览器不支持<br>嗯…我愣了一下，平常遇到这种问题貌似都是这么写的…<br>别的方法？我又想了想。JS?对，JS肯定可以。<br>然后就说，可以用JS获取当前窗口宽度，然后减去200px就是右边的宽度了<br>面试官：嗯，这样的确可以，但是布局一般不要用JS，还有没有别的方法？CSS的<br>额，这下我完全愣住了好嘛，人也变得有些紧张。还要别的方法啊，什么方法呢？？？<br>哎呀妈呀，想不出来，肿么办…<br>然后面试官看了我半天，十分体谅的说，那我们进行下一个问题吧…</p>\n<p>回来后，经过百度，哇！原来方法如此之多~还如此简单~<br>下面就来总结一下~</p>\n<hr>\n<h2 id=\"一-两栏布局（左定宽，右自动）\"><a href=\"#一-两栏布局（左定宽，右自动）\" class=\"headerlink\" title=\"一. 两栏布局（左定宽，右自动）\"></a>一. 两栏布局（左定宽，右自动）</h2><h3 id=\"1-float-margin\"><a href=\"#1-float-margin\" class=\"headerlink\" title=\"1. float + margin\"></a>1. float + margin</h3><p>即固定宽度元素设置float属性为left，自适应元素设置margin属性，margin-left应 <code>&gt;=</code> 定宽元素宽度</p>\n<p>举例：</p>\n<p>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注</strong>：使用的float属性，必要时清除一下浮动。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-margin-2.html\" target=\"_blank\">float + margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"2-position-margin\"><a href=\"#2-position-margin\" class=\"headerlink\" title=\"2. position + margin\"></a>2. position + margin</h3><p>即在父标签设置position属性为relative；子标签中定宽元素设置position属性为absolute；自适应元素设置margin属性，margin-left <code>&gt;=</code> 定宽元素宽度。</p>\n<p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/position-margin-2.html\" target=\"_blank\">position + margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"3-float-负margin\"><a href=\"#3-float-负margin\" class=\"headerlink\" title=\"3. float + 负margin\"></a>3. float + 负margin</h3><p>即给自适应宽度元素定义一个父标签，并设置float属性为left；width为100%；自适应宽度元素设置margin，margin-left应 <code>&gt;=</code> 定宽元素宽度；<br>固定宽度元素设置margin-left属性为<code>负值</code>：-100%；<br>除此之外应注意HTML结构中应先写自适应元素，再写固定宽度元素。</p>\n<p>举例：</p>\n<p>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">        我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span> <span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>注</strong>：使用的float属性，必要时清除一下浮动。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-negative-margin-2.html\" target=\"_blank\">float + 负margin实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"4-用table布局实现\"><a href=\"#4-用table布局实现\" class=\"headerlink\" title=\"4. 用table布局实现\"></a>4. 用table布局实现</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"green\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>不过这个方法，一定要设置高度才可以~</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/table-2.html\" target=\"_blank\">table实现左定宽，右自动的两栏布局</a></p>\n<h3 id=\"5-触发BFC实现\"><a href=\"#5-触发BFC实现\" class=\"headerlink\" title=\"5. 触发BFC实现\"></a>5. 触发BFC实现</h3><p>关于BFC是什么、怎么触发BFC以及BFC可以用来做什么，大家可以看看这篇，<a href=\"http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html\" target=\"_blank\">前端精选文摘：BFC 神奇背后的原理</a></p>\n<p>实现方法，即为定宽元素设置float:left;自适应宽度元素设置可以触发BFC的属性。</p>\n<p>举例：<br>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">  我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">  我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码：<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/BFC-2.html\" target=\"_blank\">BFC实现左定宽，右自动的两栏布局</a></p>\n<p>前面有说到一般我都是用的flex伸缩盒，那也来说一下用flex怎么实现的吧</p>\n<h3 id=\"6-flex伸缩盒方法\"><a href=\"#6-flex伸缩盒方法\" class=\"headerlink\" title=\"6. flex伸缩盒方法\"></a>6. flex伸缩盒方法</h3><p>即父标签设置<code>display:flex</code>属性，自适应元素设置<code>flex-grow:1</code>;</p>\n<p>举例：</p>\n<p>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;\t\t</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;\t</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">-webkit-flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/flex-2.html\" target=\"_blank\">flex实现左定宽，右自动的两栏布局</a></p>\n<h2 id=\"二、三栏布局（两侧定宽，中间自适应）\"><a href=\"#二、三栏布局（两侧定宽，中间自适应）\" class=\"headerlink\" title=\"二、三栏布局（两侧定宽，中间自适应）\"></a>二、三栏布局（两侧定宽，中间自适应）</h2><p>掌握了上面的方法，我们会发现制作一个三栏布局也是非常容易的。<br>下面我们在上面栗子的基础上，看看实现一个两侧定宽，中间自适应的三栏布局如何实现</p>\n<h3 id=\"1-float-margin-1\"><a href=\"#1-float-margin-1\" class=\"headerlink\" title=\"1. float + margin\"></a>1. float + margin</h3><p>举例：</p>\n<p>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">  我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">  我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">  我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>: right;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-margin-3.html\" target=\"_blank\">float + margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"2-position-margin-1\"><a href=\"#2-position-margin-1\" class=\"headerlink\" title=\"2. position + margin\"></a>2. position + margin</h3><p>举例： </p>\n<p>HTML代码：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">  我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">  我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">  我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/position-margin-3.html\" target=\"_blank\">position + margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"3-float-负margin-1\"><a href=\"#3-float-负margin-1\" class=\"headerlink\" title=\"3. float + 负margin\"></a>3. float + 负margin</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">    我是中间栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">  我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">  我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&nbsp</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-right</span>: <span class=\"number\">220px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: -<span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/float-negative-margin-3.html\" target=\"_blank\">float + 负margin实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"4-table实现\"><a href=\"#4-table实现\" class=\"headerlink\" title=\"4. table实现\"></a>4. table实现</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100%\"</span> <span class=\"attr\">cellspacing</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">cellpadding</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"300\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"red\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"yellow\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">width</span>=<span class=\"string\">\"200\"</span> <span class=\"attr\">bgcolor</span>=<span class=\"string\">\"green\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/table-3.html\" target=\"_blank\">table实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"5-BFC方法\"><a href=\"#5-BFC方法\" class=\"headerlink\" title=\"5. BFC方法\"></a>5. BFC方法</h3><p>举例：<br>HTML代码<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">  我是左栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">  我是右栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">  我是中间栏</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>CSS代码<br><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&nbsp</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: left;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">float</span>: right;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：HTML中先写定宽元素，再写自适应宽度元素。</p>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/BFC-3.html\" target=\"_blank\">BFC实现两侧定宽，中间自适应的三栏布局</a></p>\n<h3 id=\"6-flex伸缩盒方法-1\"><a href=\"#6-flex伸缩盒方法-1\" class=\"headerlink\" title=\"6. flex伸缩盒方法\"></a>6. flex伸缩盒方法</h3><p>即父标签设置display:flex属性，自适应元素设置flex-grow:1;<br>HTML代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_left\"</span>&gt;</span></div><div class=\"line\">    我是左栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></div><div class=\"line\">    我是中间栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrap_right\"</span>&gt;</span></div><div class=\"line\">    我是右栏</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>,<span class=\"selector-tag\">body</span>,<span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">  <span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_left</span>&#123;\t\t</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_right</span>&#123;\t</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrap_content</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">-webkit-flex-grow</span>:<span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Demo效果预览：<a href=\"/demo/div-css-adaptive-layout/flex-3.html\" target=\"_blank\">flex实现两侧定宽，中间自适应的三栏布局</a></p>\n<p>哦可~</p>\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS position 属性总结","url":"http://hysunny.me/2015/08/25/css-position/","content":"<p>CSS的position总是属性很容易让人弄混~</p>\n<p>为了仔细区别它们，所以今天总结一下CSS的position属性~</p>\n<p>下面是总结内容~</p>\n<p>有疏漏、错误之处敬请指出！~o(^▽^)o~</p>\n<hr>\n<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><p><strong>定义</strong>：position属性规定元素的定位类型。</p>\n<p><strong>说明</strong>：这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对定位或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在正常流中的默认位置偏移。</p>\n<p><strong>默认值</strong>：static</p>\n<p><strong>继承性</strong>：no</p>\n<p><strong>形式语法</strong>：static | relative | absolute | sticky | fixed</p>\n<p><strong>JavaScript语法</strong>：object.style.position = “absolute”</p>\n<p><strong>浏览器支持</strong>：所有主流浏览器都支持position属性。但：任何版本的Internet Explorer(包括IE8)都不支持属性值“inhert”。</p>\n<h2 id=\"二、取值\"><a href=\"#二、取值\" class=\"headerlink\" title=\"二、取值\"></a>二、取值</h2><table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static</td>\n<td>默认值，<code>没有定位</code>。元素出现在正常的流中。（忽略top、right、bottom、left和z-index属性）</td>\n</tr>\n<tr>\n<td>relative</td>\n<td>生成<code>相对定位</code>的元素，相对于其正常位置进行定位。</td>\n</tr>\n<tr>\n<td>absolute</td>\n<td>生成<code>绝对定位</code>的元素，相对于最近的非static父元素进行定位。绝对定位的元素可以设置外边距（margin），且不会与其他他边距合并。</td>\n</tr>\n<tr>\n<td>fixed</td>\n<td>生成<code>绝对定位</code>的元素，相对于浏览器窗口(viewport)进行定位。</td>\n</tr>\n<tr>\n<td>sticky</td>\n<td>盒位置根据正常流计算，然后相当于该元素在流中的flow root(BFC)和containing block（最近的块级元素）定位。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注：</strong> </p>\n<p>文档流：将窗体<code>自上而下</code>分成一行行，并在每行中按<code>从左至右</code>的顺序排放元素，即为文档流。</p>\n<p>元素脱离文档流的情况：浮动、绝对定位（absolute、fixed）。</p>\n<h2 id=\"三、-详解\"><a href=\"#三、-详解\" class=\"headerlink\" title=\"三、 详解\"></a>三、 详解</h2><p>我们以一个初始未定位示例为参照，其他属性值将和它进行比较。</p>\n<script async src=\"//jsfiddle.net/hysunny/3gwbeu3v/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-0.png\" alt=\"position-0\"></p>\n<h3 id=\"1-static\"><a href=\"#1-static\" class=\"headerlink\" title=\"1. static\"></a>1. static</h3><p>默认值。没有定位，元素出现在正常流中（忽略top，bottom，left，right或者z-index声明）</p>\n<p> <strong>解释</strong>：position设置为static或不设定position属性时，元素遵循正常的文档流，对象占用文档空间，该定位方式下，top、right、left、bottom、z-index属性是无效的。</p>\n<p> 示例：<br> <script async src=\"//jsfiddle.net/hysunny/zj2ogz8m/embed/html,css,result/\"></script></p>\n<p> 通过上例，可以看出position属性设置为static和不设置其实是一样的~</p>\n<p>所以，通常此属性值可以不设置，除非要<strong>覆盖之前的定义</strong>。下面举个栗子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">A</span>页面</div><div class=\"line\"><span class=\"selector-id\">#div-1</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>:absolute；</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">B</span>页面</div><div class=\"line\"><span class=\"selector-id\">#div-1</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>:absolute；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>页面B中`position:static;是为了覆盖页面A中position的定义。</p>\n<h3 id=\"2-relative\"><a href=\"#2-relative\" class=\"headerlink\" title=\"2. relative\"></a>2. relative</h3><p>生成相对定位的元素，相对于其正常位置进行定位。</p>\n<p><strong>解释：</strong> </p>\n<p>(1）position设置为relative时，top、right、left、bottom等属性有效，相对其<strong>正常位置</strong>移。</p>\n<p>(2）position设置为relative时，元素遵照正常的文档流，占据文档空间，但是占据的文档空间<strong>不会</strong>随top、right、left、bottom的偏移而发生变动，也就是说，它后面的元素是依据前一个元素正常位置（即未设置top、right、left、bottom属性之前）进行的定位。</p>\n<p>(3）position设置为relative时，如果没有进行任何的top、right、left、bottom设置，元素不会进行任何位置的改变。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/ae8s2cm4/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-1.png\" alt=\"position-1\"></p>\n<blockquote>\n<p>虚线是初始的位置空间。</p>\n</blockquote>\n<p>由图我们可以看出，相对定位是相对元素原本在文档流中的位置而进行的偏移。并且它后面的元素——second是依据虚线位置，也就是元素原本在文档流中的位置而进行的定位。</p>\n<p>好了，我们现在知道了top、right、left、bottom等属性不会改变relative定位的元素所占据的文档空间。，那么margin、padding会改变该元素占据的文档空间吗？我们来试一下：</p>\n<p>css代码中添加margin属性：</p>\n<script async src=\"//jsfiddle.net/hysunny/vxc9ctqs/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-2.png\" alt=\"position-2\"></p>\n<p>由图可以看出，我们将外边距设置为20px，second元素向下偏移40px，所以margin可以改变元素所占文档空间！同理，padding也可改变元素所占文档空间，这里不多做演示。</p>\n<h3 id=\"3-absolute\"><a href=\"#3-absolute\" class=\"headerlink\" title=\"3. absolute\"></a>3. absolute</h3><p>生成绝对定位的元素，相对于非static定位的第一个父元素进行定位。</p>\n<p><strong>解释</strong>：position设置为absolute，元素会脱离文档流，整个元素不再占据文档空间，就只能相对<strong>非static</strong>定位的<strong>第一个</strong>父元素进行定位<br>(1）absolute在无父级是非static定位时以<html>标签作为原点定位，而relative和static方式在最外层时是以<body>标签作为原点定位。<html>标签和<body>标签相差9px左右。</body></html></body></html></p>\n<p>(2）position设置为absolute或fixed时，必须指定left、right、top、bottom属性中的<strong>至少一个</strong>，否则left、right、top、bottom属性会使用它们的默认值auto，这将导致对象遵从正常的HTML布局规则，在前一个对象之后立即被呈递，简单讲就是都变成relative，会占用文档空间，不会脱离文档流。若多设，比如top和bottom一同存在的话，那么只有top生效；left和right一同存在的话，那么只有left生效。</p>\n<p>(3）绝对（absolute）定位对象和相对（relative）定位对象在可视区域之外会导致滚动条出现。而固定（fixed）定位对象放置在可视区域之外，滚动条不会出现。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/q325w0k6/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-3.png\" alt=\"position-3\"></p>\n<p>由此例我们可以发现absolute相对html定位，relative相对body定位。</p>\n<p>下面我们再来看看对absolute定位的元素的除static外第一个父元素设置margin/padding，看看会不会对文档空间有影响。</p>\n<p>在absolute定位中添加margin/padding属性：</p>\n<script async src=\"//jsfiddle.net/hysunny/59xv1qmx/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-4.png\" alt=\"position-4\"></p>\n<p>由上图我们可以看出，父元素的margin会让子元素的absolute定位跟着偏移，而padding却不会让子元素发生偏移。总结：absolute是根据父元素的<code>border</code>进行的定位。</p>\n<h3 id=\"4-fixed\"><a href=\"#4-fixed\" class=\"headerlink\" title=\"4.fixed\"></a>4.fixed</h3><p>生成绝对定位的元素，相对于浏览器窗口进行定位。</p>\n<p><strong>解释：</strong> fixed定位，又称固定定位，它和absolute定位一样，都脱离了文档流，并且能够根据top、right、left、bottom属性进行定位，但不同的是fixed是根据<code>窗口</code>为原点进行偏移定位的，也就是说它不会根据滚动条的滚动而进行偏移。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/cubxLga9/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-5.png\" alt=\"position-5\"></p>\n<h3 id=\"5-sticky\"><a href=\"#5-sticky\" class=\"headerlink\" title=\"5. sticky\"></a>5. sticky</h3><p>粘性定位。CSS3新属性。它的表现类似<code>position:relative</code>和<code>position:fixed的</code>合体，在目标区域在屏幕中可见时，它的行为就像<code>position:relative</code>; 而当页面滚动超出目标区域时，它的表现就像<code>position:fixed</code>，它会固定在目标位置。</p>\n<p>目前<code>position: sticky;</code>的浏览器兼容性还比较差。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/rztoc45w/embed/html,css,result/\"></script>\n\n\n<h3 id=\"6-inherit\"><a href=\"#6-inherit\" class=\"headerlink\" title=\"6. inherit\"></a>6. inherit</h3><p>规定应该从父元素继承position属性的值。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/4uLp2ybv/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-6.png\" alt=\"position-6\"></p>\n<p>运行，我们发现second继承了first的position属性：fixed。同时超出可视区域之外时不会出现滚动条。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-相对定位的属性：\"><a href=\"#1-相对定位的属性：\" class=\"headerlink\" title=\"1. 相对定位的属性：\"></a>1. 相对定位的属性：</h3><p>(1）如果设定了top、right、left、bottom等属性，并且父元素<code>没有</code>设定position属性，元素以其父元素的左上角为原点进行定位。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/z2L92kqz/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-7.png\" alt=\"position-7\"></p>\n<p>(2）如果设定了top、right、left、bottom等属性，并且父元素设定position属性（无论是absolute还是relative），则以父元素的左上角为原点进行定位，位置由top、right、left、bottom决定，但是如果父元素存在padding属性，则以<code>content</code>的左上角为原点进行定位。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/2jgk2nzv/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-8.png\" alt=\"position-8\"></p>\n<p><img src=\"/images/position-9.png\" alt=\"position-9\"></p>\n<blockquote>\n<p>虚线框为正常原始位置。<br>点线框为content内区域</p>\n</blockquote>\n<p>我们可以看出，元素是以content为原点进行定位的~</p>\n<p>以上两点总结：相对定位总是以父元素左上角为原点进行定位的，如果父元素不存在或没有position属性或position属性值为static，则以浏览器左上角进行定位。</p>\n<h3 id=\"2-绝对定位的属性\"><a href=\"#2-绝对定位的属性\" class=\"headerlink\" title=\"2. 绝对定位的属性\"></a>2. 绝对定位的属性</h3><p>(1）如果设定了top、right、left、bottom等属性，并且父元素<code>没有</code>设定position属性，元素以浏览器左上角为原点进行定位，位置由top、right、left、bottom决定。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/dw2wfh6n/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-10.png\" alt=\"position-10\"></p>\n<p>由图可以看出，是相对于浏览器左上角进行定位的~</p>\n<p>(2）如果设定了top、right、left、bottom等属性，并且父元素设定position属性（无论是absolute还是relative），则以父元素的左上角为原点进行定位，位置由top、right、left、bottom决定。但是父元素存不存在padding属性，对定位原点没有影响。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/2yL8Lo3k/embed/html,css,result/\"></script>\n\n<p><img src=\"/images/position-11.png\" alt=\"position-11\"></p>\n<blockquote>\n<p>虚线框为正常原始位置。<br>点线框为border内区域</p>\n</blockquote>\n<p>我们可以看出，父元素的padding并没有影响到子元素的定位。</p>\n<p>由以上两点可以总结出：<br>若想把一个定位为absolute的元素定位于其父元素内</p>\n<p>必须满足两个条件：</p>\n<p> 1）至少设定top、right、left、bottom中的一个</p>\n<p> 2）父元素设定position属性（值非static）</p>\n<p> 完。</p>\n<hr>\n<p>总结内容参考以下：</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"external\">MDN: position</a><br><a href=\"http://www.jb51.net/web/77495.html\" target=\"_blank\" rel=\"external\">css中position属性(absolute|relative|static|fixed)概述及应用</a><br><a href=\"https://segmentfault.com/a/1190000000680773\" target=\"_blank\" rel=\"external\">详解css相对定位和绝对定位</a></p>\n<p>十分感谢你们的分享~n(<em>≧▽≦</em>)n~</p>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/8789b96cfceeeb31786f83fcd68d6ff0.html\" target=\"_blank\" rel=\"external\">CSS position属性总结</a>，现迁移至此。</p>\n","categories":["CSS"],"tags":["CSS"]},{"title":"CSS选择器、优先级以及!important知识总结","url":"http://hysunny.me/2015/08/12/css-selector/","content":"<h2 id=\"一、CSS选择器\"><a href=\"#一、CSS选择器\" class=\"headerlink\" title=\"一、CSS选择器\"></a>一、CSS选择器</h2><p>关于CSS选择器，首先请看这里：<a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"external\">CSS 选择器参考手册</a> </p>\n<p>通过以上，我们可以将CSS选择器分为以下几种：</p>\n<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><ol>\n<li>ID选择器（#footer），匹配所有id属性等于footer的元素。 </li>\n<li>类选择器（.info），匹配所有class属性中包含info的元素。</li>\n<li>通用选择器（*），匹配任何元素。</li>\n<li>标签选择器（E），匹配所有使用E标签的元素。</li>\n<li>同级元素选择器（E~F ），匹配任何在E元素之后的同级F元素(CSS3)。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#footer</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#999</span>;&#125;</div><div class=\"line\"><span class=\"selector-class\">.info</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;&#125;</div><div class=\"line\">* &#123; <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;<span class=\"attribute\">padding</span>: <span class=\"number\">0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">div</span> &#123; <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> <span class=\"number\">#000000</span> solid; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> ~ <span class=\"selector-tag\">ul</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#000000</span>; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>说明：以下E表示元素，attr表示属性，val表示属性的值。</p>\n<ol>\n<li><p><code>E[attr]</code>选择器</p>\n<p> 匹配所有具有attr属性的E元素，不考虑它的值。（注：E在此处可以省略，比如“[checked]”.）</p>\n<p> 示例1：匹配所有含有title属性的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/qbLthqdo/embed/html,css,result/\"></script>\n\n<p> 示例2：匹配所有含有title属性的元素</p>\n <script async src=\"//jsfiddle.net/hysunny/xsero02u/1/embed/html,css,result/\"></script>\n\n<p> 看出区别了么~示例2就是比示例1省略了元素名div~    </p>\n</li>\n<li><p><code>E[attr=val]</code></p>\n<p> 匹配所有attr属性值为val的E元素。（注：同上，这里的E也可以省略。）</p>\n<p> 示例：匹配所有class值为test的p元素</p>\n <script async src=\"//jsfiddle.net/hysunny/2bpw297m/embed/html,css,result/\"></script>\n</li>\n<li><p><code>E[attr~=val]</code></p>\n<p> 匹配具有attr属性且属性值用空格分隔的字符列表。</p>\n<p> 示例：匹配具有class属性且其中一个属性值为name的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/fdpt62vw/embed/html,css,result/\"></script>\n\n<p> 运行代码，我们可以看到第一个div会应用上面的样式~</p>\n</li>\n<li><p><code>E[attr|=val]</code></p>\n<p> 匹配具有attr属性且属性值为用连接符（-）分隔的字符串，并以val开头的E元素。</p>\n<p> 示例: 匹配所有以test开头并以-连接的具有class属性的div元素</p>\n <script async src=\"//jsfiddle.net/hysunny/51L8p5jh/embed/html,css,result/\"></script>\n\n<p> 运行代码，可以看出第二个div会应用上面的样式~</p>\n</li>\n<li><p><code>E[attr^=&quot;val&quot;]</code>,属性attr的值以”val”开头的元素（CSS3）。</p>\n</li>\n<li><code>E[attr$=“val”]</code>,属性attr的值以”val”结尾的元素（CSS3）。</li>\n<li><code>E[attr*=&quot;val&quot;]</code>,属性attr的值包含”val”字符串的元素（CSS3）。    </li>\n</ol>\n<h3 id=\"组合选择器\"><a href=\"#组合选择器\" class=\"headerlink\" title=\"组合选择器\"></a>组合选择器</h3><ol>\n<li><p>多元素选择器（<code>E, F</code>），同时匹配多有E元素或F元素。</p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/5e4vunwt/embed/html,css,result/\"></script>\n</li>\n<li><p>后代选择器（<code>E F</code>），匹配所有属于E元素后代的F元素，E和F之间用空格分隔。    </p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/3u5edmcr/embed/html,css,result/\"></script>\n</li>\n<li><p>子元素选择器（<code>E &gt; F</code>）， 匹配所有E元素的子元素F。</p>\n<p> 示例：</p>\n <script async src=\"//jsfiddle.net/hysunny/u2gtgbzu/embed/html,css,result/\"></script>\n</li>\n<li><p>相邻选择器（<code>E + F</code>），匹配所有紧随E元素之后的同级元素F。</p>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/0xf31rbk/embed/html,css,result/\"></script>\n\n<p>可以发现，我们的样式只对紧跟div的第一个p元素起作用~</p>\n</li>\n</ol>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>说明：以下E表示元素</p>\n<h4 id=\"CSS2-1中的伪类：\"><a href=\"#CSS2-1中的伪类：\" class=\"headerlink\" title=\"CSS2.1中的伪类：\"></a>CSS2.1中的伪类：</h4><ol>\n<li><code>E:first-child</code>, 匹配父元素的第一个元素。</li>\n<li><code>E:link</code>, 匹配所有未被点击的链接.</li>\n<li><code>E:visited</code>, 匹配所有已被点击的链接。</li>\n<li><code>E:active</code>, 匹配鼠标已经将其按下，还没释放的E元素。</li>\n<li><code>E:hover</code>, 匹配鼠标悬停其上的E元素。</li>\n<li><code>E:focus</code>, 匹配获得当前焦点的E元素。</li>\n<li><code>E:lang(c)</code>, 匹配lang属性等于c的E元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-child</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">font-style</span>: italic;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=text]</span><span class=\"selector-pseudo\">:focus</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#ffe</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=text]</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">:hover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">q</span><span class=\"selector-pseudo\">:lang(sv)</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">quotes</span>: <span class=\"string\">\"\\201D\"</span> <span class=\"string\">\"\\201D\"</span> <span class=\"string\">\"\\2019\"</span> <span class=\"string\">\"\\2019\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS2-1中的伪元素\"><a href=\"#CSS2-1中的伪元素\" class=\"headerlink\" title=\"CSS2.1中的伪元素\"></a>CSS2.1中的伪元素</h4><ol>\n<li><code>E:first-line</code>, 匹配E元素的第一行。</li>\n<li><code>E:first-letter</code>, 匹配E元素的第一个字母。</li>\n<li><code>E:before</code>, 在E元素之前插入生成的内容。</li>\n<li><code>E:after</code>, 在E元素之后插入生成的内容。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-line</span> &#123; </div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold; </div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#600</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.preamble</span><span class=\"selector-pseudo\">:first-letter</span> &#123; </div><div class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5em</span>; </div><div class=\"line\">  <span class=\"attribute\">font-weight</span>: bold; </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.cbb</span><span class=\"selector-pseudo\">:before</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</div><div class=\"line\">  <span class=\"attribute\">display</span>: block;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">17px</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">18px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(top.png) no-repeat <span class=\"number\">0</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> -<span class=\"number\">18px</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:link</span><span class=\"selector-pseudo\">:after</span> &#123;</div><div class=\"line\"> <span class=\"attribute\">content</span>: <span class=\"string\">\" (\"</span> <span class=\"built_in\">attr</span>(href) <span class=\"string\">\") \"</span>; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中与用户界面有关的伪类\"><a href=\"#CSS3中与用户界面有关的伪类\" class=\"headerlink\" title=\"CSS3中与用户界面有关的伪类\"></a>CSS3中与用户界面有关的伪类</h4><ol>\n<li><code>E:enabled</code>, 匹配表单中激活的元素。</li>\n<li><code>E:disabled</code>, 匹配表单中禁用的元素。</li>\n<li><code>E:checked</code>, 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素。</li>\n<li><code>E::selection</code>, 匹配用户当前选中的元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-attr\">[type=\"text\"]</span><span class=\"selector-pseudo\">:disabled</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ddd</span>; &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中的结构性伪类\"><a href=\"#CSS3中的结构性伪类\" class=\"headerlink\" title=\"CSS3中的结构性伪类\"></a>CSS3中的结构性伪类</h4><ol>\n<li><code>E:root</code>, 匹配文档的根元素，对于HTML文档，就是HTML元素。</li>\n<li><code>E:nth-child(n)</code>, 匹配其父元素的第n个子元素，第一个编号为1。</li>\n<li><code>E:nth-last-child(n)</code>, 匹配其父元素的倒数第n个子元素，第一个编号为1。</li>\n<li><code>E:nth-of-type(n)</code>, 与:nth-child()作用类似，但是仅匹配使用同种标签的元素。</li>\n<li><code>E:nth-last-of-type(n)</code>, 与:nth-last-child()作用类似，但是仅匹配使用同种标签的元素。</li>\n<li><code>E:last-child</code>, 匹配父元素的最后一个子元素，等同于:nth-last-child(1)。</li>\n<li><code>E:first-of-type</code>, 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1).</li>\n<li><code>E:last-of-type</code>, 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)。</li>\n<li><code>E:only-child</code>, 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或:nth-child(1):nth-last-child(1).</li>\n<li><code>E:only-of-type</code>, 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或:nth:first-of-type(1):nth-last-of-type(1).</li>\n<li><code>E:empty</code>, 匹配一个不包含任何子元素的元素，注意：文本节点也被看作子元素。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(odd)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>;&#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(even)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3n+0)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:nth-child(3n)</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#f00</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-child(2n+11)</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">tr</span><span class=\"selector-pseudo\">:nth-last-child(2)</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:last-child</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:only-child</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:empty</span> &#123; <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>; &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3的反选伪类\"><a href=\"#CSS3的反选伪类\" class=\"headerlink\" title=\"CSS3的反选伪类\"></a>CSS3的反选伪类</h4><p><code>E:not(s)</code>,匹配不符合当前选择器的任何元素</p>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">:not(p)</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"CSS3中的-target伪类\"><a href=\"#CSS3中的-target伪类\" class=\"headerlink\" title=\"CSS3中的:target伪类\"></a>CSS3中的:target伪类</h4><p><code>E:target</code>,匹配文档中特定”id”点击后的效果</p>\n<p>示例：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">h2</span><span class=\"selector-pseudo\">:target</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">color</span>: white;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#f60</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"后代元素选择器和子元素选择器的区别\"><a href=\"#后代元素选择器和子元素选择器的区别\" class=\"headerlink\" title=\"后代元素选择器和子元素选择器的区别\"></a>后代元素选择器和子元素选择器的区别</h3><p>这里我们简单讨论下后代元素选择器和子元素选择器的区别</p>\n<ol>\n<li><p>写法不一样：</p>\n<p> 后代元素选择器标识：空格</p>\n<p>   如：<code>ul li{ width:150px; }</code>,ul和li之间用空格隔开</p>\n<p> 子元素选择器标识：&gt;</p>\n<p>   如：<code>ul&gt;li{ width:150px; }</code>,ul和li之间用&gt;隔开</p>\n</li>\n<li><p>功能不一样<br> 接着上例来说:</p>\n<p> 后代选择器是选择ul包围的,所以元素中的所有li元素，包括子元素、孙元素、曾孙元素等等等。</p>\n<p> 子选择器仅仅选择ul包围的 子元素中的 li元素，不包括孙元素、曾孙元素等等等。</p>\n</li>\n<li><p>兼容性不一样：</p>\n<p> 后代选择器是所有浏览器都兼容的，都可使用。</p>\n<p> 子选择器在IE6、IE7、IE8中则是不被支持的选择器，各自bug！</p>\n</li>\n</ol>\n<p>示例：</p>\n<script async src=\"//jsfiddle.net/hysunny/ouhvho5v/embed/html,css,result/\"></script>    \n\n<h2 id=\"二、CSS优先级\"><a href=\"#二、CSS优先级\" class=\"headerlink\" title=\"二、CSS优先级\"></a>二、CSS优先级</h2><h3 id=\"什么是CSS优先级？\"><a href=\"#什么是CSS优先级？\" class=\"headerlink\" title=\"什么是CSS优先级？\"></a>什么是CSS优先级？</h3><p>CSS优先级是指CSS样式在浏览器中被解析的<code>先后顺序</code>。</p>\n<h3 id=\"样式的优先级\"><a href=\"#样式的优先级\" class=\"headerlink\" title=\"样式的优先级\"></a>样式的优先级</h3><p>多重样式（Mutiple Styles）：如果外部样式、内部样式和内联样式同时应用于同一个元素，就是多重样式的使用情况。</p>\n<p>一般情况下，（<code>外部</code>样式）External style sheet &lt;（<code>内部</code>样式）Internal style sheet &lt;（<code>内联</code>样式）Inline style</p>\n<p><strong>例外</strong>：如果外部样式放在内部样式的后面，则外部样式将会覆盖内部样式。</p>\n<p>示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">utf-8</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"css\">    <span class=\"comment\">/* 内部样式 */</span></span></div><div class=\"line\"><span class=\"css\">    <span class=\"selector-tag\">h3</span>&#123;<span class=\"attribute\">color</span>:green;&#125;</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">&nbsp</div><div class=\"line\">  <span class=\"comment\">&lt;!-- 外部样式 style.css --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>测试！<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"选择器的优先级\"><a href=\"#选择器的优先级\" class=\"headerlink\" title=\"选择器的优先级\"></a>选择器的优先级</h3><p>给不同的选择器分配不同的权值</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>内联样式（style=””）</th>\n<th>id选择器</th>\n<th>类选择器/属性选择器/伪类选择器</th>\n<th>标签选择器</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>权重</td>\n<td>1000</td>\n<td>100</td>\n<td>10</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>解释：</p>\n<ol>\n<li>内联样式表的权值最高1000;</li>\n<li>id选择器权值100;</li>\n<li>类选择器/属性选择器/伪类选择器权值10;</li>\n<li>HTML标签选择器权值为1.</li>\n</ol>\n<p>示例</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"css\">      <span class=\"selector-id\">#redP</span> <span class=\"selector-tag\">p</span> &#123;</span></div><div class=\"line\"><span class=\"css\">         <span class=\"comment\">/* 权值 = 100+1=101 */</span></span></div><div class=\"line\"><span class=\"css\">         <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#F00</span>;  <span class=\"comment\">/* 红色 */</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"undefined\">      </span></div><div class=\"line\"><span class=\"css\">      <span class=\"selector-id\">#redP</span> <span class=\"selector-class\">.red</span> <span class=\"selector-tag\">em</span> &#123;</span></div><div class=\"line\"><span class=\"css\">         <span class=\"comment\">/* 权值 = 100+10+1=111 */</span></span></div><div class=\"line\"><span class=\"css\">         <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#00F</span>; <span class=\"comment\">/* 蓝色 */</span></span></div><div class=\"line\"><span class=\"undefined\">      </span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"undefined\">      </span></div><div class=\"line\"><span class=\"css\">      <span class=\"selector-id\">#redP</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">span</span> <span class=\"selector-tag\">em</span> &#123;</span></div><div class=\"line\"><span class=\"css\">         <span class=\"comment\">/* 权值 = 100+1+1+1=103 */</span></span></div><div class=\"line\"><span class=\"css\">         <span class=\"selector-tag\">color</span>:<span class=\"selector-id\">#FF0</span>;<span class=\"comment\">/*黄色*/</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"redP\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red\"</span>&gt;</span>red</div><div class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>em red<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>red<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>结果：标签内的数据显示为蓝色。</p>\n<h3 id=\"CSS优先级法则\"><a href=\"#CSS优先级法则\" class=\"headerlink\" title=\"CSS优先级法则\"></a>CSS优先级法则</h3><p>比较样式的优先级是，只需统计不同选择器的个数，然后与对应的权值相乘即可。根据结果便可得出优先级。</p>\n<ol>\n<li>结果较大的优先级较高；</li>\n<li>结果相同，则<code>后定义</code>的优先级较高</li>\n<li>创作者的优先级高于浏览者，网页编写者设置的CSS样式的优先权高于浏览器所设置的样式。</li>\n<li>继承的CSS样式优先级低于后来指定的CSS样式</li>\n<li>若样式值中含有<code>!important</code>，则该值优先级最高</li>\n</ol>\n<p>看到这里，有些同学是不是对!important有点迷惑呀~为什么有了它，就优先级最高呐~下面我们再来详细讲一讲!important~</p>\n<h2 id=\"三、-important知识点\"><a href=\"#三、-important知识点\" class=\"headerlink\" title=\"三、!important知识点\"></a>三、!important知识点</h2><h3 id=\"important简介\"><a href=\"#important简介\" class=\"headerlink\" title=\"!important简介\"></a>!important简介</h3><p><code>!important</code> 是CSS1就定义的语法，作用是提高指定样式的应用优先权。</p>\n<p>语法格式：<code>{cssRule !important}</code>，即写在定义的最后面，例如：<code>box { color: red !important}</code></p>\n<p>声明了<code>!important</code>的样式，具有最高的优先级，相当于写在最下面（最后定义）</p>\n<h3 id=\"IE-6-0下的-important\"><a href=\"#IE-6-0下的-important\" class=\"headerlink\" title=\"IE 6.0下的!important\"></a>IE 6.0下的!important</h3><p>IE 6.0<code>不完全</code>支持!important</p>\n<p>IE支持重定义中的!important，例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#e00</span> <span class=\"meta\">!important</span>; &#125;</div><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>:<span class=\"number\">#000</span>; &#125;</div></pre></td></tr></table></figure>\n<p>你将会发现定义了样式<code>class=&quot;yuanxin&quot;</code>时，在IE下，字体显示为红色（#e00）。<br>但不支持同一定义中的<code>!important</code>。例如：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.yuanxin</span> &#123; <span class=\"attribute\">color</span>: <span class=\"number\">#e00</span> <span class=\"meta\">!important</span>; <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>; &#125;</div></pre></td></tr></table></figure>\n<p>此时在IE6下不支持，你将会发现定义了样式<code>class=&quot;yuanxin&quot;</code>时，字体显示为黑色（#000）。</p>\n<p><strong>解释</strong>：</p>\n<p>important的样式属性和覆盖它的样式属性单独使用时(不在一个{}里)，IE 6.0认为!important优先级较高，否则当含!important的样式属性被同一个{}里的样式覆盖时，IE 6.0认为!important较低!<br>再举一个例子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*样式1*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span> &#123; <span class=\"attribute\">width</span>:<span class=\"number\">100</span> <span class=\"meta\">!important</span>; &#125; <span class=\"comment\">/*有效*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span> &#123; <span class=\"attribute\">width</span>:<span class=\"number\">50px</span>; &#125; <span class=\"comment\">/*无效*/</span></div><div class=\"line\"><span class=\"comment\">/*样式2*/</span></div><div class=\"line\"><span class=\"selector-id\">#a</span> &#123; <span class=\"attribute\">width</span>:<span class=\"number\">100px</span> <span class=\"meta\">!important</span>; <span class=\"attribute\">width</span>:<span class=\"number\">50px</span>; &#125; <span class=\"comment\">/*width:100px无效，width:50px 有效*/</span></div></pre></td></tr></table></figure>\n<p>因为IE 6.0一直都不完全支持这个语法，而其他的浏览器都支持。因此我们就可以利用这一点来分别利用!important，我们可以针对IE和非IE浏览器设置不同的样式，只要在非IE浏览器样式的后面加上!important。</p>\n<p>完。</p>\n<hr>\n<p>总结内容参考以下：</p>\n<p><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\" rel=\"external\">w3school_CSS 选择器参考手册</a><br><a href=\"http://www.ruanyifeng.com/blog/2009/03/css_selectors.html\" target=\"_blank\" rel=\"external\">阮一峰_CSS选择器笔记</a><br><a href=\"http://www.jb51.net/css/67029.html\" target=\"_blank\" rel=\"external\">css选择器优先级深入理解</a><br><a href=\"http://www.cnblogs.com/xugang/archive/2010/09/24/1833760.html\" target=\"_blank\" rel=\"external\">CSS 的优先级机制[总结]</a></p>\n<p>十分感谢你们的分享~n(<em>≧▽≦</em>)n~</p>\n<p>注：原文章首发于：<a href=\"http://www.qdfuns.com/notes/15972/428bcf01ddf5adf75e5c3a3bdaccc44d.html\" target=\"_blank\" rel=\"external\">CSS选择器、优先级以及!important知识总结</a>，现迁移至此。</p>\n","categories":["CSS"],"tags":["CSS"]},{"title":"about","url":"http://hysunny.me/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://hysunny.me/category/index.html","content":"","categories":[],"tags":[]},{"title":"demo","url":"http://hysunny.me/demo/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://hysunny.me/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://hysunny.me/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://hysunny.me/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://hysunny.me/tag/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/BFC-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            overflow: hidden;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/BFC-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            float: right;\n            width: 200px;\n            background-color: green;\n        }\n        .wrap_content{\n            overflow: hidden;\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n    <div class=\"wrap_content\">\n        我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/flex-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            display: flex;\n            display: -webkit-flex;\n        }\n        .wrap_left{\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            flex-grow:1;\n            -webkit-flex-grow:1;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/flex-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            display: flex;\n            display: -webkit-flex;\n        }\n        .wrap_left{\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            width: 200px;\n            background-color: green;\n        }\n        .wrap_content{\n            flex-grow:1;\n            -webkit-flex-grow:1;\n            background-color: yellow;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_content\">\n        我是中间栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            margin: 10px;\n        }\n        .wrap_left{\n            float: left;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-negative-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            float: left;;\n            width: 100%;\n        }\n        .wrap_left{\n            width: 200px;\n            float: left;\n            margin-left: -100%;\n            background-color: red;\n\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            float: left;\n            margin-left: -200px;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_content\">\n        我是中间栏\n    </div>\n</div>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-negative-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            float: left;\n            width: 100%;\n        }\n        .wrap .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n        .wrap_left{\n            float: left;\n            width: 200px;\n            margin-left: -100%;\n            background-color: red;\n        }\n\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/position-margin-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap{\n            margin: 10px;\n            position: relative;\n        }\n        .wrap_left{\n            position: absolute;\n            width: 200px;\n            background-color: red;\n        }\n        .wrap_right{\n            margin-left: 220px;\n            background-color: green;\n        }\n    </style>\n</head>\n<body>\n<div class=\"wrap\">\n    <div class=\"wrap_left\">\n        我是左栏\n    </div>\n    <div class=\"wrap_right\">\n        我是右栏\n    </div>\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/float-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap_left{\n            width: 200px;\n            float: left;\n            background-color: red;\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            float: right;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n<div class=\"wrap_content\">\n    我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/position-margin-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自适应</title>\n    <style type=\"text/css\">\n        html,body,div{\n            margin: 0;\n            padding: 0;\n        }\n        .wrap_left{\n            width: 200px;\n            position: absolute;\n            background-color: red;\n            left: 0;\n        }\n\n        .wrap_content{\n            margin-left: 220px;\n            margin-right: 220px;\n            background-color: yellow;\n        }\n        .wrap_right{\n            width: 200px;\n            position: absolute;\n            right: 0;\n            background-color: green;\n        }\n\n\n    </style>\n</head>\n<body>\n<div class=\"wrap_left\">\n    我是左栏\n</div>\n<div class=\"wrap_right\">\n    我是右栏\n</div>\n<div class=\"wrap_content\">\n    我是中间栏\n</div>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/table-2.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>两栏布局-左定宽，右自动</title>\n    <style type=\"text/css\">\n        html,body,table{\n            margin: 0;\n            padding: 0;\n        }\n\n    </style>\n</head>\n<body>\n<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\" border=\"1\" height=\"300\">\n    <tr>\n        <td width=\"200\" bgcolor=\"red\"></td>\n        <td bgcolor=\"green\"></td>\n    </tr>\n</table>\n</body>\n</html>","categories":[],"tags":[]},{"title":"","url":"http://hysunny.me/demo/div-css-adaptive-layout/table-3.html","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>三栏布局-两侧定宽，中间自动</title>\n    <style type=\"text/css\">\n        html,body,table{\n            margin: 0;\n            padding: 0;\n        }\n\n    </style>\n</head>\n<body>\n<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\" border=\"1\" height=\"300\">\n    <tr>\n        <td width=\"200\" bgcolor=\"red\"></td>\n        <td bgcolor=\"yellow\"></td>\n        <td width=\"200\" bgcolor=\"green\"></td>\n    </tr>\n</table>\n</body>\n</html>","categories":[],"tags":[]}]